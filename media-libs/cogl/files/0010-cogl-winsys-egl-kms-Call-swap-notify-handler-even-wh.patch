From 22378d572b039e4fe6ceb56e56492470bb461d48 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Kristian=20H=C3=B8gsberg?= <krh@bitplanet.net>
Date: Wed, 23 Apr 2014 22:12:52 -0700
Subject: [PATCH 10/14] cogl-winsys-egl-kms: Call swap notify handler even when
 pageflip ioctl fails

This can happen when we dpms off the output or when login1 takes away
drm master status from our drm fd.  In either case, we need to call
the swap notify handler so that the compositor dosn't get stuck waiting
for that notification.  The compositor should stop repainting shortly in
both cases, as it's either going into dpms off mode or vt switching away.

https://bugzilla.gnome.org/show_bug.cgi?id=728979

Reviewed-by: Neil Roberts <neil@linux.intel.com>
---
 cogl/winsys/cogl-winsys-egl-kms.c | 41 ++++++++++++++++++++++++++-------------
 1 file changed, 28 insertions(+), 13 deletions(-)

diff --git a/cogl/winsys/cogl-winsys-egl-kms.c b/cogl/winsys/cogl-winsys-egl-kms.c
index 958c80f..ec54095 100644
--- a/cogl/winsys/cogl-winsys-egl-kms.c
+++ b/cogl/winsys/cogl-winsys-egl-kms.c
@@ -196,6 +196,31 @@ free_current_bo (CoglOnscreen *onscreen)
 }
 
 static void
+queue_swap_notify_for_onscreen (CoglOnscreen *onscreen)
+{
+  CoglOnscreenEGL *egl_onscreen = onscreen->winsys;
+  CoglOnscreenKMS *kms_onscreen = egl_onscreen->platform;
+  CoglContext *context = COGL_FRAMEBUFFER (onscreen)->context;
+  CoglRenderer *renderer = context->display->renderer;
+  CoglRendererEGL *egl_renderer = renderer->winsys;
+  CoglRendererKMS *kms_renderer = egl_renderer->platform;
+
+  /* We only want to notify that the swap is complete when the
+   * application calls cogl_context_dispatch so instead of
+   * immediately notifying we queue an idle callback */
+  if (!kms_renderer->swap_notify_idle)
+    {
+      kms_renderer->swap_notify_idle =
+        _cogl_poll_renderer_add_idle (renderer,
+                                      flush_pending_swap_notify_idle,
+                                      context,
+                                      NULL);
+    }
+
+  kms_onscreen->pending_swap_notify = TRUE;
+}
+
+static void
 page_flip_handler (int fd,
                    unsigned int frame,
                    unsigned int sec,
@@ -217,19 +242,7 @@ page_flip_handler (int fd,
       CoglRendererEGL *egl_renderer = renderer->winsys;
       CoglRendererKMS *kms_renderer = egl_renderer->platform;
 
-      /* We only want to notify that the swap is complete when the
-       * application calls cogl_context_dispatch so instead of
-       * immediately notifying we queue an idle callback */
-      if (!kms_renderer->swap_notify_idle)
-        {
-          kms_renderer->swap_notify_idle =
-            _cogl_poll_renderer_add_idle (renderer,
-                                          flush_pending_swap_notify_idle,
-                                          context,
-                                          NULL);
-        }
-
-      kms_onscreen->pending_swap_notify = TRUE;
+      queue_swap_notify_for_onscreen (onscreen);
 
       free_current_bo (onscreen);
 
@@ -903,6 +916,8 @@ _cogl_winsys_onscreen_swap_buffers_with_damage (CoglOnscreen *onscreen,
       kms_onscreen->next_fb_id = 0;
       g_slice_free (CoglFlipKMS, flip);
       flip = NULL;
+
+      queue_swap_notify_for_onscreen (onscreen);
     }
   else
     {
-- 
2.0.0

