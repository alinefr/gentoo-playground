diff --git a/Makefile.am b/Makefile.am
index 756ab8b..253564c 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,4 +1,4 @@
-SUBDIRS=dbus bus tools test doc
+SUBDIRS=dbus bus tools test doc samsung_tools
 
 pkgconfigdir = $(libdir)/pkgconfig
 pkgconfig_DATA = dbus-1.pc
diff --git a/autogen.sh b/autogen.sh
index 91d4b09..5a885c0 100755
--- a/autogen.sh
+++ b/autogen.sh
@@ -100,6 +100,7 @@ else
   run_configure=false
 fi
 
+#--enable-developer --enable-verbose-mode
 if $run_configure; then
-    $srcdir/configure --enable-developer --config-cache "$@"
+    $srcdir/configure --enable-abstract-sockets --config-cache --enable-doxygen-docs=no "$@" || exit $?
 fi
diff --git a/bus/Makefile.am b/bus/Makefile.am
index f335e30..12a667c 100644
--- a/bus/Makefile.am
+++ b/bus/Makefile.am
@@ -92,6 +92,13 @@ BUS_SOURCES=					\
 	utils.h					\
 	$(XML_SOURCES)
 
+if ENABLE_KDBUS_TRANSPORT
+BUS_SOURCES+= 				\
+	kdbus-d.c				\
+	kdbus-d.h
+endif
+
+
 dbus_daemon_SOURCES=				\
 	$(BUS_SOURCES)				\
 	main.c
diff --git a/bus/activation.c b/bus/activation.c
index fa6c156..390d475 100644
--- a/bus/activation.c
+++ b/bus/activation.c
@@ -4,6 +4,7 @@
  * Copyright (C) 2003  CodeFactory AB
  * Copyright (C) 2003  Red Hat, Inc.
  * Copyright (C) 2004  Imendio HB
+ * Copyright (C) 2013  Samsung Electronics
  *
  * Licensed under the Academic Free License version 2.1
  *
@@ -1187,7 +1188,16 @@ bus_activation_send_pending_auto_activation_messages (BusActivation  *activation
         {
           DBusConnection *addressed_recipient;
 
-          addressed_recipient = bus_service_get_primary_owners_connection (service);
+#ifdef ENABLE_KDBUS_TRANSPORT
+          /* kdbus change - we can not send anything using phantom connections
+           * (DBusConnection structures for services other than daemon)
+           * so we have to use daemon connection
+           */
+          if(bus_context_is_kdbus(bus_transaction_get_context (transaction)))
+              addressed_recipient = entry->connection;
+          else
+#endif
+              addressed_recipient = bus_service_get_primary_owners_connection (service);
 
           /* Resume dispatching where we left off in bus_dispatch() */
           if (!bus_dispatch_matches (transaction,
diff --git a/bus/bus.c b/bus/bus.c
index a514e31..211ae32 100644
--- a/bus/bus.c
+++ b/bus/bus.c
@@ -2,6 +2,7 @@
 /* bus.c  message bus context object
  *
  * Copyright (C) 2003, 2004 Red Hat, Inc.
+ * Copyright (C) 2013  Samsung Electronics
  *
  * Licensed under the Academic Free License version 2.1
  *
@@ -40,6 +41,11 @@
 #include <dbus/dbus-credentials.h>
 #include <dbus/dbus-internals.h>
 
+#ifdef ENABLE_KDBUS_TRANSPORT
+#include "kdbus-d.h"
+#include <stdlib.h>
+#endif
+
 #ifdef DBUS_CYGWIN
 #include <signal.h>
 #endif
@@ -68,6 +74,9 @@ struct BusContext
   unsigned int keep_umask : 1;
   unsigned int allow_anonymous : 1;
   unsigned int systemd_activation : 1;
+#ifdef ENABLE_KDBUS_TRANSPORT
+  DBusConnection *myKdbusConnection;  //todo maybe can be rafctored and removed
+#endif
 };
 
 static dbus_int32_t server_data_slot = -1;
@@ -261,6 +270,47 @@ setup_server (BusContext *context,
   return TRUE;
 }
 
+#ifdef ENABLE_KDBUS_TRANSPORT
+static int
+init_server_for_kdbus (BusContext  *context,
+                       const char  *address,
+                       DBusError   *error)
+{
+  DBusBusType type;
+  DBusServer* server;
+  char* bus_address;
+
+  if (!strcmp (context->type, "system"))
+    type = DBUS_BUS_SYSTEM;
+  else if (!strcmp (context->type, "session"))
+    type = DBUS_BUS_SESSION;
+  else
+    type = DBUS_BUS_STARTER;
+
+  bus_address = make_kdbus_bus (type, address, error);
+  if (bus_address == NULL)
+    return -1;
+
+  server = empty_server_init (bus_address);
+  if (server == NULL)
+    {
+      free (bus_address);
+      return -1;
+	}
+  if (!_dbus_list_append (&context->servers, server))
+    {
+      free (bus_address);
+      return -2;
+    }
+
+  context->myKdbusConnection = daemon_as_client (type, bus_address, error);
+  if (context->myKdbusConnection == NULL)
+    return -1;
+
+  return 0;
+}
+#endif
+
 /* This code only gets executed the first time the
  * config files are parsed.  It is not executed
  * when config files are reloaded.
@@ -423,49 +473,81 @@ process_config_first_time_only (BusContext       *context,
 
   if (address)
     {
-      DBusServer *server;
-
-      server = dbus_server_listen (_dbus_string_get_const_data(address), error);
-      if (server == NULL)
+#ifdef ENABLE_KDBUS_TRANSPORT
+      if(!strncmp(_dbus_string_get_const_data(address), "kdbus:", strlen("kdbus:")))
         {
-          _DBUS_ASSERT_ERROR_IS_SET (error);
-          goto failed;
+          int ret;
+
+          ret = init_server_for_kdbus (context, _dbus_string_get_const_data (address), error);
+
+          if (ret == -1)
+            goto failed;
+          else if (ret == -2)
+            goto oom;
         }
-      else if (!setup_server (context, server, auth_mechanisms, error))
+      else
+#endif
         {
-          _DBUS_ASSERT_ERROR_IS_SET (error);
-          goto failed;
-        }
-
-      if (!_dbus_list_append (&context->servers, server))
-        goto oom;
+		  DBusServer *server;
+
+		  server = dbus_server_listen (_dbus_string_get_const_data(address), error);
+		  if (server == NULL)
+			{
+			  _DBUS_ASSERT_ERROR_IS_SET (error);
+			  goto failed;
+			}
+		  else if (!setup_server (context, server, auth_mechanisms, error))
+			{
+			  _DBUS_ASSERT_ERROR_IS_SET (error);
+			  goto failed;
+			}
+
+		  if (!_dbus_list_append (&context->servers, server))
+			goto oom;
+      }
     }
   else
     {
       addresses = bus_config_parser_get_addresses (parser);
 
       link = _dbus_list_get_first_link (addresses);
-      while (link != NULL)
+#ifdef ENABLE_KDBUS_TRANSPORT
+	  if (!strcmp (link->data, "kdbus:"))
         {
-          DBusServer *server;
+          int ret;
 
-          server = dbus_server_listen (link->data, error);
-          if (server == NULL)
-            {
-              _DBUS_ASSERT_ERROR_IS_SET (error);
-              goto failed;
-            }
-          else if (!setup_server (context, server, auth_mechanisms, error))
-            {
-              _DBUS_ASSERT_ERROR_IS_SET (error);
-              goto failed;
-            }
+          ret = init_server_for_kdbus (context, link->data, error);
 
-          if (!_dbus_list_append (&context->servers, server))
+          if (ret == -1)
+            goto failed;
+          else if (ret == -2)
             goto oom;
-
-          link = _dbus_list_get_next_link (addresses, link);
         }
+      else
+#endif
+        {
+          while (link != NULL)
+            {
+              DBusServer *server;
+
+              server = dbus_server_listen (link->data, error);
+              if (server == NULL)
+                {
+                  _DBUS_ASSERT_ERROR_IS_SET (error);
+                  goto failed;
+                }
+              else if (!setup_server (context, server, auth_mechanisms, error))
+                {
+                  _DBUS_ASSERT_ERROR_IS_SET (error);
+                  goto failed;
+                }
+
+              if (!_dbus_list_append (&context->servers, server))
+                goto oom;
+
+              link = _dbus_list_get_next_link (addresses, link);
+            }
+       }
     }
 
   context->fork = bus_config_parser_get_fork (parser);
@@ -743,6 +825,10 @@ bus_context_new (const DBusString *config_file,
     }
   context->refcount = 1;
 
+#ifdef ENABLE_KDBUS_TRANSPORT
+  context->myKdbusConnection = NULL;
+#endif
+
   _dbus_generate_uuid (&context->uuid);
 
   if (!_dbus_string_copy_data (config_file, &context->config_file))
@@ -940,6 +1026,39 @@ bus_context_new (const DBusString *config_file,
 
   dbus_server_free_data_slot (&server_data_slot);
 
+#ifdef ENABLE_KDBUS_TRANSPORT
+  if(context->myKdbusConnection)
+  {
+	  DBusString unique_name;
+
+	  if(!bus_connections_setup_connection(context->connections, context->myKdbusConnection))
+	  {
+          _dbus_verbose ("Bus connections setup connection failed for myKdbusConnection!\n");
+          dbus_connection_close (context->myKdbusConnection);
+          dbus_connection_unref (context->myKdbusConnection);
+          goto failed;
+	  }
+	  dbus_connection_set_route_peer_messages (context->myKdbusConnection, FALSE);
+	  _dbus_string_init_const (&unique_name, dbus_bus_get_unique_name(context->myKdbusConnection));
+	  if(!bus_connection_complete (context->myKdbusConnection, &unique_name, error))
+	  {
+		  _dbus_verbose ("Bus connection complete failed for myKdbusConnection!\n");
+		  goto failed;
+	  }
+
+	  if(!register_daemon_name(context->myKdbusConnection))
+	  {
+	      _dbus_verbose ("Registering org.freedesktop.DBus name for daemon failed!\n");
+	      goto failed;
+	  }
+	  if(!register_kdbus_starters(context->myKdbusConnection))
+	  {
+          _dbus_verbose ("Registering kdbus starters for dbus activatable names failed!\n");
+          goto failed;
+	  }
+  }
+#endif
+
   return context;
 
  failed:
@@ -991,6 +1110,19 @@ bus_context_reload_config (BusContext *context,
       _DBUS_ASSERT_ERROR_IS_SET (error);
       goto failed;
     }
+
+#ifdef ENABLE_KDBUS_TRANSPORT
+  if(context->myKdbusConnection)
+  {
+      if(!update_kdbus_starters(context->myKdbusConnection))
+      {
+          _dbus_verbose ("Update kdbus starters for dbus activatable names failed.\n");
+          _DBUS_ASSERT_ERROR_IS_SET (error);
+          goto failed;
+      }
+  }
+#endif
+
   ret = TRUE;
 
   bus_context_log (context, DBUS_SYSTEM_LOG_INFO, "Reloaded configuration");
@@ -1284,6 +1416,13 @@ bus_context_get_reply_timeout (BusContext *context)
   return context->limits.reply_timeout;
 }
 
+#ifdef ENABLE_KDBUS_TRANSPORT
+dbus_bool_t bus_context_is_kdbus(BusContext* context)
+{
+	return context->myKdbusConnection != NULL;
+}
+#endif
+
 void
 bus_context_log (BusContext *context, DBusSystemLogSeverity severity, const char *msg, ...) _DBUS_GNUC_PRINTF (3, 4);
 
diff --git a/bus/bus.h b/bus/bus.h
index 3597884..2d8728e 100644
--- a/bus/bus.h
+++ b/bus/bus.h
@@ -114,6 +114,11 @@ int               bus_context_get_max_services_per_connection    (BusContext
 int               bus_context_get_max_match_rules_per_connection (BusContext       *context);
 int               bus_context_get_max_replies_per_connection     (BusContext       *context);
 int               bus_context_get_reply_timeout                  (BusContext       *context);
+
+#ifdef ENABLE_KDBUS_TRANSPORT
+dbus_bool_t 	  bus_context_is_kdbus							 (BusContext	   *context);
+#endif
+
 void              bus_context_log                                (BusContext       *context,
                                                                   DBusSystemLogSeverity severity,
                                                                   const char       *msg,
diff --git a/bus/connection.c b/bus/connection.c
index ea2d155..0359203 100644
--- a/bus/connection.c
+++ b/bus/connection.c
@@ -2,6 +2,7 @@
 /* connection.c  Client connections
  *
  * Copyright (C) 2003  Red Hat, Inc.
+ * Copyright (C) 2013  Samsung Electronics
  *
  * Licensed under the Academic Free License version 2.1
  * 
@@ -190,6 +191,9 @@ bus_connection_disconnected (DBusConnection *connection)
   BusConnectionData *d;
   BusService *service;
   BusMatchmaker *matchmaker;
+#ifdef ENABLE_KDBUS_TRANSPORT
+  dbus_bool_t is_phantom = FALSE;
+#endif
   
   d = BUS_CONNECTION_DATA (connection);
   _dbus_assert (d != NULL);
@@ -197,6 +201,11 @@ bus_connection_disconnected (DBusConnection *connection)
   _dbus_verbose ("%s disconnected, dropping all service ownership and releasing\n",
                  d->name ? d->name : "(inactive)");
 
+#ifdef ENABLE_KDBUS_TRANSPORT
+  if((d->name) && bus_context_is_kdbus(d->connections->context) && (strcmp(d->name, ":1.1")))
+      is_phantom = TRUE;
+#endif
+
   /* Delete our match rules */
   if (d->n_match_rules > 0)
     {
@@ -305,8 +314,13 @@ bus_connection_disconnected (DBusConnection *connection)
   dbus_connection_set_data (connection,
                             connection_data_slot,
                             NULL, NULL);
-  
-  dbus_connection_unref (connection);
+
+#ifdef ENABLE_KDBUS_TRANSPORT
+  if(is_phantom)
+      dbus_connection_unref_phantom(connection);
+  else
+#endif
+      dbus_connection_unref (connection);
 }
 
 static dbus_bool_t
@@ -995,6 +1009,28 @@ bus_connections_foreach (BusConnections               *connections,
   foreach_inactive (connections, function, data);
 }
 
+#ifdef ENABLE_KDBUS_TRANSPORT
+DBusConnection*
+bus_connections_find_conn_by_name(BusConnections *connections, const char* name)
+{
+    DBusList *link;
+
+    link = _dbus_list_get_first_link (&connections->completed);
+    while (link != NULL)
+      {
+        DBusConnection *connection = link->data;
+        DBusList *next = _dbus_list_get_next_link (&connections->completed, link);
+
+        if (!strcmp(bus_connection_get_name(connection), name))
+          return connection;
+
+        link = next;
+      }
+
+    return NULL;
+}
+#endif
+
 BusContext*
 bus_connections_get_context (BusConnections *connections)
 {
@@ -1351,6 +1387,18 @@ bus_connection_get_n_services_owned (DBusConnection *connection)
   return d->n_services_owned;
 }
 
+#ifdef ENABLE_KDBUS_TRANSPORT
+DBusList**
+bus_connection_get_services_owned (DBusConnection *connection)
+{
+    BusConnectionData *d;
+    d = BUS_CONNECTION_DATA (connection);
+    _dbus_assert (d != NULL);
+
+    return &d->services_owned;
+}
+#endif
+
 dbus_bool_t
 bus_connection_complete (DBusConnection   *connection,
 			 const DBusString *name,
@@ -2046,7 +2094,10 @@ bus_transaction_send_from_driver (BusTransaction *transaction,
   if (!dbus_message_set_sender (message, DBUS_SERVICE_DBUS))
     return FALSE;
 
-  if (bus_connection_is_active (connection))
+#ifdef ENABLE_KDBUS_TRANSPORT
+  if(!bus_context_is_kdbus(bus_transaction_get_context (transaction))) /* we can't set destination on the basis of connection when on kdbus*/
+#endif
+    if (bus_connection_is_active (connection))
     {
       if (!dbus_message_set_destination (message,
                                          bus_connection_get_name (connection)))
diff --git a/bus/connection.h b/bus/connection.h
index 9f4f9ae..418bf9f 100644
--- a/bus/connection.h
+++ b/bus/connection.h
@@ -43,6 +43,10 @@ void            bus_connections_foreach           (BusConnections
 void            bus_connections_foreach_active    (BusConnections               *connections,
                                                    BusConnectionForeachFunction  function,
                                                    void                         *data);
+#ifdef ENABLE_KDBUS_TRANSPORT
+DBusConnection* bus_connections_find_conn_by_name (BusConnections *connections,
+                                                   const char* name);
+#endif
 BusContext*     bus_connections_get_context       (BusConnections               *connections);
 void            bus_connections_increment_stamp   (BusConnections               *connections);
 dbus_bool_t     bus_connections_reload_policy     (BusConnections               *connections,
@@ -81,6 +85,10 @@ dbus_bool_t bus_connection_preallocate_oom_error (DBusConnection *connection);
 void        bus_connection_send_oom_error        (DBusConnection *connection,
                                                   DBusMessage    *in_reply_to);
 
+#ifdef ENABLE_KDBUS_TRANSPORT
+DBusList** bus_connection_get_services_owned (DBusConnection *connection);
+#endif
+
 /* called by signals.c */
 dbus_bool_t bus_connection_add_match_rule      (DBusConnection *connection,
                                                 BusMatchRule   *rule);
diff --git a/bus/dispatch.c b/bus/dispatch.c
index 7a61953..7715800 100644
--- a/bus/dispatch.c
+++ b/bus/dispatch.c
@@ -4,6 +4,7 @@
  * Copyright (C) 2003  CodeFactory AB
  * Copyright (C) 2003, 2004, 2005  Red Hat, Inc.
  * Copyright (C) 2004  Imendio HB
+ * Copyright (C) 2013  Samsung Electronics
  *
  * Licensed under the Academic Free License version 2.1
  *
@@ -36,6 +37,9 @@
 #include <dbus/dbus-internals.h>
 #include <dbus/dbus-misc.h>
 #include <string.h>
+#ifdef ENABLE_KDBUS_TRANSPORT
+#include "kdbus-d.h"
+#endif
 
 #ifdef HAVE_UNIX_FD_PASSING
 #include <dbus/dbus-sysdeps-unix.h>
@@ -218,6 +222,10 @@ bus_dispatch (DBusConnection *connection,
   }
 #endif /* DBUS_ENABLE_VERBOSE_MODE */
 
+  /* Create our transaction */
+  while ((transaction = bus_transaction_new (context)) == NULL)
+            _dbus_wait_for_memory ();
+
   /* If service_name is NULL, if it's a signal we send it to all
    * connections with a match rule. If it's not a signal, there
    * are some special cases here but mostly we just bail out.
@@ -240,18 +248,25 @@ bus_dispatch (DBusConnection *connection,
           result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
           goto out;
         }
-    }
 
-  /* Create our transaction */
-  transaction = bus_transaction_new (context);
-  if (transaction == NULL)
-    {
-      BUS_SET_OOM (&error);
-      goto out;
+#ifdef ENABLE_KDBUS_TRANSPORT
+      if(bus_context_is_kdbus(context))
+      {
+          if (dbus_message_is_signal (message, DBUS_INTERFACE_DBUS, "NameOwnerChanged"))
+          {
+              handleNameOwnerChanged(message, transaction, connection);
+              goto out;
+          }
+      }
+#endif
     }
 
+#ifdef ENABLE_KDBUS_TRANSPORT
   /* Assign a sender to the message */
-  if (bus_connection_is_active (connection))
+  if(bus_context_is_kdbus(context) == FALSE)  //if using kdbus, sender must be set on library side
+#endif
+  {
+    if (bus_connection_is_active (connection))
     {
       sender = bus_connection_get_name (connection);
       _dbus_assert (sender != NULL);
@@ -269,6 +284,7 @@ bus_dispatch (DBusConnection *connection,
        */
       service_name = dbus_message_get_destination (message);
     }
+  }
 
   if (service_name &&
       strcmp (service_name, DBUS_SERVICE_DBUS) == 0) /* to bus driver */
@@ -303,7 +319,11 @@ bus_dispatch (DBusConnection *connection,
       _dbus_string_init_const (&service_string, service_name);
       service = bus_registry_lookup (registry, &service_string);
 
+#ifdef ENABLE_KDBUS_TRANSPORT
+      if (dbus_message_get_auto_start (message) && (service == NULL || bus_service_get_is_kdbus_starter(service)))
+#else
       if (service == NULL && dbus_message_get_auto_start (message))
+#endif
         {
           BusActivation *activation;
           /* We can't do the security policy check here, since the addressed
diff --git a/bus/driver.c b/bus/driver.c
index e95a79d..c69a38c 100644
--- a/bus/driver.c
+++ b/bus/driver.c
@@ -3,6 +3,7 @@
  *
  * Copyright (C) 2003 CodeFactory AB
  * Copyright (C) 2003, 2004, 2005 Red Hat, Inc.
+ * Copyright (C) 2013  Samsung Electronics
  *
  * Licensed under the Academic Free License version 2.1
  *
@@ -40,6 +41,14 @@
 #include <dbus/dbus-marshal-recursive.h>
 #include <string.h>
 
+#ifdef ENABLE_KDBUS_TRANSPORT
+#include "kdbus-d.h"
+#include <stdio.h>
+#include <errno.h>
+#include <limits.h>
+#include <stdlib.h>
+#endif
+
 static DBusConnection *
 bus_driver_get_conn_helper (DBusConnection  *connection,
                             DBusMessage     *message,
@@ -98,6 +107,11 @@ bus_driver_send_service_owner_changed (const char     *service_name,
   dbus_bool_t retval;
   const char *null_service;
 
+#ifdef ENABLE_KDBUS_TRANSPORT
+  if(bus_context_is_kdbus(bus_transaction_get_context (transaction)))
+	  return TRUE;
+#endif
+
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
 
   null_service = "";
@@ -147,6 +161,11 @@ bus_driver_send_service_lost (DBusConnection *connection,
 {
   DBusMessage *message;
 
+#ifdef ENABLE_KDBUS_TRANSPORT
+  if(bus_context_is_kdbus(bus_transaction_get_context (transaction)))
+	  return TRUE;
+#endif
+
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
 
   message = dbus_message_new_signal (DBUS_PATH_DBUS,
@@ -190,6 +209,11 @@ bus_driver_send_service_acquired (DBusConnection *connection,
 {
   DBusMessage *message;
 
+#ifdef ENABLE_KDBUS_TRANSPORT
+  if(bus_context_is_kdbus(bus_transaction_get_context (transaction)))
+	  return TRUE;
+#endif
+
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
 
   message = dbus_message_new_signal (DBUS_PATH_DBUS,
@@ -437,12 +461,26 @@ bus_driver_handle_list_services (DBusConnection *connection,
       return FALSE;
     }
 
-  if (!bus_registry_list_services (registry, &services, &len))
-    {
-      dbus_message_unref (reply);
-      BUS_SET_OOM (error);
-      return FALSE;
-    }
+#ifdef ENABLE_KDBUS_TRANSPORT
+  if(bus_context_is_kdbus(bus_transaction_get_context (transaction)))
+  {
+	  if(!kdbus_list_services (connection, &services, &len))
+	    {
+	      dbus_message_unref (reply);
+	      BUS_SET_OOM (error);
+	      return FALSE;
+	    }
+  }
+  else
+#endif
+  {
+      if (!bus_registry_list_services (registry, &services, &len))
+        {
+          dbus_message_unref (reply);
+          BUS_SET_OOM (error);
+          return FALSE;
+        }
+  }
 
   dbus_message_iter_init_append (reply, &iter);
 
@@ -456,7 +494,11 @@ bus_driver_handle_list_services (DBusConnection *connection,
       return FALSE;
     }
 
+#ifdef ENABLE_KDBUS_TRANSPORT
+  if(!bus_context_is_kdbus(bus_transaction_get_context (transaction))) //not needed for kdbus, we got it from kdbus_list_services
+#endif
   {
+
     /* Include the bus driver in the list */
     const char *v_STRING = DBUS_SERVICE_DBUS;
     if (!dbus_message_iter_append_basic (&sub, DBUS_TYPE_STRING,
@@ -627,13 +669,27 @@ bus_driver_handle_acquire_service (DBusConnection *connection,
   retval = FALSE;
   reply = NULL;
 
-  _dbus_string_init_const (&service_name, name);
+#ifdef ENABLE_KDBUS_TRANSPORT
+  if(bus_context_is_kdbus(bus_transaction_get_context (transaction)))
+  {
+	  if (!bus_registry_acquire_kdbus_service (registry, connection,
+										 message,
+	                                     &service_reply, transaction,
+	                                     error))
+	    goto out;
+  }
+  else
+#endif
+  {
 
-  if (!bus_registry_acquire_service (registry, connection,
-                                     &service_name, flags,
-                                     &service_reply, transaction,
-                                     error))
-    goto out;
+	  _dbus_string_init_const (&service_name, name);
+
+	  if (!bus_registry_acquire_service (registry, connection,
+	                                     &service_name, flags,
+	                                     &service_reply, transaction,
+	                                     error))
+	    goto out;
+  }
 
   reply = dbus_message_new_method_return (message);
   if (reply == NULL)
@@ -677,8 +733,6 @@ bus_driver_handle_release_service (DBusConnection *connection,
 
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
 
-  registry = bus_connection_get_registry (connection);
-
   if (!dbus_message_get_args (message, error,
                               DBUS_TYPE_STRING, &name,
                               DBUS_TYPE_INVALID))
@@ -690,7 +744,18 @@ bus_driver_handle_release_service (DBusConnection *connection,
   reply = NULL;
 
   _dbus_string_init_const (&service_name, name);
+  registry = bus_connection_get_registry (connection);
 
+#ifdef ENABLE_KDBUS_TRANSPORT
+  if(bus_context_is_kdbus(bus_transaction_get_context (transaction)))
+  {
+	  if (!bus_registry_release_service_kdbus (dbus_message_get_sender(message), connection,
+	                                     &service_name, &service_reply,
+	                                     transaction, error))
+	      goto out;
+  }
+  else
+#endif
   if (!bus_registry_release_service (registry, connection,
                                      &service_name, &service_reply,
                                      transaction, error))
@@ -754,9 +819,29 @@ bus_driver_handle_service_exists (DBusConnection *connection,
     }
   else
     {
-      _dbus_string_init_const (&service_name, name);
-      service = bus_registry_lookup (registry, &service_name);
-      service_exists = service != NULL;
+#ifdef ENABLE_KDBUS_TRANSPORT
+	  if(bus_context_is_kdbus(bus_transaction_get_context (transaction)))
+	  {
+		  int inter_ret;
+		  struct nameInfo info;
+
+		  inter_ret = kdbus_NameQuery(name, dbus_connection_get_transport(connection), &info);
+			if((inter_ret == 0) || (inter_ret == -ENOENT) || (inter_ret == -ENXIO))
+				service_exists = (inter_ret == 0) ? TRUE : FALSE;
+			else
+			{
+				_dbus_verbose("kdbus error checking if name exists: err %d (%m)\n", errno);
+				dbus_set_error (error, DBUS_ERROR_FAILED, "Could not determine whether name '%s' exists", name);
+				service_exists = FALSE;
+			}
+	  }
+	  else
+#endif
+	  {
+	      _dbus_string_init_const (&service_name, name);
+	      service = bus_registry_lookup (registry, &service_name);
+	      service_exists = service != NULL;
+	  }
     }
 
   reply = dbus_message_new_method_return (message);
@@ -1026,20 +1111,36 @@ bus_driver_handle_add_match (DBusConnection *connection,
   if (rule == NULL)
     goto failed;
 
-  matchmaker = bus_connection_get_matchmaker (connection);
+#ifdef ENABLE_KDBUS_TRANSPORT
+  if(bus_context_is_kdbus(bus_transaction_get_context (transaction)))
+  {
 
-  if (!bus_matchmaker_add_rule (matchmaker, rule))
-    {
-      BUS_SET_OOM (error);
-      goto failed;
-    }
+	  if (!kdbus_add_match_rule (connection, message, text, error))
+	      goto failed;
 
-  if (!send_ack_reply (connection, transaction,
-                       message, error))
-    {
-      bus_matchmaker_remove_rule (matchmaker, rule);
-      goto failed;
-    }
+	  if (!send_ack_reply (connection, transaction,
+	                       message, error))
+	      goto failed;
+  }
+  else
+#endif
+  {
+
+	  matchmaker = bus_connection_get_matchmaker (connection);
+
+	  if (!bus_matchmaker_add_rule (matchmaker, rule))
+	    {
+	      BUS_SET_OOM (error);
+	      goto failed;
+	    }
+
+	  if (!send_ack_reply (connection, transaction,
+	                       message, error))
+	    {
+	      bus_matchmaker_remove_rule (matchmaker, rule);
+	      goto failed;
+	    }
+  }
 
   bus_match_rule_unref (rule);
 
@@ -1082,6 +1183,14 @@ bus_driver_handle_remove_match (DBusConnection *connection,
   if (rule == NULL)
     goto failed;
 
+#ifdef ENABLE_KDBUS_TRANSPORT
+  if(bus_context_is_kdbus(bus_transaction_get_context (transaction)))
+  {
+	  if(!kdbus_remove_match(connection, message, error))
+		  goto failed;
+  }
+#endif
+
   /* Send the ack before we remove the rule, since the ack is undone
    * on transaction cancel, but rule removal isn't.
    */
@@ -1089,10 +1198,15 @@ bus_driver_handle_remove_match (DBusConnection *connection,
                        message, error))
     goto failed;
 
-  matchmaker = bus_connection_get_matchmaker (connection);
+#ifdef ENABLE_KDBUS_TRANSPORT
+  if(!bus_context_is_kdbus(bus_transaction_get_context (transaction)))
+#endif
+  {
+	  matchmaker = bus_connection_get_matchmaker (connection);
 
-  if (!bus_matchmaker_remove_rule_by_value (matchmaker, rule, error))
-    goto failed;
+	  if (!bus_matchmaker_remove_rule_by_value (matchmaker, rule, error))
+		goto failed;
+  }
 
   bus_match_rule_unref (rule);
 
@@ -1117,6 +1231,9 @@ bus_driver_handle_get_service_owner (DBusConnection *connection,
   BusRegistry *registry;
   BusService *service;
   DBusMessage *reply;
+#ifdef ENABLE_KDBUS_TRANSPORT
+  char unique_name[(unsigned int)(snprintf((char*)base_name, 0, "%llu", ULLONG_MAX) + sizeof(":1."))];
+#endif
 
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
 
@@ -1130,35 +1247,59 @@ bus_driver_handle_get_service_owner (DBusConnection *connection,
 			       DBUS_TYPE_INVALID))
       goto failed;
 
-  _dbus_string_init_const (&str, text);
-  service = bus_registry_lookup (registry, &str);
-  if (service == NULL &&
-      _dbus_string_equal_c_str (&str, DBUS_SERVICE_DBUS))
+#ifdef ENABLE_KDBUS_TRANSPORT
+  if(bus_context_is_kdbus(bus_transaction_get_context (transaction)))
     {
-      /* ORG_FREEDESKTOP_DBUS owns itself */
-      base_name = DBUS_SERVICE_DBUS;
-    }
-  else if (service == NULL)
-    {
-      dbus_set_error (error,
-                      DBUS_ERROR_NAME_HAS_NO_OWNER,
-                      "Could not get owner of name '%s': no such name", text);
-      goto failed;
-    }
-  else
-    {
-      base_name = bus_connection_get_name (bus_service_get_primary_owners_connection (service));
-      if (base_name == NULL)
+      int ret;
+
+      ret = kdbus_get_name_owner(connection, text, unique_name);
+      if(ret == 0)
+        base_name = unique_name;
+      else if((ret == -ENOENT) || (ret == -ENXIO)) //name has no owner
         {
-          /* FIXME - how is this error possible? */
-          dbus_set_error (error,
-                          DBUS_ERROR_FAILED,
-                          "Could not determine unique name for '%s'", text);
+          dbus_set_error (error, DBUS_ERROR_NAME_HAS_NO_OWNER,
+                  "Could not get owner of name '%s': no such name", text);
+          goto failed;
+        }
+      else
+        {
+          dbus_set_error (error, DBUS_ERROR_FAILED,
+                  "Could not determine unique name for '%s'", text);
           goto failed;
         }
-      _dbus_assert (*base_name == ':');
     }
-
+  else
+#endif
+    {
+	  _dbus_string_init_const (&str, text);
+	  service = bus_registry_lookup (registry, &str);
+	  if (service == NULL &&
+		  _dbus_string_equal_c_str (&str, DBUS_SERVICE_DBUS))
+		{
+		  /* ORG_FREEDESKTOP_DBUS owns itself */
+		  base_name = DBUS_SERVICE_DBUS;
+		}
+	  else if (service == NULL)
+		{
+		  dbus_set_error (error,
+						  DBUS_ERROR_NAME_HAS_NO_OWNER,
+						  "Could not get owner of name '%s': no such name", text);
+		  goto failed;
+		}
+	  else
+		{
+		  base_name = bus_connection_get_name (bus_service_get_primary_owners_connection (service));
+		  if (base_name == NULL)
+			{
+			  /* FIXME - how is this error possible? */
+			  dbus_set_error (error,
+							  DBUS_ERROR_FAILED,
+							  "Could not determine unique name for '%s'", text);
+			  goto failed;
+			}
+		  _dbus_assert (*base_name == ':');
+		}
+  }
   _dbus_assert (base_name != NULL);
 
   reply = dbus_message_new_method_return (message);
@@ -1225,7 +1366,11 @@ bus_driver_handle_list_queued_owners (DBusConnection *connection,
       if (! _dbus_list_append (&base_names, dbus_service_name))
         goto oom;
     }
+#ifdef ENABLE_KDBUS_TRANSPORT
+  else if (!bus_context_is_kdbus(bus_transaction_get_context (transaction)) && (service == NULL))
+#else
   else if (service == NULL)
+#endif
     {
       dbus_set_error (error,
                       DBUS_ERROR_NAME_HAS_NO_OWNER,
@@ -1234,10 +1379,20 @@ bus_driver_handle_list_queued_owners (DBusConnection *connection,
     }
   else
     {
-      if (!bus_service_list_queued_owners (service,
-                                           &base_names,
-                                           error))
-        goto failed;
+#ifdef ENABLE_KDBUS_TRANSPORT
+      if(bus_context_is_kdbus(bus_transaction_get_context (transaction)))
+        {
+          if(!kdbus_list_queued (connection,  &base_names, text ,error))
+            goto failed;
+        }
+      else
+#endif
+        {
+          if (!bus_service_list_queued_owners (service,
+              &base_names,
+              error))
+            goto failed;
+        }
     }
 
   _dbus_assert (base_names != NULL);
@@ -1278,6 +1433,23 @@ bus_driver_handle_list_queued_owners (DBusConnection *connection,
 
   dbus_message_unref (reply);
 
+#ifdef ENABLE_KDBUS_TRANSPORT
+  if(bus_context_is_kdbus(bus_transaction_get_context (transaction)))
+    {
+      link = _dbus_list_get_first_link (&base_names);
+      while (link != NULL)
+        {
+          DBusList *next = _dbus_list_get_next_link (&base_names, link);
+
+          if(link->data != NULL)
+            free(link->data);
+
+          _dbus_list_free_link (link);
+          link = next;
+        }
+    }
+#endif
+
   return TRUE;
 
  oom:
@@ -1287,10 +1459,8 @@ bus_driver_handle_list_queued_owners (DBusConnection *connection,
   _DBUS_ASSERT_ERROR_IS_SET (error);
   if (reply)
     dbus_message_unref (reply);
-
   if (base_names)
     _dbus_list_clear (&base_names);
-
   return FALSE;
 }
 
@@ -1308,24 +1478,36 @@ bus_driver_handle_get_connection_unix_user (DBusConnection *connection,
 
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
 
-  reply = NULL;
-
-  conn = bus_driver_get_conn_helper (connection, message, "UID", &service,
-                                     error);
-
-  if (conn == NULL)
-    goto failed;
-
   reply = dbus_message_new_method_return (message);
   if (reply == NULL)
     goto oom;
 
-  if (!dbus_connection_get_unix_user (conn, &uid))
+#ifdef ENABLE_KDBUS_TRANSPORT
+  if (bus_context_is_kdbus (bus_transaction_get_context (transaction)))
     {
-      dbus_set_error (error,
-                      DBUS_ERROR_FAILED,
-                      "Could not determine UID for '%s'", service);
-      goto failed;
+      const char* name;
+
+      if (!dbus_message_get_args (message, NULL, DBUS_TYPE_STRING, &name, DBUS_TYPE_INVALID))
+        goto failed;
+      if (!kdbus_connection_get_unix_user (connection, name, &uid, error))
+        goto failed;
+    }
+  else
+#endif
+    {
+      conn = bus_driver_get_conn_helper (connection, message, "UID", &service,
+                                         error);
+
+      if (conn == NULL)
+        goto failed;
+
+      if (!dbus_connection_get_unix_user (conn, &uid))
+        {
+          dbus_set_error (error,
+                          DBUS_ERROR_FAILED,
+                          "Could not determine UID for '%s'", service);
+          goto failed;
+        }
     }
 
   uid32 = uid;
@@ -1365,24 +1547,34 @@ bus_driver_handle_get_connection_unix_process_id (DBusConnection *connection,
 
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
 
-  reply = NULL;
-
-  conn = bus_driver_get_conn_helper (connection, message, "PID", &service,
-                                     error);
-
-  if (conn == NULL)
-    goto failed;
-
   reply = dbus_message_new_method_return (message);
   if (reply == NULL)
     goto oom;
+#ifdef ENABLE_KDBUS_TRANSPORT
+  if (bus_context_is_kdbus (bus_transaction_get_context (transaction)))
+    {
+      const char* name;
 
-  if (!dbus_connection_get_unix_process_id (conn, &pid))
+      if (!dbus_message_get_args (message, NULL, DBUS_TYPE_STRING, &name, DBUS_TYPE_INVALID))
+        goto failed;
+      if (!kdbus_connection_get_unix_process_id (connection, name, &pid, error))
+        goto failed;
+    }
+  else
+#endif
     {
-      dbus_set_error (error,
-                      DBUS_ERROR_UNIX_PROCESS_ID_UNKNOWN,
-                      "Could not determine PID for '%s'", service);
-      goto failed;
+      conn = bus_driver_get_conn_helper (connection, message, "PID", &service,
+                                         error);
+      if (conn == NULL)
+        goto failed;
+
+      if (!dbus_connection_get_unix_process_id (conn, &pid))
+        {
+          dbus_set_error (error,
+                          DBUS_ERROR_UNIX_PROCESS_ID_UNKNOWN,
+                          "Could not determine PID for '%s'", service);
+          goto failed;
+        }
     }
 
   pid32 = pid;
@@ -1477,29 +1669,37 @@ bus_driver_handle_get_connection_selinux_security_context (DBusConnection *conne
 
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
 
-  reply = NULL;
-
-  conn = bus_driver_get_conn_helper (connection, message, "security context",
-                                     &service, error);
-
-  if (conn == NULL)
-    goto failed;
-
   reply = dbus_message_new_method_return (message);
   if (reply == NULL)
     goto oom;
 
-  context = bus_connection_get_selinux_id (conn);
-  if (!context)
-    {
-      dbus_set_error (error,
-                      DBUS_ERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN,
-                      "Could not determine security context for '%s'", service);
-      goto failed;
-    }
-
-  if (! bus_selinux_append_context (reply, context, error))
-    goto failed;
+#ifdef ENABLE_KDBUS_TRANSPORT
+  if(bus_context_is_kdbus(bus_transaction_get_context (transaction)))
+  {
+	  if(!kdbus_get_connection_unix_selinux_security_context(connection, message, reply, error))
+		  goto failed;
+  }
+  else
+#endif
+  {
+	  conn = bus_driver_get_conn_helper (connection, message, "security context",
+										 &service, error);
+
+	  if (conn == NULL)
+		goto failed;
+
+	  context = bus_connection_get_selinux_id (conn);
+	  if (!context)
+		{
+		  dbus_set_error (error,
+						  DBUS_ERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN,
+						  "Could not determine security context for '%s'", service);
+		  goto failed;
+		}
+
+	  if (! bus_selinux_append_context (reply, context, error))
+		goto failed;
+  }
 
   if (! bus_transaction_send_from_driver (transaction, connection, reply))
     goto oom;
@@ -1533,35 +1733,62 @@ bus_driver_handle_get_connection_credentials (DBusConnection *connection,
 
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
 
-  reply = NULL;
-
-  conn = bus_driver_get_conn_helper (connection, message, "credentials",
-                                     &service, error);
-
-  if (conn == NULL)
-    goto failed;
-
   reply = _dbus_asv_new_method_return (message, &reply_iter, &array_iter);
   if (reply == NULL)
     goto oom;
 
-  /* we can't represent > 32-bit pids; if your system needs them, please
-   * add ProcessID64 to the spec or something */
-  if (dbus_connection_get_unix_process_id (conn, &ulong_val) &&
-      ulong_val <= _DBUS_UINT32_MAX)
+#ifdef ENABLE_KDBUS_TRANSPORT
+  if(!bus_context_is_kdbus(bus_transaction_get_context (transaction)))
+  {
+#endif
+	  conn = bus_driver_get_conn_helper (connection, message, "credentials",
+										 &service, error);
+
+	  if (conn == NULL)
+		goto failed;
+
+	  /* we can't represent > 32-bit pids; if your system needs them, please
+	   * add ProcessID64 to the spec or something */
+	  if (dbus_connection_get_unix_process_id (conn, &ulong_val) &&
+		  ulong_val <= _DBUS_UINT32_MAX)
+		{
+		  if (!_dbus_asv_add_uint32 (&array_iter, "ProcessID", ulong_val))
+			goto oom;
+		}
+
+	  /* we can't represent > 32-bit uids; if your system needs them, please
+	   * add UnixUserID64 to the spec or something */
+	  if (dbus_connection_get_unix_user (conn, &ulong_val) &&
+		  ulong_val <= _DBUS_UINT32_MAX)
+		{
+		  if (!_dbus_asv_add_uint32 (&array_iter, "UnixUserID", ulong_val))
+			goto oom;
+		}
+#ifdef ENABLE_KDBUS_TRANSPORT
+  }
+  else
     {
-      if (!_dbus_asv_add_uint32 (&array_iter, "ProcessID", ulong_val))
-        goto oom;
-    }
+      const char* name;
 
-  /* we can't represent > 32-bit uids; if your system needs them, please
-   * add UnixUserID64 to the spec or something */
-  if (dbus_connection_get_unix_user (conn, &ulong_val) &&
-      ulong_val <= _DBUS_UINT32_MAX)
-    {
-      if (!_dbus_asv_add_uint32 (&array_iter, "UnixUserID", ulong_val))
-        goto oom;
-    }
+      if (!dbus_message_get_args (message, NULL, DBUS_TYPE_STRING, &name, DBUS_TYPE_INVALID))
+        goto failed;
+      if (kdbus_connection_get_unix_process_id (connection, name, &ulong_val, error))
+        {
+          if (!_dbus_asv_add_uint32 (&array_iter, "ProcessID", ulong_val))
+            goto oom;
+        }
+      else
+        goto failed;
+
+      if (kdbus_connection_get_unix_user (connection, name, &ulong_val, error))
+        {
+          if (!_dbus_asv_add_uint32 (&array_iter, "UnixUserID", ulong_val))
+            goto oom;
+        }
+      else
+        goto failed;
+   }
+#endif
 
   if (!_dbus_asv_close (&reply_iter, &array_iter))
     goto oom;
diff --git a/bus/kdbus-d.c b/bus/kdbus-d.c
new file mode 100644
index 0000000..9fbc2d4
--- /dev/null
+++ b/bus/kdbus-d.c
@@ -0,0 +1,993 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+/* kdbus-d.c  kdbus related daemon functions
+ *
+ * Copyright (C) 2013  Samsung Electronics
+ *
+ * Licensed under the Academic Free License version 2.1
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version and under the terms of the GNU
+ * Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+#include <dbus/dbus-connection-internal.h>
+#include "kdbus-d.h"
+#include <dbus/kdbus.h>
+#include <dbus/dbus-bus.h>
+#include "dispatch.h"
+#include <dbus/dbus-transport.h>
+#include <dbus/dbus-transport-kdbus.h>
+#include "connection.h"
+#include "activation.h"
+#include "services.h"
+#include <dbus/dbus-connection.h>
+
+#include <utils.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <errno.h>
+
+/*
+ * Converts string with unique name into __u64 id number. If the name is not unique, sets error.
+ */
+__u64 sender_name_to_id(const char* name, DBusError* error)
+{
+	__u64 sender_id = 0;
+
+	if(!strncmp(name, ":1.", 3)) /*if name is unique name it must be converted to unique id*/
+		sender_id = strtoull(&name[3], NULL, 10);
+	else
+		dbus_set_error (error, DBUS_ERROR_INVALID_ARGS, "Could not convert sender of the message into kdbus unique id");
+
+	return sender_id;
+}
+
+/**
+ * Seeks key in rule string, and duplicates value of the key into pValue.
+ * Because of the duplication, pValue must be freed after use.
+ *
+ * @param rule rule to look through
+ * @param key key to look for
+ * @param pValue pointer to value of the key found
+ * @return length of the value string, 0 means not found
+ */
+static int parse_match_key(const char *rule, const char* key, char** pValue)
+{
+  const char* pBegin;
+  const char* pValueEnd;
+  int value_length = 0;
+
+  pBegin = strstr(rule, key);
+  if(pBegin)
+  {
+    pBegin += strlen(key);
+    pValueEnd = strchr(pBegin, '\'');
+    if(pValueEnd)
+    {
+      value_length = pValueEnd - pBegin;
+      *pValue = strndup(pBegin, value_length);
+      if(*pValue)
+        _dbus_verbose ("found for key: %s value:'%s'\n", key, *pValue);
+    }
+  }
+  return value_length;
+}
+
+/**
+ * Adds a match rule to match broadcast messages going through the message bus.
+ * Do no affect messages addressed directly.
+ *
+ * The "rule" argument is the string form of a match rule.
+ *
+ * Only part of the dbus's matching capabilities is implemented in kdbus now, because of different mechanism.
+ * Current mapping:
+ * interface match key mapped to bloom
+ * sender match key mapped to src_name
+ *
+ * @param transport transport
+ * @param id id of connection for which the rule is to be added
+ * @param rule textual form of match rule
+  */
+dbus_bool_t add_match_kdbus (DBusTransport* transport, __u64 id, const char *rule)
+{
+  struct kdbus_cmd_match* pCmd_match;
+  struct kdbus_item *pItem;
+  __u64 src_id = KDBUS_MATCH_SRC_ID_ANY;
+  uint64_t size;
+  int name_size;
+  char* pName = NULL;
+  char* pInterface = NULL;
+  dbus_bool_t ret_value = FALSE;
+  int fd;
+  __u64 bloom_size;
+
+  if(!_dbus_transport_get_socket_fd(transport, &fd))
+    return FALSE;
+
+  bloom_size = dbus_transport_get_bloom_size(transport);
+
+  /*parsing rule and calculating size of command*/
+  size = sizeof(struct kdbus_cmd_match);
+  if(parse_match_key(rule, "interface='", &pInterface))       /*actual size is not important for interface because bloom size is defined by bus*/
+    size += KDBUS_ITEM_HEADER_SIZE + bloom_size;
+  name_size = parse_match_key(rule, "sender='", &pName);
+  if(name_size)
+  {
+    if(!strncmp(pName, ":1.", 3)) /*if name is unique name it must be converted to unique id*/
+    {
+      src_id = strtoull(&pName[3], NULL, 10);
+      free(pName);
+      pName = NULL;
+    }
+    else
+      size += KDBUS_ITEM_SIZE(name_size + 1);  //well known name
+  }
+
+  pCmd_match = alloca(size);
+  if(pCmd_match == NULL)
+    goto out;
+
+  pCmd_match->id = id;
+  pCmd_match->cookie = id;
+  pCmd_match->size = size;
+  pCmd_match->src_id = src_id;
+
+  pItem = pCmd_match->items;
+  if(pName)
+  {
+    pItem->type = KDBUS_MATCH_SRC_NAME;
+    pItem->size = KDBUS_ITEM_HEADER_SIZE + name_size + 1;
+    memcpy(pItem->str, pName, strlen(pName) + 1);
+    pItem = KDBUS_PART_NEXT(pItem);
+  }
+  if(pInterface)
+  {
+    pItem->type = KDBUS_MATCH_BLOOM;
+    pItem->size = KDBUS_ITEM_HEADER_SIZE + bloom_size;
+    strncpy(pItem->data, pInterface, bloom_size);
+  }
+
+  if(ioctl(fd, KDBUS_CMD_MATCH_ADD, pCmd_match))
+    _dbus_verbose("Failed adding match bus rule %s,\nerror: %d, %m\n", rule, errno);
+  else
+  {
+    _dbus_verbose("Added match bus rule %s for id:%llu\n", rule, (unsigned long long)id);
+    ret_value = TRUE;
+  }
+
+out:
+  if(pName)
+    free(pName);
+  if(pInterface)
+    free(pInterface);
+  return ret_value;
+}
+
+/**
+ * Opposing to dbus, in kdbus removes all match rules with given
+ * cookie, which in this implementation is equal to uniqe id.
+ *
+ * @param transport transport
+ * @param id connection id for which rules are to be removed
+ */
+dbus_bool_t remove_match_kdbus (DBusTransport* transport, __u64 id)
+{
+  struct kdbus_cmd_match __attribute__ ((__aligned__(8))) cmd;
+  int fd;
+
+  if(!_dbus_transport_get_socket_fd(transport, &fd))
+    return FALSE;
+
+  cmd.cookie = id;
+  cmd.id = id;
+  cmd.size = sizeof(struct kdbus_cmd_match);
+
+  if(ioctl(fd, KDBUS_CMD_MATCH_REMOVE, &cmd))
+  {
+    _dbus_verbose("Failed removing match rule for id: %llu; error: %d, %m\n", (unsigned long long)id, errno);
+    return FALSE;
+  }
+  else
+  {
+    _dbus_verbose("Match rule removed correctly.\n");
+    return TRUE;
+  }
+}
+
+/*
+ * Creates kdbus bus of given type.
+ */
+char* make_kdbus_bus(DBusBusType type, const char* address, DBusError *error)
+{
+  // TODO Function alloca() used. In upstream there was a patch proposing to
+  // replace alloca() with malloc() to assure memory alignment. If there will be
+  // suggestion to use malloc instead of alloca this function has to be modified
+  struct kdbus_cmd_make *bus_make;
+  struct kdbus_item *item;
+  __u64 name_size, bus_make_size;
+  int fdc, ret;
+  char *addr_value = NULL;
+  char *bus = NULL;
+  char *name = NULL;
+
+  if(type == DBUS_BUS_SYSTEM)
+    name_size = snprintf(name, 0, "%u-kdbus-%s", getuid(), "system") + 1;
+  else if(type == DBUS_BUS_SESSION)
+    name_size = snprintf(name, 0, "%u-kdbus", getuid()) + 1;
+  else
+    name_size = snprintf(name, 0, "%u-kdbus-%u", getuid(), getpid()) + 1;
+
+  name = alloca(name_size);
+  if (!name)
+    {
+      return NULL;
+    }
+
+  bus_make_size = sizeof(struct kdbus_cmd_make) + KDBUS_ITEM_SIZE(name_size) + KDBUS_ITEM_SIZE(sizeof(__u64));
+  bus_make = alloca(bus_make_size);
+  if (!bus_make)
+    {
+      return NULL;
+    }
+
+  bus_make->size = bus_make_size;
+#ifdef POLICY_TO_KDBUS
+  bus_make->flags = KDBUS_MAKE_ACCESS_WORLD;
+#else
+  bus_make->flags = KDBUS_MAKE_ACCESS_WORLD | KDBUS_MAKE_POLICY_OPEN;
+#endif
+  item = bus_make->items;
+
+  item->type = KDBUS_ITEM_MAKE_NAME;
+  item->size = KDBUS_ITEM_HEADER_SIZE + name_size;
+  if(type == DBUS_BUS_SYSTEM)
+    sprintf(name, "%u-kdbus-%s", getuid(), "system");
+  else if(type == DBUS_BUS_SESSION)
+    sprintf(name, "%u-kdbus", getuid());
+  else
+    sprintf(name, "%u-kdbus-%u", getuid(), getpid());
+  memcpy((bus_make->items)->str, name, name_size);
+
+  item = KDBUS_PART_NEXT(item);
+  item->type = KDBUS_ITEM_BLOOM_SIZE;
+  item->size = KDBUS_ITEM_HEADER_SIZE + sizeof(__u64);
+  item->data64[0] = 64;
+
+#ifdef KDBUS_FOR_SBB
+  addr_value = strchr(address, ':') + 1;
+  if(*addr_value)
+    {
+      if(!strcmp(addr_value, "sbb"))
+        bus_make->flags |= KDBUS_MAKE_SBB_OFFSET;
+      else
+        {
+          dbus_set_error_const(error, DBUS_ERROR_BAD_ADDRESS, "Invalid address parameter.");
+          return NULL;
+        }
+    }
+#endif
+
+  _dbus_verbose("Opening /dev/kdbus/control\n");
+  fdc = open("/dev/kdbus/control", O_RDWR|O_CLOEXEC);
+  if (fdc < 0)
+    {
+      _dbus_verbose("--- error %d (%m)\n", fdc);
+      dbus_set_error(error, DBUS_ERROR_FAILED, "Opening /dev/kdbus/control failed: %d (%m)", fdc);
+      return NULL;
+    }
+
+  _dbus_verbose("Creating bus '%s'\n", (bus_make->items[0]).str);
+  ret = ioctl(fdc, KDBUS_CMD_BUS_MAKE, bus_make);
+  if (ret)
+    {
+      _dbus_verbose("--- error %d (%m)\n", errno);
+      dbus_set_error(error, DBUS_ERROR_FAILED, "Creating bus '%s' failed: %d (%m)",
+          (bus_make->items[0]).str, errno);
+      return NULL;
+    }
+
+  if (asprintf(&bus, "kdbus:path=/dev/kdbus/%s/bus", (bus_make->items[0]).str) < 0)
+    {
+      BUS_SET_OOM (error);
+      return NULL;
+    }
+
+  _dbus_verbose("Return value '%s'\n", bus);
+  return bus;
+}
+
+/*
+ * Minimal server init needed by context to go further.
+ */
+DBusServer* empty_server_init(char* address)
+{
+	return dbus_server_init_mini(address);
+}
+
+static dbus_bool_t add_matches_for_kdbus_broadcasts(DBusConnection* connection)
+{
+  struct kdbus_cmd_match* pCmd_match;
+  struct kdbus_item *pItem;
+  uint64_t size;
+  int fd;
+  DBusTransport *transport;
+
+  transport = dbus_connection_get_transport(connection);
+
+  if(!_dbus_transport_get_socket_fd(transport, &fd))
+    {
+      errno = EPERM;
+      return FALSE;
+    }
+
+  size = sizeof(struct kdbus_cmd_match);
+  size += KDBUS_ITEM_SIZE(1)*3 + KDBUS_ITEM_SIZE(sizeof(__u64))*2;  /*3 name related items plus 2 id related items*/
+
+  pCmd_match = alloca(size);
+  if(pCmd_match == NULL)
+    {
+      errno = ENOMEM;
+      return FALSE;
+    }
+
+  pCmd_match->id = 0;
+  pCmd_match->cookie = 1;
+  pCmd_match->size = size;
+  pCmd_match->src_id = 0;
+
+  pItem = pCmd_match->items;
+  pItem->type = KDBUS_MATCH_NAME_CHANGE;
+  pItem->size = KDBUS_ITEM_HEADER_SIZE + 1;
+  pItem = KDBUS_PART_NEXT(pItem);
+  pItem->type = KDBUS_MATCH_NAME_ADD;
+  pItem->size = KDBUS_ITEM_HEADER_SIZE + 1;
+  pItem = KDBUS_PART_NEXT(pItem);
+  pItem->type = KDBUS_MATCH_NAME_REMOVE;
+  pItem->size = KDBUS_ITEM_HEADER_SIZE + 1;
+  pItem = KDBUS_PART_NEXT(pItem);
+  pItem->type = KDBUS_MATCH_ID_ADD;
+  pItem->size = KDBUS_ITEM_HEADER_SIZE + sizeof(__u64);
+  pItem->id = KDBUS_MATCH_SRC_ID_ANY;
+  pItem = KDBUS_PART_NEXT(pItem);
+  pItem->type = KDBUS_MATCH_ID_REMOVE;
+  pItem->size = KDBUS_ITEM_HEADER_SIZE + sizeof(__u64);
+  pItem->id = KDBUS_MATCH_SRC_ID_ANY;
+
+  if(ioctl(fd, KDBUS_CMD_MATCH_ADD, pCmd_match))
+    {
+      _dbus_verbose("Failed adding match rule for daemon, error: %d, %m\n", errno);
+      return FALSE;
+    }
+
+  _dbus_verbose("Added match rule for daemon correctly.\n");
+  return TRUE;
+}
+
+/*
+ * Connects daemon to bus created by him and adds matches for "system" broadcasts.
+ * Do not requests org.freedesktop.DBus name, because it's to early
+ * (some structures of BusContext are not ready yet).
+ */
+DBusConnection* daemon_as_client(DBusBusType type, char* address, DBusError *error)
+{
+  DBusConnection* connection;
+
+  dbus_bus_set_bus_connection_address(type, address);
+
+  connection = dbus_bus_get_private(type, error);  /*todo possibly could be optimised by using lower functions*/
+  if(connection == NULL)
+    return NULL;
+
+  if(!add_matches_for_kdbus_broadcasts(connection))
+    {
+      dbus_set_error (error, _dbus_error_from_errno (errno), "Could not add match for daemon, %s", _dbus_strerror_from_errno ());
+      goto failed;
+    }
+
+  if(dbus_error_is_set(error))
+    {
+      failed:
+      _dbus_connection_close_possibly_shared (connection);
+      dbus_connection_unref (connection);
+      connection = NULL;
+    }
+  else
+    _dbus_verbose ("Daemon connected as kdbus client.\n");
+
+  return connection;
+}
+
+/*
+ * Asks bus for org.freedesktop.DBus well-known name.
+ */
+dbus_bool_t register_daemon_name(DBusConnection* connection)
+{
+    DBusString daemon_name;
+    dbus_bool_t retval = FALSE;
+    BusTransaction *transaction;
+
+    _dbus_string_init_const(&daemon_name, DBUS_SERVICE_DBUS);
+#ifdef POLICY_TO_KDBUS
+    if(!register_kdbus_policy(DBUS_SERVICE_DBUS, dbus_connection_get_transport(connection), geteuid()))
+      return FALSE;
+#endif
+
+    if(kdbus_request_name(connection, &daemon_name, 0, 0) != DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER)
+       return FALSE;
+
+    transaction = bus_transaction_new (bus_connection_get_context(connection));
+    if (transaction == NULL)
+    {
+        kdbus_release_name(connection, &daemon_name, 0);
+        goto out;
+    }
+
+    if(!bus_registry_ensure (bus_connection_get_registry (connection), &daemon_name, connection, 0, transaction, NULL))
+    {
+        kdbus_release_name(connection, &daemon_name, 0);
+        goto out;
+    }
+
+    retval = TRUE;
+
+out:
+  if(retval)
+    bus_transaction_execute_and_free(transaction);
+  else
+    bus_transaction_cancel_and_free(transaction);
+
+  return retval;
+}
+
+dbus_uint32_t kdbus_request_name(DBusConnection* connection, const DBusString *service_name, dbus_uint32_t flags, __u64 sender_id)
+{
+	int fd;
+
+	_dbus_transport_get_socket_fd(dbus_connection_get_transport(connection), &fd);
+
+	return request_kdbus_name(fd, _dbus_string_get_const_data(service_name), flags, sender_id);
+}
+
+dbus_uint32_t kdbus_release_name(DBusConnection* connection, const DBusString *service_name, __u64 sender_id)
+{
+	int fd;
+
+	_dbus_transport_get_socket_fd(dbus_connection_get_transport(connection), &fd);
+
+	return release_kdbus_name(fd, _dbus_string_get_const_data(service_name), sender_id);
+}
+
+/*
+ * Asks kdbus for well-known names registered on the bus
+ */
+dbus_bool_t kdbus_list_services (DBusConnection* connection, char ***listp, int *array_len)
+{
+	int fd;
+	struct kdbus_cmd_name_list __attribute__ ((__aligned__(8))) cmd;
+	struct kdbus_name_list *name_list;
+	struct kdbus_cmd_name *name;
+	DBusTransport *transport = dbus_connection_get_transport(connection);
+	dbus_bool_t ret_val = FALSE;
+	char** list;
+	int list_len = 0;
+	int i = 0;
+	int j;
+
+	if(!_dbus_transport_get_socket_fd(transport, &fd))
+	  return FALSE;
+
+  cmd.flags = KDBUS_NAME_LIST_NAMES | KDBUS_NAME_LIST_UNIQUE;
+
+again:
+	if(ioctl(fd, KDBUS_CMD_NAME_LIST, &cmd))
+	{
+		if(errno == EINTR)
+			goto again;
+		else
+		{
+			_dbus_verbose("kdbus error asking for name list: err %d (%m)\n",errno);
+			return FALSE;
+		}
+	}
+
+	name_list = (struct kdbus_name_list *)((char*)dbus_transport_get_pool_pointer(transport) + cmd.offset);
+
+  for (name = name_list->names; (uint8_t *)(name) < (uint8_t *)(name_list) + name_list->size; name = KDBUS_PART_NEXT(name))
+    list_len++;
+
+  _dbus_verbose ("List len: %d\n", list_len);
+
+  list = malloc(sizeof(char*) * (list_len + 1));
+  if(list == NULL)
+    goto out;
+
+  for (name = name_list->names; (uint8_t *)(name) < (uint8_t *)(name_list) + name_list->size; name = KDBUS_PART_NEXT(name))
+  {
+      if(name->size > sizeof(struct kdbus_cmd_name) )
+      {
+        list[i] = strdup(name->name);
+        if(list[i] == NULL)
+          goto out;
+      }
+      else
+      {
+        list[i] = malloc(snprintf(list[i], 0, ":1.%llu0", (unsigned long long)name->id));
+        if(list[i] == NULL)
+          goto out;
+        sprintf(list[i], ":1.%llu", (unsigned long long int)name->id);
+      }
+    _dbus_verbose ("Name %d: %s\n", i, list[i]);
+    ++i;
+  }
+
+  list[i] = NULL;
+	*array_len = list_len;
+	*listp = list;
+	ret_val = TRUE;
+
+out:
+  if (ioctl(fd, KDBUS_CMD_FREE, &cmd.offset) < 0)
+  {
+    if(errno == EINTR)
+      goto out;
+    _dbus_verbose("kdbus error freeing pool: %d (%m)\n", errno);
+    ret_val = FALSE;
+  }
+  if(ret_val == FALSE)
+    {
+      for(j=0; j<i; j++)
+        free(list[j]);
+      free(list);
+      *array_len = 0;
+      *listp = NULL;
+    }
+
+	return ret_val;
+}
+
+/*
+ * Asks kdbus for list of connections being in the queue to own
+ * given well-known name. The list includes the owner of the name on the
+ * first position.
+ */
+dbus_bool_t kdbus_list_queued (DBusConnection *connection, DBusList  **return_list,
+                               const char *name, DBusError  *error)
+{
+  int fd;
+  dbus_bool_t ret_val = FALSE;
+  int name_length;
+  struct kdbus_cmd_conn_info *pCmd;
+  __u64 cmd_size;
+  DBusTransport *transport = dbus_connection_get_transport(connection);
+  struct kdbus_name_list *name_list;
+  struct kdbus_cmd_name *owner;
+
+  _dbus_assert (*return_list == NULL);
+
+  name_length = strlen(name) + 1;
+  cmd_size = sizeof(struct kdbus_cmd_conn_info) + name_length;
+  pCmd = alloca(cmd_size);
+  if(pCmd == NULL)
+    goto out;
+  pCmd->size = cmd_size;
+  pCmd->id = 0;
+  memcpy(pCmd->name, name, name_length);
+
+  _dbus_verbose ("Asking for queued owners of %s\n", pCmd->name);
+
+  _dbus_transport_get_socket_fd(transport, &fd);
+
+  again:
+  if(ioctl(fd, KDBUS_CMD_NAME_LIST_QUEUED, pCmd))
+    {
+      if(errno == EINTR)
+        goto again;
+      else if(errno == ESRCH)
+        {
+          dbus_set_error (error, DBUS_ERROR_NAME_HAS_NO_OWNER,
+                      "Could not get owners of name '%s': no such name", name);
+          return FALSE;
+        }
+      else
+        {
+          _dbus_verbose("kdbus error asking for queued owners list: err %d (%m)\n",errno);
+          goto out;
+        }
+    }
+
+  name_list = (struct kdbus_name_list *)((char*)dbus_transport_get_pool_pointer(transport) + pCmd->offset);
+
+  for (owner = name_list->names; (uint8_t *)(owner) < (uint8_t *)(name_list) + name_list->size; owner = KDBUS_PART_NEXT(owner))
+    {
+      char *uname = NULL;
+
+      _dbus_verbose ("Got queued owner id: %llu\n", (unsigned long long)owner->id);
+      uname = malloc(snprintf(uname, 0, ":1.%llu0", (unsigned long long)owner->id));
+      if(uname == NULL)
+        goto out;
+      sprintf(uname, ":1.%llu", (unsigned long long int)owner->id);
+      if (!_dbus_list_append (return_list, uname))
+        goto out;
+    }
+
+  ret_val = TRUE;
+
+  out:
+  if (ioctl(fd, KDBUS_CMD_FREE, &pCmd->offset) < 0)
+  {
+    if(errno == EINTR)
+      goto out;
+    _dbus_verbose("kdbus error freeing pool: %d (%m)\n", errno);
+    ret_val = FALSE;
+  }
+  if(ret_val == FALSE)
+    {
+      DBusList *link;
+
+      dbus_set_error (error, _dbus_error_from_errno (errno),
+          "Failed to list queued owners of \"%s\": %s",
+          name, _dbus_strerror (errno));
+
+      link = _dbus_list_get_first_link (return_list);
+      while (link != NULL)
+        {
+          DBusList *next = _dbus_list_get_next_link (return_list, link);
+
+          if(link->data != NULL)
+            free(link->data);
+
+          _dbus_list_free_link (link);
+          link = next;
+        }
+    }
+
+  return ret_val;
+}
+
+/*
+ *  Register match rule in kdbus on behalf of sender of the message
+ */
+dbus_bool_t kdbus_add_match_rule (DBusConnection* connection, DBusMessage* message, const char* text, DBusError* error)
+{
+	__u64 sender_id;
+
+	sender_id = sender_name_to_id(dbus_message_get_sender(message), error);
+	if(dbus_error_is_set(error))
+		return FALSE;
+
+	if(!add_match_kdbus (dbus_connection_get_transport(connection), sender_id, text))
+	{
+	      dbus_set_error (error, _dbus_error_from_errno (errno), "Could not add match for id:%llu, %s",
+	                      sender_id, _dbus_strerror_from_errno ());
+	      return FALSE;
+	}
+
+	return TRUE;
+}
+
+/*
+ *  Removes match rule in kdbus on behalf of sender of the message
+ */
+dbus_bool_t kdbus_remove_match (DBusConnection* connection, DBusMessage* message, DBusError* error)
+{
+	__u64 sender_id;
+
+	sender_id = sender_name_to_id(dbus_message_get_sender(message), error);
+	if(dbus_error_is_set(error))
+		return FALSE;
+
+	if(!remove_match_kdbus (dbus_connection_get_transport(connection), sender_id))
+	{
+	      dbus_set_error (error, _dbus_error_from_errno (errno), "Could not remove match rules for id:%llu", sender_id);
+	      return FALSE;
+	}
+
+	return TRUE;
+}
+
+int kdbus_get_name_owner(DBusConnection* connection, const char* name, char* owner)
+{
+  int ret;
+  struct nameInfo info;
+
+  ret = kdbus_NameQuery(name, dbus_connection_get_transport(connection), &info);
+  if(ret == 0) //unique id of the name
+  {
+    sprintf(owner, ":1.%llu", (unsigned long long int)info.uniqueId);
+    _dbus_verbose("Unique name discovered:%s\n", owner);
+  }
+  else if((ret != -ENOENT) && (ret != -ENXIO))
+    _dbus_verbose("kdbus error sending name query: err %d (%m)\n", ret);
+
+  return ret;
+}
+
+/*
+ *  Asks kdbus for selinux_security_context of the owner of the name given in the message
+ */
+dbus_bool_t kdbus_get_connection_unix_selinux_security_context(DBusConnection* connection, DBusMessage* message, DBusMessage* reply, DBusError* error)
+{
+	char* name = NULL;
+	struct nameInfo info;
+	int inter_ret;
+	dbus_bool_t ret = FALSE;
+
+	dbus_message_get_args(message, NULL, DBUS_TYPE_STRING, &name, DBUS_TYPE_INVALID);
+	inter_ret = kdbus_NameQuery(name, dbus_connection_get_transport(connection), &info);
+	if((inter_ret == -ENOENT) || (inter_ret == -ENXIO)) //name has no owner
+		dbus_set_error (error, DBUS_ERROR_FAILED, "Could not get security context of name '%s': no such name", name);
+	else if(inter_ret < 0)
+	{
+		_dbus_verbose("kdbus error determining security context: err %d (%m)\n", errno);
+		dbus_set_error (error, DBUS_ERROR_FAILED, "Could not determine security context for '%s'", name);
+	}
+	else
+	{
+		if (!dbus_message_append_args (reply, DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE, &info.sec_label, info.sec_label_len, DBUS_TYPE_INVALID))
+		{
+		      _DBUS_SET_OOM (error);
+		      return FALSE;
+		}
+		ret = TRUE;
+	}
+
+	return ret;
+}
+
+/*
+ * Create connection structure for given name. It is needed to control starters - activatable services
+ * and for ListQueued method (as long as kdbus is not supporting it). This connections don't have it's own
+ * fd so it is set up on the basis of daemon's transport. Functionality of such connection is limited.
+ */
+DBusConnection* create_phantom_connection(DBusConnection* connection, const char* name, DBusError* error)
+{
+    DBusConnection *phantom_connection;
+    DBusString Sname;
+
+    _dbus_string_init_const(&Sname, name);
+
+    phantom_connection = _dbus_connection_new_for_used_transport (dbus_connection_get_transport(connection));
+    if(phantom_connection == NULL)
+        return FALSE;
+    if(!bus_connections_setup_connection(bus_connection_get_connections(connection), phantom_connection))
+    {
+        dbus_connection_unref_phantom(phantom_connection);
+        phantom_connection = NULL;
+        dbus_set_error (error, DBUS_ERROR_FAILED , "Name \"%s\" could not be acquired", name);
+        goto out;
+    }
+    dbus_bus_set_unique_name(phantom_connection, name);
+    if(!bus_connection_complete(phantom_connection, &Sname, error))
+    {
+        bus_connection_disconnected(phantom_connection);
+        phantom_connection = NULL;
+        goto out;
+    }
+
+    _dbus_verbose ("Created phantom connection for %s\n", bus_connection_get_name(phantom_connection));
+
+out:
+    return phantom_connection;
+}
+
+/*
+ * Registers activatable services as kdbus starters.
+ */
+dbus_bool_t register_kdbus_starters(DBusConnection* connection)
+{
+    int i,j, len;
+    char **services;
+    dbus_bool_t retval = FALSE;
+    int fd;
+    BusTransaction *transaction;
+    DBusString name;
+    DBusTransport* transport;
+
+    transaction = bus_transaction_new (bus_connection_get_context(connection));
+    if (transaction == NULL)
+	return FALSE;
+
+    if (!bus_activation_list_services (bus_connection_get_activation (connection), &services, &len))
+        return FALSE;
+
+    transport = dbus_connection_get_transport(connection);
+
+    if(!_dbus_transport_get_socket_fd (transport, &fd))
+      return FALSE;
+
+    _dbus_string_init(&name);
+
+    for(i=0; i<len; i++)
+    {
+#ifdef POLICY_TO_KDBUS
+        if(!register_kdbus_policy(services[i], transport, geteuid()))
+          goto out;
+#endif
+
+        if (request_kdbus_name(fd, services[i], (DBUS_NAME_FLAG_ALLOW_REPLACEMENT | KDBUS_NAME_STARTER_NAME) , 0) < 0)
+            goto out;
+
+        if(!_dbus_string_append(&name, services[i]))
+		goto out;
+        if(!bus_registry_ensure (bus_connection_get_registry (connection), &name, connection,
+			(DBUS_NAME_FLAG_ALLOW_REPLACEMENT | KDBUS_NAME_STARTER_NAME), transaction, NULL))
+		goto out;
+        if(!_dbus_string_set_length(&name, 0))
+		goto out;
+    }
+    retval = TRUE;
+
+out:
+    if(retval == FALSE)
+    {
+        for(j=0; j<i; j++)
+            release_kdbus_name(fd, services[j], 0);
+    }
+    dbus_free_string_array (services);
+    _dbus_string_free(&name);
+  if(retval)
+    bus_transaction_execute_and_free(transaction);
+  else
+    bus_transaction_cancel_and_free(transaction);
+
+  return retval;
+}
+
+/*
+ * Updates kdbus starters (activatable services) after configuration was reloaded.
+ * It releases all previous starters and registers all new.
+ */
+dbus_bool_t update_kdbus_starters(DBusConnection* connection)
+{
+    dbus_bool_t retval = FALSE;
+    DBusList **services_old;
+    DBusList *link;
+    BusService *service = NULL;
+    BusTransaction *transaction;
+    int fd;
+
+    transaction = bus_transaction_new (bus_connection_get_context(connection));
+    if (transaction == NULL)
+        return FALSE;
+
+    if(!_dbus_transport_get_socket_fd(dbus_connection_get_transport(connection), &fd))
+        goto out;
+
+    services_old = bus_connection_get_services_owned(connection);
+    link = _dbus_list_get_first_link(services_old);
+    link = _dbus_list_get_next_link (services_old, link); //skip org.freedesktop.DBus which is not starter
+
+    while (link != NULL)
+    {
+        int ret;
+
+        service = (BusService*) link->data;
+        if(service == NULL)
+            goto out;
+
+        ret = release_kdbus_name(fd, bus_service_get_name(service), 0);
+
+        if (ret == DBUS_RELEASE_NAME_REPLY_RELEASED)
+        {
+            if(!bus_service_remove_owner(service, connection, transaction, NULL))
+                _dbus_verbose ("Unable to remove\n");
+        }
+        else if(ret < 0)
+            goto out;
+
+        link = _dbus_list_get_next_link (services_old, link);
+    }
+
+    if(!register_kdbus_starters(connection))
+    {
+        _dbus_verbose ("Registering kdbus starters for dbus activatable names failed!\n");
+        goto out;
+    }
+    retval = TRUE;
+
+out:
+  if(retval)
+    bus_transaction_execute_and_free(transaction);
+  else
+    bus_transaction_cancel_and_free(transaction);
+
+  return retval;
+}
+
+/*
+ * Analyzes system broadcasts about id and name changes.
+ * Basing on this it sends NameAcquired and NameLost signals and clear phantom connections.
+ */
+void handleNameOwnerChanged(DBusMessage *msg, BusTransaction *transaction, DBusConnection *connection)
+{
+    const char *name, *old, *new;
+
+    if(!dbus_message_get_args(msg, NULL, DBUS_TYPE_STRING, &name, DBUS_TYPE_STRING, &old, DBUS_TYPE_STRING, &new, DBUS_TYPE_INVALID))
+    {
+        _dbus_verbose ("Couldn't get args of NameOwnerChanged signal.\n");//, error.message);
+        return;
+    }
+
+    _dbus_verbose ("Got NameOwnerChanged signal:\nName: %s\nOld: %s\nNew: %s\n", name, old, new);
+
+    if(!strncmp(name, ":1.", 3))/*if it starts from :1. it is unique name - this might be IdRemoved info*/
+    {
+        if(!strcmp(name, old))  //yes it is - someone has disconnected
+        {
+            DBusConnection* conn;
+
+            conn = bus_connections_find_conn_by_name(bus_connection_get_connections(connection), name);
+            if(conn)
+                bus_connection_disconnected(conn);
+        }
+    }
+    else //it is well-known name
+    {
+        if((*old != 0) && (strcmp(old, bus_connection_get_name(connection))))
+        {
+            DBusMessage *message;
+
+            if(bus_connections_find_conn_by_name(bus_connection_get_connections(connection), old) == NULL)
+                goto next;
+
+            _dbus_verbose ("Owner '%s' lost name '%s'. Sending NameLost.\n", old, name);
+
+            message = dbus_message_new_signal (DBUS_PATH_DBUS, DBUS_INTERFACE_DBUS, "NameLost");
+            if (message == NULL)
+                goto next;
+
+            if (!dbus_message_set_destination (message, old) || !dbus_message_append_args (message,
+                                                                 DBUS_TYPE_STRING, &name,
+                                                                 DBUS_TYPE_INVALID))
+            {
+                dbus_message_unref (message);
+                goto next;
+            }
+
+            bus_transaction_send_from_driver (transaction, connection, message);
+            dbus_message_unref (message);
+        }
+    next:
+        if((*new != 0) && (strcmp(new, bus_connection_get_name(connection))))
+        {
+            DBusMessage *message;
+
+            _dbus_verbose ("Owner '%s' acquired name '%s'. Sending NameAcquired.\n", new, name);
+
+            message = dbus_message_new_signal (DBUS_PATH_DBUS, DBUS_INTERFACE_DBUS, "NameAcquired");
+            if (message == NULL)
+                return;
+
+            if (!dbus_message_set_destination (message, new) || !dbus_message_append_args (message,
+                                                                 DBUS_TYPE_STRING, &name,
+                                                                 DBUS_TYPE_INVALID))
+            {
+                dbus_message_unref (message);
+                return;
+            }
+
+            bus_transaction_send_from_driver (transaction, connection, message);
+            dbus_message_unref (message);
+        }
+    }
+
+    if(bus_transaction_send(transaction, connection, msg))
+      _dbus_verbose ("NameOwnerChanged sent\n");
+    else
+      _dbus_verbose ("Sending NameOwnerChanged failed\n");
+}
diff --git a/bus/kdbus-d.h b/bus/kdbus-d.h
new file mode 100644
index 0000000..7bbab69
--- /dev/null
+++ b/bus/kdbus-d.h
@@ -0,0 +1,63 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+/* kdbus-d.h  kdbus related daemon functions
+ *
+ * Copyright (C) 2013  Samsung Electronics
+ *
+ * Licensed under the Academic Free License version 2.1
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version and under the terms of the GNU
+ * Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef KDBUS_D_H_
+#define KDBUS_D_H_
+
+
+#include <dbus/dbus-bus.h>
+#include "bus.h"
+#include <dbus/dbus-server.h>
+#include <linux/types.h>
+#include <dbus/dbus-transport-kdbus.h>
+#include <dbus/kdbus-common.h>
+
+__u64 sender_name_to_id(const char* name, DBusError* error);
+char* make_kdbus_bus(DBusBusType type, const char* address, DBusError *error);
+DBusServer* empty_server_init(char* address);
+
+dbus_bool_t kdbus_register_policy (const DBusString *service_name, DBusConnection* connection);
+dbus_uint32_t kdbus_request_name(DBusConnection* connection, const DBusString *service_name, dbus_uint32_t flags, __u64 sender_id);
+dbus_uint32_t kdbus_release_name(DBusConnection* connection, const DBusString *service_name, __u64 sender_id);
+dbus_bool_t kdbus_list_services (DBusConnection* connection, char ***listp, int *array_len);
+dbus_bool_t kdbus_list_queued (DBusConnection *connection, DBusList **return_list, const char *name, DBusError *error);
+dbus_bool_t kdbus_add_match_rule (DBusConnection* connection, DBusMessage* message, const char* text, DBusError* error);
+dbus_bool_t kdbus_remove_match (DBusConnection* connection, DBusMessage* message, DBusError* error);
+
+dbus_bool_t add_match_kdbus (DBusTransport* transport, __u64 id, const char *rule);
+dbus_bool_t remove_match_kdbus (DBusTransport* transport, __u64 id);
+
+int kdbus_get_name_owner(DBusConnection* connection, const char* name, char* owner);
+dbus_bool_t kdbus_get_connection_unix_selinux_security_context(DBusConnection* connection, DBusMessage* message, DBusMessage* reply, DBusError* error);
+
+DBusConnection* daemon_as_client(DBusBusType type, char* address, DBusError *error);
+dbus_bool_t register_daemon_name(DBusConnection* connection);
+DBusConnection* create_phantom_connection(DBusConnection* connection, const char* unique_name, DBusError* error);
+dbus_bool_t register_kdbus_starters(DBusConnection* connection);
+dbus_bool_t update_kdbus_starters(DBusConnection* connection);
+
+void handleNameOwnerChanged(DBusMessage *msg, BusTransaction *transaction, DBusConnection *connection);
+#endif /* KDBUS_H_ */
diff --git a/bus/main.c b/bus/main.c
index e060baa..ebd0945 100644
--- a/bus/main.c
+++ b/bus/main.c
@@ -643,6 +643,18 @@ main (int argc, char **argv)
   _dbus_set_signal_handler (SIGHUP, signal_handler);
 #endif /* DBUS_UNIX */
 
+#ifdef ENABLE_KDBUS_TRANSPORT
+  if (bus_context_get_systemd_activation(context) == TRUE)
+    {
+      if (strncmp(bus_context_get_address(context), "kdbus:", strlen("kdbus:")) == 0 &&
+                  !strcmp(bus_context_get_type(context), "system") &&
+                  getuid() == 0)
+        {
+          kill (1, SIGUSR1);
+        }
+    }
+#endif
+
   _dbus_verbose ("We are on D-Bus...\n");
   _dbus_loop_run (bus_context_get_loop (context));
 
diff --git a/bus/services.c b/bus/services.c
index 01a720e..82cfa6e 100644
--- a/bus/services.c
+++ b/bus/services.c
@@ -3,6 +3,7 @@
  *
  * Copyright (C) 2003  Red Hat, Inc.
  * Copyright (C) 2003  CodeFactory AB
+ * Copyright (C) 2013  Samsung Electronics
  *
  * Licensed under the Academic Free License version 2.1
  * 
@@ -27,7 +28,6 @@
 #include <dbus/dbus-list.h>
 #include <dbus/dbus-mempool.h>
 #include <dbus/dbus-marshal-validate.h>
-
 #include "driver.h"
 #include "services.h"
 #include "connection.h"
@@ -37,6 +37,18 @@
 #include "bus.h"
 #include "selinux.h"
 
+#ifdef ENABLE_KDBUS_TRANSPORT
+#include <linux/types.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <limits.h>
+
+#include "kdbus-d.h"
+#include "dbus/kdbus.h"
+#include "dbus/kdbus-common.h"
+#endif
+
 struct BusService
 {
   int refcount;
@@ -55,6 +67,9 @@ struct BusOwner
 
   unsigned int allow_replacement : 1;
   unsigned int do_not_queue : 1;
+#ifdef ENABLE_KDBUS_TRANSPORT
+  unsigned int is_kdbus_starter : 1;
+#endif
 };
 
 struct BusRegistry
@@ -172,6 +187,30 @@ _bus_service_find_owner_link (BusService *service,
   return link;
 }
 
+#ifdef ENABLE_KDBUS_TRANSPORT
+static DBusConnection *
+_bus_service_find_owner_connection (BusService *service,
+                                   const char* unique_name)
+{
+  DBusList *link;
+
+  link = _dbus_list_get_first_link (&service->owners);
+
+  while (link != NULL)
+    {
+      BusOwner *bus_owner;
+
+      bus_owner = (BusOwner *) link->data;
+      if(!strcmp(bus_connection_get_name(bus_owner->conn), unique_name))
+          return bus_owner->conn;
+
+      link = _dbus_list_get_next_link (&service->owners, link);
+    }
+
+  return NULL;
+}
+#endif
+
 static void
 bus_owner_set_flags (BusOwner *owner,
                      dbus_uint32_t flags)
@@ -181,6 +220,11 @@ bus_owner_set_flags (BusOwner *owner,
 
    owner->do_not_queue =
         (flags & DBUS_NAME_FLAG_DO_NOT_QUEUE) != FALSE;
+
+#ifdef ENABLE_KDBUS_TRANSPORT
+   owner->is_kdbus_starter =
+        (flags & KDBUS_NAME_STARTER_NAME) != FALSE;
+#endif
 }
 
 static BusOwner *
@@ -310,7 +354,7 @@ bus_registry_ensure (BusRegistry               *registry,
       BUS_SET_OOM (error);
       return NULL;
     }
-  
+
   return service;
 }
 
@@ -437,163 +481,310 @@ bus_registry_acquire_service (BusRegistry      *registry,
    * in bus_connection_selinux_allows_acquire_service()
    */
   sid = bus_selinux_id_table_lookup (registry->service_sid_table,
-                                     service_name);
+									 service_name);
 
   if (!bus_selinux_allows_acquire_service (connection, sid,
 					   _dbus_string_get_const_data (service_name), error))
-    {
+	{
 
-      if (dbus_error_is_set (error) &&
+	  if (dbus_error_is_set (error) &&
 	  dbus_error_has_name (error, DBUS_ERROR_NO_MEMORY))
 	{
 	  goto out;
 	}
 
-      dbus_set_error (error, DBUS_ERROR_ACCESS_DENIED,
-                      "Connection \"%s\" is not allowed to own the service \"%s\" due "
-                      "to SELinux policy",
-                      bus_connection_is_active (connection) ?
-                      bus_connection_get_name (connection) :
-                      "(inactive)",
-                      _dbus_string_get_const_data (service_name));
-      goto out;
-    }
-  
+	  dbus_set_error (error, DBUS_ERROR_ACCESS_DENIED,
+					  "Connection \"%s\" is not allowed to own the service \"%s\" due "
+					  "to SELinux policy",
+					  bus_connection_is_active (connection) ?
+					  bus_connection_get_name (connection) :
+					  "(inactive)",
+					  _dbus_string_get_const_data (service_name));
+	  goto out;
+	}
+
   if (!bus_client_policy_check_can_own (policy, service_name))
-    {
-      dbus_set_error (error, DBUS_ERROR_ACCESS_DENIED,
-                      "Connection \"%s\" is not allowed to own the service \"%s\" due "
-                      "to security policies in the configuration file",
-                      bus_connection_is_active (connection) ?
-                      bus_connection_get_name (connection) :
-                      "(inactive)",
-                      _dbus_string_get_const_data (service_name));
-      goto out;
-    }
+	{
+	  dbus_set_error (error, DBUS_ERROR_ACCESS_DENIED,
+					  "Connection \"%s\" is not allowed to own the service \"%s\" due "
+					  "to security policies in the configuration file",
+					  bus_connection_is_active (connection) ?
+					  bus_connection_get_name (connection) :
+					  "(inactive)",
+					  _dbus_string_get_const_data (service_name));
+	  goto out;
+	}
 
   if (bus_connection_get_n_services_owned (connection) >=
-      bus_context_get_max_services_per_connection (registry->context))
-    {
-      dbus_set_error (error, DBUS_ERROR_LIMITS_EXCEEDED,
-                      "Connection \"%s\" is not allowed to own more services "
-                      "(increase limits in configuration file if required)",
-                      bus_connection_is_active (connection) ?
-                      bus_connection_get_name (connection) :
-                      "(inactive)");
-      goto out;
-    }
-  
+	  bus_context_get_max_services_per_connection (registry->context))
+	{
+	  dbus_set_error (error, DBUS_ERROR_LIMITS_EXCEEDED,
+					  "Connection \"%s\" is not allowed to own more services "
+					  "(increase limits in configuration file if required)",
+					  bus_connection_is_active (connection) ?
+					  bus_connection_get_name (connection) :
+					  "(inactive)");
+	  goto out;
+	}
+
   service = bus_registry_lookup (registry, service_name);
 
   if (service != NULL)
-    {
-      primary_owner = bus_service_get_primary_owner (service);
-      if (primary_owner != NULL)
-        old_owner_conn = primary_owner->conn;
-      else
-        old_owner_conn = NULL;
-    }
+	{
+	  primary_owner = bus_service_get_primary_owner (service);
+	  if (primary_owner != NULL)
+		old_owner_conn = primary_owner->conn;
+	  else
+		old_owner_conn = NULL;
+	}
   else
-    old_owner_conn = NULL;
-      
+	old_owner_conn = NULL;
+
   if (service == NULL)
-    {
-      service = bus_registry_ensure (registry,
-                                     service_name, connection, flags,
-                                     transaction, error);
-      if (service == NULL)
-        goto out;
-    }
+	{
+	  service = bus_registry_ensure (registry,
+									 service_name, connection, flags,
+									 transaction, error);
+	  if (service == NULL)
+		goto out;
+	}
 
   primary_owner = bus_service_get_primary_owner (service);
   if (primary_owner == NULL)
-    goto out;
+	goto out;
 
   if (old_owner_conn == NULL)
-    {
-      _dbus_assert (primary_owner->conn == connection);
+	{
+	  _dbus_assert (primary_owner->conn == connection);
 
-      *result = DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER;      
-    }
+	  *result = DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER;
+	}
   else if (old_owner_conn == connection)
-    {
-      bus_owner_set_flags (primary_owner, flags);
-      *result = DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER;
-    }
+	{
+	  bus_owner_set_flags (primary_owner, flags);
+	  *result = DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER;
+	}
   else if (((flags & DBUS_NAME_FLAG_DO_NOT_QUEUE) &&
-           !(bus_service_get_allow_replacement (service))) ||
+		   !(bus_service_get_allow_replacement (service))) ||
 	   ((flags & DBUS_NAME_FLAG_DO_NOT_QUEUE) &&
-           !(flags & DBUS_NAME_FLAG_REPLACE_EXISTING))) 
+		   !(flags & DBUS_NAME_FLAG_REPLACE_EXISTING)))
+	{
+	  DBusList *link;
+	  BusOwner *temp_owner;
+	/* Since we can't be queued if we are already in the queue
+	   remove us */
+
+	  link = _bus_service_find_owner_link (service, connection);
+	  if (link != NULL)
+		{
+		  _dbus_list_unlink (&service->owners, link);
+		  temp_owner = (BusOwner *)link->data;
+		  bus_owner_unref (temp_owner);
+		  _dbus_list_free_link (link);
+		}
+
+	  *result = DBUS_REQUEST_NAME_REPLY_EXISTS;
+	}
+  else if (!(flags & DBUS_NAME_FLAG_DO_NOT_QUEUE) &&
+		   (!(flags & DBUS_NAME_FLAG_REPLACE_EXISTING) ||
+		!(bus_service_get_allow_replacement (service))))
+	{
+	  /* Queue the connection */
+	  if (!bus_service_add_owner (service, connection,
+								  flags,
+								  transaction, error))
+		goto out;
+
+	  *result = DBUS_REQUEST_NAME_REPLY_IN_QUEUE;
+	}
+  else
+	{
+	  /* Replace the current owner */
+
+	  /* We enqueue the new owner and remove the first one because
+	   * that will cause NameAcquired and NameLost messages to
+	   * be sent.
+	   */
+
+	  if (!bus_service_add_owner (service, connection,
+								  flags,
+								  transaction, error))
+		goto out;
+
+	  if (primary_owner->do_not_queue)
+		{
+		  if (!bus_service_remove_owner (service, old_owner_conn,
+										 transaction, error))
+			goto out;
+		}
+	  else
+		{
+		  if (!bus_service_swap_owner (service, old_owner_conn,
+									   transaction, error))
+			goto out;
+		}
+
+
+	  _dbus_assert (connection == bus_service_get_primary_owner (service)->conn);
+	  *result = DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER;
+	}
+
+  activation = bus_context_get_activation (registry->context);
+  retval = bus_activation_send_pending_auto_activation_messages (activation,
+								 service,
+								 transaction,
+								 error);
+
+ out:
+  return retval;
+}
+
+#ifdef ENABLE_KDBUS_TRANSPORT
+dbus_bool_t
+bus_registry_acquire_kdbus_service (BusRegistry      *registry,
+                              DBusConnection   *connection,
+                              DBusMessage *message,
+                              dbus_uint32_t    *result,
+                              BusTransaction   *transaction,
+                              DBusError        *error)
+{
+  dbus_bool_t retval;
+  BusService *service;
+  BusActivation  *activation;
+  DBusString service_name_real;
+  const DBusString *service_name = &service_name_real;
+  char* name;
+  dbus_uint32_t flags;
+  __u64 sender_id;
+  const char* conn_unique_name;
+  DBusConnection* phantom;
+  unsigned long int uid;
+
+  if (!dbus_message_get_args (message, error,
+                              DBUS_TYPE_STRING, &name,
+                              DBUS_TYPE_UINT32, &flags,
+                              DBUS_TYPE_INVALID))
+    return FALSE;
+
+  retval = FALSE;
+
+  _dbus_string_init_const (&service_name_real, name);
+
+  if (!_dbus_validate_bus_name (service_name, 0,
+                                _dbus_string_get_length (service_name)))
     {
-      DBusList *link;
-      BusOwner *temp_owner;
-    /* Since we can't be queued if we are already in the queue
-       remove us */
+      dbus_set_error (error, DBUS_ERROR_INVALID_ARGS,
+                      "Requested bus name \"%s\" is not valid", name);
 
-      link = _bus_service_find_owner_link (service, connection);
-      if (link != NULL)
-        {
-          _dbus_list_unlink (&service->owners, link);
-          temp_owner = (BusOwner *)link->data;
-          bus_owner_unref (temp_owner); 
-          _dbus_list_free_link (link);
-        }
-      
-      *result = DBUS_REQUEST_NAME_REPLY_EXISTS;
+      _dbus_verbose ("Attempt to acquire invalid service name\n");
+
+      return FALSE;
     }
-  else if (!(flags & DBUS_NAME_FLAG_DO_NOT_QUEUE) &&
-           (!(flags & DBUS_NAME_FLAG_REPLACE_EXISTING) ||
-	    !(bus_service_get_allow_replacement (service))))
+
+  if (_dbus_string_get_byte (service_name, 0) == ':')
     {
-      /* Queue the connection */
-      if (!bus_service_add_owner (service, connection, 
-                                  flags,
-                                  transaction, error))
-        goto out;
-      
-      *result = DBUS_REQUEST_NAME_REPLY_IN_QUEUE;
+      /* Not allowed; only base services can start with ':' */
+      dbus_set_error (error, DBUS_ERROR_INVALID_ARGS,
+                      "Cannot acquire a service starting with ':' such as \"%s\"", name);
+
+      _dbus_verbose ("Attempt to acquire invalid base service name \"%s\"", name);
+
+      return FALSE;
     }
-  else
+
+  conn_unique_name = dbus_message_get_sender(message);
+
+  if (_dbus_string_equal_c_str (service_name, DBUS_SERVICE_DBUS))
     {
-      /* Replace the current owner */
+      dbus_set_error (error, DBUS_ERROR_INVALID_ARGS,
+                      "Connection \"%s\" is not allowed to own the service \"%s\"because "
+                      "it is reserved for D-Bus' use only",
+                      conn_unique_name, DBUS_SERVICE_DBUS);
+      return FALSE;
+    }
 
-      /* We enqueue the new owner and remove the first one because
-       * that will cause NameAcquired and NameLost messages to
-       * be sent.
-       */
-      
-      if (!bus_service_add_owner (service, connection,
-                                  flags,
-                                  transaction, error))
-        goto out;
+  sender_id = sender_name_to_id(conn_unique_name, error);
+  if(dbus_error_is_set(error))
+    return FALSE;
+
+  phantom = bus_connections_find_conn_by_name(bus_connection_get_connections(connection), conn_unique_name);
+  if(phantom == NULL)
+    {
+      phantom = create_phantom_connection(connection, conn_unique_name, error);
+      if(phantom == NULL)
+        return FALSE;
+    }
+
+  if (!bus_client_policy_check_can_own (bus_connection_get_policy (phantom), service_name))
+    {
+      dbus_set_error (error, DBUS_ERROR_ACCESS_DENIED,
+          "Connection \"%s\" is not allowed to own the service \"%s\" due "
+          "to security policies in the configuration file", conn_unique_name, name);
+      goto failed;
+    }
+
+  if (!kdbus_connection_get_unix_user(phantom, conn_unique_name, &uid, NULL))
+    goto failed;
+
+#ifdef POLICY_TO_KDBUS
+  if (!register_kdbus_policy(name, dbus_connection_get_transport(phantom), uid))
+  {
+    dbus_set_error (error, DBUS_ERROR_ACCESS_DENIED,
+            "Kdbus error when setting policy for connection \"%s\" and  service name \"%s\"",
+            conn_unique_name, name);
+    goto failed;
+  }
+#endif
+
+  *result = kdbus_request_name(connection, service_name, flags, sender_id);
+  if(*result == -EPERM)
+    {
+      dbus_set_error (error, DBUS_ERROR_ACCESS_DENIED,
+          "Kdbus not allowed %s to own the service \"%s\"",
+          conn_unique_name, _dbus_string_get_const_data (service_name));
+      goto failed;
+    }
+  else if(*result < 0)
+    {
+      dbus_set_error (error, DBUS_ERROR_FAILED , "Name \"%s\" could not be acquired", name);
+      goto failed;
+    }
 
-      if (primary_owner->do_not_queue)
+  if((*result == DBUS_REQUEST_NAME_REPLY_IN_QUEUE) || (*result == DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER))
+    {
+      service = bus_registry_lookup (registry, service_name);
+      if (service == NULL)
         {
-          if (!bus_service_remove_owner (service, old_owner_conn,
-                                         transaction, error))
-            goto out;
+          service = bus_registry_ensure (registry, service_name, phantom, flags,
+                       transaction, error);
+          if (service == NULL)
+            goto failed2;
         }
       else
         {
-          if (!bus_service_swap_owner (service, old_owner_conn,
-                                       transaction, error))
-            goto out;
+          if (!bus_service_add_owner (service, phantom, flags, transaction, error))
+            goto failed2;
         }
-        
-    
-      _dbus_assert (connection == bus_service_get_primary_owner (service)->conn);
-      *result = DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER;
+
+      activation = bus_context_get_activation (registry->context);
+      retval = bus_activation_send_pending_auto_activation_messages (activation,
+                   service,
+                   transaction,
+                   error);
     }
+  else
+    retval = TRUE;
 
-  activation = bus_context_get_activation (registry->context);
-  retval = bus_activation_send_pending_auto_activation_messages (activation,
-								 service,
-								 transaction,
-								 error);
-  
- out:
   return retval;
+
+failed2:
+  kdbus_release_name(phantom, service_name, sender_id);
+failed:
+  bus_connection_disconnected(phantom);
+
+  return FALSE;
 }
+#endif
 
 dbus_bool_t
 bus_registry_release_service (BusRegistry      *registry,
@@ -672,6 +863,95 @@ bus_registry_release_service (BusRegistry      *registry,
   return retval;
 }
 
+#ifdef ENABLE_KDBUS_TRANSPORT
+dbus_bool_t
+bus_registry_release_service_kdbus (const char* sender_name,
+                              DBusConnection   *connection,
+                              const DBusString *service_name,
+                              dbus_uint32_t    *result,
+                              BusTransaction   *transaction,
+                              DBusError        *error)
+{
+  dbus_bool_t retval = FALSE;
+  __u64 sender_id;
+
+  if (!_dbus_validate_bus_name (service_name, 0,
+                                _dbus_string_get_length (service_name)))
+    {
+      dbus_set_error (error, DBUS_ERROR_INVALID_ARGS,
+                      "Given bus name \"%s\" is not valid",
+                      _dbus_string_get_const_data (service_name));
+
+      _dbus_verbose ("Attempt to release invalid service name\n");
+
+      goto out;
+    }
+
+  if (_dbus_string_get_byte (service_name, 0) == ':')
+    {
+      /* Not allowed; the base service name cannot be created or released */
+      dbus_set_error (error, DBUS_ERROR_INVALID_ARGS,
+                      "Cannot release a service starting with ':' such as \"%s\"",
+                      _dbus_string_get_const_data (service_name));
+
+      _dbus_verbose ("Attempt to release invalid base service name \"%s\"",
+                     _dbus_string_get_const_data (service_name));
+
+      goto out;
+    }
+
+   if (_dbus_string_equal_c_str (service_name, DBUS_SERVICE_DBUS))
+    {
+      /* Not allowed; the base service name cannot be created or released */
+      dbus_set_error (error, DBUS_ERROR_INVALID_ARGS,
+                      "Cannot release the %s service because it is owned by the bus",
+                     DBUS_SERVICE_DBUS);
+
+      _dbus_verbose ("Attempt to release service name \"%s\"",
+                     DBUS_SERVICE_DBUS);
+
+      goto out;
+    }
+
+    sender_id = sender_name_to_id(sender_name, error);
+    if(dbus_error_is_set(error))
+        return FALSE;
+
+    *result = kdbus_release_name(connection, service_name, sender_id);
+
+    if(*result == DBUS_RELEASE_NAME_REPLY_RELEASED)
+    {
+        BusRegistry* registry;
+        BusService *service;
+
+        registry = bus_connection_get_registry (connection);
+        service = bus_registry_lookup (registry, service_name);
+        if(service)
+        {
+            DBusConnection* phantom;
+
+            phantom = _bus_service_find_owner_connection(service, sender_name);
+            if(phantom)
+            {
+                bus_service_remove_owner (service, phantom, transaction, NULL);
+                /* todo we could remove phantom if he doesn't own any name
+                 * to do this we should write function in connection.c to check if
+                 * _dbus_list_get_last (&d->services_owned) returns not NULL
+                 *  or we can leave phantom - he will be removed when he disconnects from the bus
+                 */
+            }
+            else
+                _dbus_verbose ("Didn't find phantom connection for released name!\n");
+        }
+   }
+
+  retval = TRUE;
+
+ out:
+  return retval;
+}
+#endif
+
 dbus_bool_t
 bus_registry_set_service_context_table (BusRegistry   *registry,
 					DBusHashTable *table)
@@ -800,7 +1080,7 @@ add_cancel_ownership_to_transaction (BusTransaction *transaction,
   bus_service_ref (d->service);
   bus_owner_ref (owner);
   dbus_connection_ref (d->owner->conn);
- 
+
   return TRUE;
 }
 
@@ -1220,13 +1500,29 @@ DBusConnection *
 bus_service_get_primary_owners_connection (BusService *service)
 {
   BusOwner *owner;
+#ifdef ENABLE_KDBUS_TRANSPORT
+  char unique_name[(unsigned int)(snprintf((char*)NULL, 0, "%llu", ULLONG_MAX) + sizeof(":1."))];
+#endif
 
   owner = bus_service_get_primary_owner (service);
 
+#ifdef ENABLE_KDBUS_TRANSPORT
+  if(!owner)
+    return NULL;
+  if(bus_context_is_kdbus(service->registry->context))
+  {
+    if(kdbus_get_name_owner(owner->conn, bus_service_get_name(service), unique_name) < 0)
+      return NULL;
+    return _bus_service_find_owner_connection(service, unique_name);  //bus_connections_find_conn_by_name would be safer? but slower
+  }
+  else
+    return owner->conn;
+#else
   if (owner != NULL)
     return owner->conn;
   else
     return NULL;
+#endif
 }
 
 BusOwner*
@@ -1255,6 +1551,22 @@ bus_service_get_allow_replacement (BusService *service)
   return owner->allow_replacement;
 }
 
+#ifdef ENABLE_KDBUS_TRANSPORT
+dbus_bool_t
+bus_service_get_is_kdbus_starter (BusService *service)
+{
+  BusOwner *owner;
+  DBusList *link;
+
+  _dbus_assert (service->owners != NULL);
+
+  link = _dbus_list_get_first_link (&service->owners);
+  owner = (BusOwner *) link->data;
+
+  return owner->is_kdbus_starter;
+}
+#endif
+
 dbus_bool_t
 bus_service_has_owner (BusService     *service,
 		       DBusConnection *connection)
@@ -1289,8 +1601,11 @@ bus_service_list_queued_owners (BusService *service,
       owner = (BusOwner *) link->data;
       uname = bus_connection_get_name (owner->conn);
 
-      if (!_dbus_list_append (return_list, (char *)uname))
-        goto oom;
+#ifdef ENABLE_KDBUS_TRANSPORT
+      if(!owner->is_kdbus_starter)
+#endif
+          if (!_dbus_list_append (return_list, (char *)uname))
+              goto oom;
 
       link = _dbus_list_get_next_link (&service->owners, link);
     }
diff --git a/bus/services.h b/bus/services.h
index 056dd9f..b459b0d 100644
--- a/bus/services.h
+++ b/bus/services.h
@@ -63,6 +63,22 @@ dbus_bool_t  bus_registry_release_service (BusRegistry                 *registry
                                            dbus_uint32_t               *result,
                                            BusTransaction              *transaction,
                                            DBusError                   *error);
+#ifdef ENABLE_KDBUS_TRANSPORT
+dbus_bool_t bus_registry_acquire_kdbus_service (BusRegistry      *registry,
+                                                 DBusConnection   *connection,
+                                                 DBusMessage *message,
+                                                 dbus_uint32_t    *result,
+                                                 BusTransaction   *transaction,
+                                                 DBusError        *error);
+
+
+dbus_bool_t bus_registry_release_service_kdbus (const char* sender_name,
+                                          DBusConnection   *connection,
+                                          const DBusString *service_name,
+                                          dbus_uint32_t    *result,
+                                          BusTransaction   *transaction,
+                                          DBusError        *error);
+#endif
 dbus_bool_t  bus_registry_set_service_context_table (BusRegistry           *registry,
 						     DBusHashTable         *table);
 
@@ -85,6 +101,9 @@ dbus_bool_t     bus_service_has_owner                 (BusService     *service,
                                                        DBusConnection *connection);
 BusOwner*       bus_service_get_primary_owner         (BusService     *service);
 dbus_bool_t     bus_service_get_allow_replacement     (BusService     *service);
+#ifdef ENABLE_KDBUS_TRANSPORT
+dbus_bool_t     bus_service_get_is_kdbus_starter      (BusService     *service);
+#endif
 const char*     bus_service_get_name                  (BusService     *service);
 dbus_bool_t     bus_service_list_queued_owners        (BusService *service,
                                                        DBusList  **return_list,
diff --git a/configure.ac b/configure.ac
index ed77046..b5a906a 100644
--- a/configure.ac
+++ b/configure.ac
@@ -155,6 +155,8 @@ AC_ARG_ENABLE(kqueue, AS_HELP_STRING([--enable-kqueue],[build with kqueue suppor
 AC_ARG_ENABLE(console-owner-file, AS_HELP_STRING([--enable-console-owner-file],[enable console owner file]),enable_console_owner_file=$enableval,enable_console_owner_file=auto)
 AC_ARG_ENABLE(launchd, AS_HELP_STRING([--enable-launchd],[build with launchd auto-launch support]),enable_launchd=$enableval,enable_launchd=auto)
 AC_ARG_ENABLE(systemd, AS_HELP_STRING([--enable-systemd],[build with systemd at_console support]),enable_systemd=$enableval,enable_systemd=auto)
+AC_ARG_ENABLE(kdbus-transport, AS_HELP_STRING([--enable-kdbus-transport],[build with kdbus transport support]),enable_kdbus_transport=$enableval,enable_kdbus_transport=no)
+AC_ARG_ENABLE(kdbus-for-sbb, AS_HELP_STRING([--enable-kdbus-for-sbb],[build with kdbus sbb support]),enable_kdbus_for_sbb=$enableval,enable_kdbus_for_sbb=no)
 
 AC_ARG_WITH(init-scripts, AS_HELP_STRING([--with-init-scripts=[redhat]],[Style of init scripts to install]))
 AC_ARG_WITH(session-socket-dir, AS_HELP_STRING([--with-session-socket-dir=[dirname]],[Where to put sockets for the per-login-session message bus]))
@@ -814,7 +816,7 @@ AC_CHECK_FUNCS(pipe2 accept4)
 
 #### Abstract sockets
 
-if test x$enable_abstract_sockets = xauto; then
+if test x$enable_abstract_sockets != xno; then
 AC_LANG_PUSH(C)
 warn_on_xcompile=no
 AC_CACHE_CHECK([abstract socket namespace],
@@ -1243,10 +1245,35 @@ AC_DEFINE_UNQUOTED([DBUS_DEFAULT_MESSAGE_UNIX_FDS],
   [Default for dbus_connection_get_max_message_unix_fds()])
 AC_SUBST([DEFAULT_MESSAGE_UNIX_FDS])
 
+### kdbus support
+if test x$enable_kdbus_transport = xyes; then
+    KDBUS_LIBS=
+    #"-lcrypto"
+    #AC_SUBST([KDBUS_LIBS])
+    AC_DEFINE(ENABLE_KDBUS_TRANSPORT,1,[Enable kdbus transport support])
+else
+    KDBUS_LIBS=
+fi
+
+AM_CONDITIONAL([ENABLE_KDBUS_TRANSPORT], [test x$enable_kdbus_transport = xyes])
+
+### sbb support
+if test x$enable_kdbus_for_sbb = xyes; then
+    KDBUS_LIBS=
+    #"-lcrypto"
+    #AC_SUBST([KDBUS_LIBS])
+    AC_DEFINE(KDBUS_FOR_SBB,1,[Enable SBB support])
+else
+    KDBUS_LIBS=
+fi
+
+AM_CONDITIONAL([ENABLE_KDBUS_FOR_SBB], [test x$enable_kdbus_for_sbb = xyes])
+
 #### Set up final flags
-LIBDBUS_LIBS="$THREAD_LIBS $NETWORK_libs"
+LIBDBUS_LIBS="$THREAD_LIBS $NETWORK_libs $KDBUS_LIBS"
 AC_SUBST([LIBDBUS_LIBS])
 
+
 ### X11 detection
 DBUS_X_LIBS=
 DBUS_X_CFLAGS=
@@ -1758,6 +1785,8 @@ Makefile
 dbus/Makefile
 bus/Makefile
 tools/Makefile
+samsung_tools/Makefile
+samsung_tools/test_foxp_latency/Makefile
 test/Makefile
 test/name-test/Makefile
 doc/Makefile
@@ -1834,6 +1863,8 @@ echo "
         Building Doxygen docs:    ${enable_doxygen_docs}
         Building XML docs:        ${enable_xml_docs}
         Building launchd support: ${have_launchd}
+        Building kdbus support:   ${enable_kdbus_transport}
+        Building kdbus for sbb:   ${enable_kdbus_for_sbb}
         Init scripts style:       ${with_init_scripts}
         Abstract socket names:    ${ac_cv_have_abstract_sockets}
         System bus socket:        ${DBUS_SYSTEM_SOCKET}
@@ -1844,8 +1875,8 @@ echo "
         Console auth dir:         ${DBUS_CONSOLE_AUTH_DIR}
         Console owner file:       ${have_console_owner_file}
         Console owner file path:  ${DBUS_CONSOLE_OWNER_FILE}
-	System bus user:          ${DBUS_USER}
-	Session bus services dir: ${EXPANDED_DATADIR}/dbus-1/services
+        System bus user:          ${DBUS_USER}
+        Session bus services dir: ${EXPANDED_DATADIR}/dbus-1/services
         'make check' socket dir:  ${TEST_SOCKET_DIR}
 "
 if test x$have_launchd = xyes; then
diff --git a/dbus/.project b/dbus/.project
new file mode 100644
index 0000000..b8a675d
--- /dev/null
+++ b/dbus/.project
@@ -0,0 +1,109 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>dbus</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.cdt.managedbuilder.core.genmakebuilder</name>
+			<triggers>clean,full,incremental,</triggers>
+			<arguments>
+				<dictionary>
+					<key>?name?</key>
+					<value></value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.append_environment</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.autoBuildTarget</key>
+					<value>all</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.buildArguments</key>
+					<value></value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.buildCommand</key>
+					<value>make</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.buildLocation</key>
+					<value>${workspace_loc:/libdbus}</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.cleanBuildTarget</key>
+					<value>clean</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.contents</key>
+					<value>org.eclipse.cdt.make.core.activeConfigSettings</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.enableAutoBuild</key>
+					<value>false</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.enableCleanBuild</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.enableFullBuild</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.fullBuildTarget</key>
+					<value>all</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.stopOnError</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.useDefaultBuildCmd</key>
+					<value>true</value>
+				</dictionary>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.cdt.managedbuilder.core.ScannerConfigBuilder</name>
+			<triggers>full,incremental,</triggers>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.tizen.nativecpp.apichecker.core.builder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.cdt.core.cnature</nature>
+		<nature>org.eclipse.cdt.core.ccnature</nature>
+		<nature>org.eclipse.cdt.managedbuilder.core.managedBuildNature</nature>
+		<nature>org.eclipse.cdt.managedbuilder.core.ScannerConfigNature</nature>
+		<nature>org.tizen.nativecpp.apichecker.core.tizenCppNature</nature>
+	</natures>
+	<filteredResources>
+		<filter>
+			<id>1386660941020</id>
+			<name></name>
+			<type>6</type>
+			<matcher>
+				<id>org.eclipse.ui.ide.multiFilter</id>
+				<arguments>1.0-name-matches-false-false-*.lo</arguments>
+			</matcher>
+		</filter>
+		<filter>
+			<id>1386660941025</id>
+			<name></name>
+			<type>6</type>
+			<matcher>
+				<id>org.eclipse.ui.ide.multiFilter</id>
+				<arguments>1.0-name-matches-false-false-*.orig</arguments>
+			</matcher>
+		</filter>
+	</filteredResources>
+</projectDescription>
diff --git a/dbus/Makefile.am b/dbus/Makefile.am
index b248107..dd42cd4 100644
--- a/dbus/Makefile.am
+++ b/dbus/Makefile.am
@@ -111,6 +111,14 @@ DBUS_SHARED_arch_sources = 			\
 	sd-daemon.c                             \
 	sd-daemon.h
 
+if ENABLE_KDBUS_TRANSPORT
+DBUS_SHARED_arch_sources += \
+    dbus-transport-kdbus.c  \
+    dbus-transport-kdbus.h  \
+    kdbus-common.c          \
+    kdbus-common.h
+endif
+
 DBUS_UTIL_arch_sources = 			\
 	dbus-sysdeps-util-unix.c		\
 	dbus-userdb-util.c			\
diff --git a/dbus/dbus-auth.c b/dbus/dbus-auth.c
index 6a07665..b5ba61e 100644
--- a/dbus/dbus-auth.c
+++ b/dbus/dbus-auth.c
@@ -2,6 +2,7 @@
 /* dbus-auth.c Authentication
  *
  * Copyright (C) 2002, 2003, 2004 Red Hat Inc.
+ * Copyright (C) 2013  Samsung Electronics
  *
  * Licensed under the Academic Free License version 2.1
  * 
@@ -2321,6 +2322,49 @@ _dbus_auth_client_new (void)
   return auth;
 }
 
+#ifdef ENABLE_KDBUS_TRANSPORT
+/**
+ * Creates a new auth conversation object for the client side of kdbus.
+ * In fact it only initialize structures and sets authenticated state
+ * because of different authentication-like mechanism in kdbus - policies
+ * TODO Probably to be checked and modified when kdbus will be documented
+ *
+ * @returns the new object or #NULL if no memory
+ */
+DBusAuth*
+_dbus_auth_client_new_kdbus (void)
+{
+  DBusAuth *auth;
+  DBusString guid_str;
+
+  if (!_dbus_string_init (&guid_str))
+    return NULL;
+
+  auth = _dbus_auth_new (sizeof (DBusAuthClient));
+  if (auth == NULL)
+    {
+      _dbus_string_free (&guid_str);
+      return NULL;
+    }
+
+  DBUS_AUTH_CLIENT (auth)->guid_from_server = guid_str;
+
+  auth->side = auth_side_client;
+  auth->state = &common_state_authenticated;
+  auth->unix_fd_negotiated = TRUE;
+
+  /* Start the auth conversation by sending AUTH for our default
+   * mechanism */
+/*  if (!send_auth (auth, &all_mechanisms[0]))
+    {
+      _dbus_auth_unref (auth);
+      return NULL;
+    }*/
+
+  return auth;
+}
+#endif
+
 /**
  * Increments the refcount of an auth object.
  *
diff --git a/dbus/dbus-auth.h b/dbus/dbus-auth.h
index ba1975f..d014582 100644
--- a/dbus/dbus-auth.h
+++ b/dbus/dbus-auth.h
@@ -2,6 +2,7 @@
 /* dbus-auth.h Authentication
  *
  * Copyright (C) 2002  Red Hat Inc.
+ * Copyright (C) 2013  Samsung Electronics
  *
  * Licensed under the Academic Free License version 2.1
  * 
@@ -43,6 +44,9 @@ typedef enum
 
 DBusAuth*     _dbus_auth_server_new          (const DBusString       *guid);
 DBusAuth*     _dbus_auth_client_new          (void);
+#ifdef ENABLE_KDBUS_TRANSPORT
+DBusAuth* 	  _dbus_auth_client_new_kdbus 	 (void);
+#endif
 DBusAuth*     _dbus_auth_ref                 (DBusAuth               *auth);
 void          _dbus_auth_unref               (DBusAuth               *auth);
 dbus_bool_t   _dbus_auth_set_mechanisms      (DBusAuth               *auth,
diff --git a/dbus/dbus-bus.c b/dbus/dbus-bus.c
index 0fd4831..4ae54d0 100644
--- a/dbus/dbus-bus.c
+++ b/dbus/dbus-bus.c
@@ -3,6 +3,7 @@
  *
  * Copyright (C) 2003  CodeFactory AB
  * Copyright (C) 2003  Red Hat, Inc.
+ * Copyright (C) 2013  Samsung Electronics
  *
  * Licensed under the Academic Free License version 2.1
  * 
@@ -32,6 +33,12 @@
 #include "dbus-threads-internal.h"
 #include "dbus-connection-internal.h"
 #include "dbus-string.h"
+#ifdef ENABLE_KDBUS_TRANSPORT
+#include "dbus-transport-kdbus.h"
+#include <stdlib.h>
+#include <limits.h>
+#include <stdio.h>
+#endif
 
 /**
  * @defgroup DBusBus Message bus APIs
@@ -135,6 +142,15 @@ get_from_env (char           **connection_p,
     }
 }
 
+#ifdef ENABLE_KDBUS_TRANSPORT
+void dbus_bus_set_bus_connection_address(DBusBusType address_type, char* address)
+{
+	if(bus_connection_addresses[address_type] != NULL)
+		free(bus_connection_addresses[address_type]);
+	bus_connection_addresses[address_type] = address;
+}
+#endif
+
 static dbus_bool_t
 init_session_address (void)
 {
@@ -647,7 +663,7 @@ dbus_bus_register (DBusConnection *connection,
                    DBusError      *error)
 {
   DBusMessage *message, *reply;
-  char *name;
+  char *name = NULL;
   BusData *bd;
   dbus_bool_t retval;
 
@@ -680,36 +696,35 @@ dbus_bus_register (DBusConnection *connection,
       retval = TRUE;
       goto out;
     }
-  
   message = dbus_message_new_method_call (DBUS_SERVICE_DBUS,
-                                          DBUS_PATH_DBUS,
-                                          DBUS_INTERFACE_DBUS,
-                                          "Hello"); 
-
+											  DBUS_PATH_DBUS,
+											  DBUS_INTERFACE_DBUS,
+											  "Hello");
   if (!message)
-    {
-      _DBUS_SET_OOM (error);
-      goto out;
-    }
-  
+	{
+	  _DBUS_SET_OOM (error);
+	  goto out;
+	}
+
   reply = dbus_connection_send_with_reply_and_block (connection, message, -1, error);
 
   if (reply == NULL)
-    goto out;
+	goto out;
   else if (dbus_set_error_from_message (error, reply))
-    goto out;
+	goto out;
   else if (!dbus_message_get_args (reply, error,
-                                   DBUS_TYPE_STRING, &name,
-                                   DBUS_TYPE_INVALID))
-    goto out;
-  
+								   DBUS_TYPE_STRING, &name,
+								   DBUS_TYPE_INVALID))
+	goto out;
+
   bd->unique_name = _dbus_strdup (name);
+
   if (bd->unique_name == NULL)
     {
       _DBUS_SET_OOM (error);
       goto out;
     }
-  
+
   retval = TRUE;
   
  out:
@@ -1114,65 +1129,63 @@ dbus_bus_request_name (DBusConnection *connection,
                        unsigned int    flags,
                        DBusError      *error)
 {
-  DBusMessage *message, *reply;
-  dbus_uint32_t result;
-
-  _dbus_return_val_if_fail (connection != NULL, 0);
-  _dbus_return_val_if_fail (name != NULL, 0);
-  _dbus_return_val_if_fail (_dbus_check_is_valid_bus_name (name), 0);
-  _dbus_return_val_if_error_is_set (error, 0);
-  
-  message = dbus_message_new_method_call (DBUS_SERVICE_DBUS,
-                                          DBUS_PATH_DBUS,
-                                          DBUS_INTERFACE_DBUS,
-                                          "RequestName");
-
-  if (message == NULL)
-    {
-      _DBUS_SET_OOM (error);
-      return -1;
-    }
- 
-  if (!dbus_message_append_args (message,
-				 DBUS_TYPE_STRING, &name,
-				 DBUS_TYPE_UINT32, &flags,
-				 DBUS_TYPE_INVALID))
-    {
-      dbus_message_unref (message);
-      _DBUS_SET_OOM (error);
-      return -1;
-    }
-  
-  reply = dbus_connection_send_with_reply_and_block (connection, message, -1,
-                                                     error);
-  
-  dbus_message_unref (message);
-  
-  if (reply == NULL)
-    {
-      _DBUS_ASSERT_ERROR_IS_SET (error);
-      return -1;
-    }  
-
-  if (dbus_set_error_from_message (error, reply))
-    {
-      _DBUS_ASSERT_ERROR_IS_SET (error);
-      dbus_message_unref (reply);
-      return -1;
-    }
-  
-  if (!dbus_message_get_args (reply, error,
-                              DBUS_TYPE_UINT32, &result,
-                              DBUS_TYPE_INVALID))
-    {
-      _DBUS_ASSERT_ERROR_IS_SET (error);
-      dbus_message_unref (reply);
-      return -1;
-    }
-
-  dbus_message_unref (reply);
-  
-  return result;
+	dbus_uint32_t result;
+	DBusMessage *message, *reply;
+
+	_dbus_return_val_if_fail (connection != NULL, 0);
+	_dbus_return_val_if_fail (name != NULL, 0);
+	_dbus_return_val_if_fail (_dbus_check_is_valid_bus_name (name), 0);
+	_dbus_return_val_if_error_is_set (error, 0);
+
+	message = dbus_message_new_method_call (DBUS_SERVICE_DBUS,
+											  DBUS_PATH_DBUS,
+											  DBUS_INTERFACE_DBUS,
+											  "RequestName");
+	if (message == NULL)
+	{
+	  _DBUS_SET_OOM (error);
+	  return -1;
+	}
+
+	if (!dbus_message_append_args (message,
+					 DBUS_TYPE_STRING, &name,
+					 DBUS_TYPE_UINT32, &flags,
+					 DBUS_TYPE_INVALID))
+	{
+		dbus_message_unref (message);
+		_DBUS_SET_OOM (error);
+		return -1;
+	}
+
+	reply = dbus_connection_send_with_reply_and_block (connection, message, -1,
+														 error);
+
+	dbus_message_unref (message);
+
+	if (reply == NULL)
+	{
+		_DBUS_ASSERT_ERROR_IS_SET (error);
+		return -1;
+	}
+
+	if (dbus_set_error_from_message (error, reply))
+	{
+		_DBUS_ASSERT_ERROR_IS_SET (error);
+		dbus_message_unref (reply);
+		return -1;
+	}
+
+	if (!dbus_message_get_args (reply, error,
+								  DBUS_TYPE_UINT32, &result,
+								  DBUS_TYPE_INVALID))
+	{
+		_DBUS_ASSERT_ERROR_IS_SET (error);
+		dbus_message_unref (reply);
+		return -1;
+	}
+
+	dbus_message_unref (reply);
+	return result;
 }
 
 
@@ -1527,32 +1540,32 @@ dbus_bus_add_match (DBusConnection *connection,
                     const char     *rule,
                     DBusError      *error)
 {
-  DBusMessage *msg;
+	DBusMessage *msg;
 
-  _dbus_return_if_fail (rule != NULL);
+	_dbus_return_if_fail (rule != NULL);
 
-  msg = dbus_message_new_method_call (DBUS_SERVICE_DBUS,
+	msg = dbus_message_new_method_call (DBUS_SERVICE_DBUS,
                                       DBUS_PATH_DBUS,
                                       DBUS_INTERFACE_DBUS,
                                       "AddMatch");
 
-  if (msg == NULL)
-    {
-      _DBUS_SET_OOM (error);
-      return;
-    }
+	if (msg == NULL)
+	{
+		_DBUS_SET_OOM (error);
+		return;
+	}
 
-  if (!dbus_message_append_args (msg, DBUS_TYPE_STRING, &rule,
-                                 DBUS_TYPE_INVALID))
-    {
-      dbus_message_unref (msg);
-      _DBUS_SET_OOM (error);
-      return;
-    }
+	if (!dbus_message_append_args (msg, DBUS_TYPE_STRING, &rule,
+									 DBUS_TYPE_INVALID))
+	{
+		dbus_message_unref (msg);
+		_DBUS_SET_OOM (error);
+		return;
+	}
 
-  send_no_return_values (connection, msg, error);
+	send_no_return_values (connection, msg, error);
 
-  dbus_message_unref (msg);
+	dbus_message_unref (msg);
 }
 
 /**
@@ -1577,26 +1590,26 @@ dbus_bus_remove_match (DBusConnection *connection,
                        const char     *rule,
                        DBusError      *error)
 {
-  DBusMessage *msg;
+	DBusMessage *msg;
 
-  _dbus_return_if_fail (rule != NULL);
-  
-  msg = dbus_message_new_method_call (DBUS_SERVICE_DBUS,
-                                      DBUS_PATH_DBUS,
-                                      DBUS_INTERFACE_DBUS,
-                                      "RemoveMatch");
+	_dbus_return_if_fail (rule != NULL);
 
-  if (!dbus_message_append_args (msg, DBUS_TYPE_STRING, &rule,
-                                 DBUS_TYPE_INVALID))
-    {
-      dbus_message_unref (msg);
-      _DBUS_SET_OOM (error);
-      return;
-    }
+	msg = dbus_message_new_method_call (DBUS_SERVICE_DBUS,
+										  DBUS_PATH_DBUS,
+										  DBUS_INTERFACE_DBUS,
+										  "RemoveMatch");
 
-  send_no_return_values (connection, msg, error);
+	if (!dbus_message_append_args (msg, DBUS_TYPE_STRING, &rule,
+									 DBUS_TYPE_INVALID))
+	{
+		dbus_message_unref (msg);
+		_DBUS_SET_OOM (error);
+		return;
+	}
 
-  dbus_message_unref (msg);
+	send_no_return_values (connection, msg, error);
+
+	dbus_message_unref (msg);
 }
 
 /** @} */
diff --git a/dbus/dbus-bus.h b/dbus/dbus-bus.h
index 02a9571..e8549e7 100644
--- a/dbus/dbus-bus.h
+++ b/dbus/dbus-bus.h
@@ -28,6 +28,9 @@
 #define DBUS_BUS_H
 
 #include <dbus/dbus-connection.h>
+#ifdef ENABLE_KDBUS_TRANSPORT
+#include "dbus-address.h"
+#endif
 
 DBUS_BEGIN_DECLS
 
@@ -36,6 +39,11 @@ DBUS_BEGIN_DECLS
  * @{
  */
 
+#ifdef ENABLE_KDBUS_TRANSPORT
+DBUS_EXPORT
+void			dbus_bus_set_bus_connection_address(DBusBusType address_type, char* address);
+#endif
+
 DBUS_EXPORT
 DBusConnection *dbus_bus_get              (DBusBusType     type,
 					   DBusError      *error);
diff --git a/dbus/dbus-connection-internal.h b/dbus/dbus-connection-internal.h
index 2842f2f..6e1bc30 100644
--- a/dbus/dbus-connection-internal.h
+++ b/dbus/dbus-connection-internal.h
@@ -72,6 +72,9 @@ void              _dbus_connection_toggle_timeout_unlocked     (DBusConnection
                                                                 DBusTimeout        *timeout,
                                                                 dbus_bool_t         enabled);
 DBusConnection*   _dbus_connection_new_for_transport           (DBusTransport      *transport);
+#ifdef ENABLE_KDBUS_TRANSPORT
+DBusConnection*   _dbus_connection_new_for_used_transport       (DBusTransport *transport);
+#endif
 void              _dbus_connection_do_iteration_unlocked       (DBusConnection     *connection,
                                                                 DBusPendingCall    *pending,
                                                                 unsigned int        flags,
diff --git a/dbus/dbus-connection.c b/dbus/dbus-connection.c
index f0b6871..f5f8df9 100644
--- a/dbus/dbus-connection.c
+++ b/dbus/dbus-connection.c
@@ -2,6 +2,7 @@
 /* dbus-connection.c DBusConnection object
  *
  * Copyright (C) 2002-2006  Red Hat Inc.
+ * Copyright (C) 2013  Samsung Electronics
  *
  * Licensed under the Academic Free License version 2.1
  * 
@@ -44,6 +45,11 @@
 #include "dbus-threads-internal.h"
 #include "dbus-bus.h"
 #include "dbus-marshal-basic.h"
+#ifdef ENABLE_KDBUS_TRANSPORT
+#include "dbus-transport-kdbus.h"
+#include "kdbus-common.h"
+#include <stdlib.h>
+#endif
 
 #ifdef DBUS_DISABLE_CHECKS
 #define TOOK_LOCK_CHECK(connection)
@@ -1244,9 +1250,14 @@ _dbus_connection_do_iteration_unlocked (DBusConnection *connection,
  *
  * @param transport the transport.
  * @returns the new connection, or #NULL on failure.
- */
+*/
+#ifdef ENABLE_KDBUS_TRANSPORT
+static DBusConnection*
+_dbus_connection_new_for_transport_internal (DBusTransport *transport, dbus_bool_t exists)
+#else
 DBusConnection*
 _dbus_connection_new_for_transport (DBusTransport *transport)
+#endif
 {
   DBusConnection *connection;
   DBusWatchList *watch_list;
@@ -1276,7 +1287,7 @@ _dbus_connection_new_for_transport (DBusTransport *transport)
 
   pending_replies =
     _dbus_hash_table_new (DBUS_HASH_INT,
-			  NULL,
+              NULL,
                           (DBusFreeFunction)free_pending_call_on_hash_removal);
   if (pending_replies == NULL)
     goto error;
@@ -1346,7 +1357,7 @@ _dbus_connection_new_for_transport (DBusTransport *transport)
   connection->route_peer_messages = FALSE;
   connection->disconnected_message_arrived = FALSE;
   connection->disconnected_message_processed = FALSE;
-  
+
 #if defined(DBUS_ENABLE_CHECKS) || defined(DBUS_ENABLE_ASSERT)
   connection->generation = _dbus_current_generation;
 #endif
@@ -1357,18 +1368,23 @@ _dbus_connection_new_for_transport (DBusTransport *transport)
 
   connection->disconnect_message_link = disconnect_link;
 
-  CONNECTION_LOCK (connection);
-  
-  if (!_dbus_transport_set_connection (transport, connection))
-    {
-      CONNECTION_UNLOCK (connection);
+#ifdef ENABLE_KDBUS_TRANSPORT
+  if(!exists)
+#endif
+  {
+      CONNECTION_LOCK (connection);
 
-      goto error;
-    }
+      if (!_dbus_transport_set_connection (transport, connection))
+        {
+          CONNECTION_UNLOCK (connection);
 
-  _dbus_transport_ref (transport);
+          goto error;
+        }
 
-  CONNECTION_UNLOCK (connection);
+      _dbus_transport_ref (transport);
+
+      CONNECTION_UNLOCK (connection);
+  }
 
   _dbus_connection_trace_ref (connection, 0, 1, "new_for_transport");
   return connection;
@@ -1408,6 +1424,29 @@ _dbus_connection_new_for_transport (DBusTransport *transport)
   return NULL;
 }
 
+#ifdef ENABLE_KDBUS_TRANSPORT
+/**
+ * Creates a new connection for the given transport.  A transport
+ * represents a message stream that uses some concrete mechanism, such
+ * as UNIX domain sockets. May return #NULL if insufficient
+ * memory exists to create the connection.
+ *
+ * @param transport the transport.
+ * @returns the new connection, or #NULL on failure.
+ */
+DBusConnection*
+_dbus_connection_new_for_transport (DBusTransport *transport)
+{
+    return _dbus_connection_new_for_transport_internal(transport, FALSE);
+}
+
+DBusConnection*
+_dbus_connection_new_for_used_transport (DBusTransport *transport)
+{
+    return _dbus_connection_new_for_transport_internal(transport, TRUE);
+}
+#endif
+
 /**
  * Increments the reference count of a DBusConnection.
  * Requires that the caller already holds the connection lock.
@@ -1836,6 +1875,7 @@ connection_try_from_address_entry (DBusAddressEntry *entry,
 #ifndef DBUS_DISABLE_CHECKS
   _dbus_assert (!connection->have_connection_lock);
 #endif
+
   return connection;
 }
 
@@ -2182,7 +2222,7 @@ _dbus_memory_pause_based_on_timeout (int timeout_milliseconds)
     _dbus_sleep_milliseconds (1000);
 }
 
-static DBusMessage *
+DBusMessage *
 generate_local_error_message (dbus_uint32_t serial, 
                               char *error_name, 
                               char *error_msg)
@@ -2675,12 +2715,13 @@ free_outgoing_message (void *element,
   dbus_message_unref (message);
 }
 
-/* This is run without the mutex held, but after the last reference
- * to the connection has been dropped we should have no thread-related
- * problems
- */
+#ifdef ENABLE_KDBUS_TRANSPORT
+static void
+_dbus_connection_last_unref_internal (DBusConnection *connection, dbus_bool_t unref_transport)
+#else
 static void
 _dbus_connection_last_unref (DBusConnection *connection)
+#endif
 {
   DBusList *link;
 
@@ -2691,7 +2732,10 @@ _dbus_connection_last_unref (DBusConnection *connection)
   /* You have to disconnect the connection before unref:ing it. Otherwise
    * you won't get the disconnected message.
    */
-  _dbus_assert (!_dbus_transport_get_is_connected (connection->transport));
+#ifdef ENABLE_KDBUS_TRANSPORT
+  if(unref_transport)
+#endif
+      _dbus_assert (!_dbus_transport_get_is_connected (connection->transport));
   _dbus_assert (connection->server_guid == NULL);
   
   /* ---- We're going to call various application callbacks here, hope it doesn't break anything... */
@@ -2735,17 +2779,20 @@ _dbus_connection_last_unref (DBusConnection *connection)
   
   _dbus_list_foreach (&connection->outgoing_messages,
                       free_outgoing_message,
-		      connection);
+              connection);
   _dbus_list_clear (&connection->outgoing_messages);
   
   _dbus_list_foreach (&connection->incoming_messages,
-		      (DBusForeachFunction) dbus_message_unref,
-		      NULL);
+              (DBusForeachFunction) dbus_message_unref,
+              NULL);
   _dbus_list_clear (&connection->incoming_messages);
 
   _dbus_counter_unref (connection->outgoing_counter);
 
-  _dbus_transport_unref (connection->transport);
+#ifdef ENABLE_KDBUS_TRANSPORT
+  if(unref_transport)
+#endif
+      _dbus_transport_unref (connection->transport);
 
   if (connection->disconnect_message_link)
     {
@@ -2767,6 +2814,18 @@ _dbus_connection_last_unref (DBusConnection *connection)
   dbus_free (connection);
 }
 
+#ifdef ENABLE_KDBUS_TRANSPORT
+/* This is run without the mutex held, but after the last reference
+ * to the connection has been dropped we should have no thread-related
+ * problems
+ */
+static void
+_dbus_connection_last_unref (DBusConnection *connection)
+{
+    _dbus_connection_last_unref_internal(connection, TRUE);
+}
+#endif
+
 /**
  * Decrements the reference count of a DBusConnection, and finalizes
  * it if the count reaches zero.
@@ -2815,6 +2874,24 @@ dbus_connection_unref (DBusConnection *connection)
     }
 }
 
+#ifdef ENABLE_KDBUS_TRANSPORT
+void
+dbus_connection_unref_phantom (DBusConnection *connection)
+{
+  dbus_int32_t old_refcount;
+
+  _dbus_return_if_fail (connection != NULL);
+  _dbus_return_if_fail (connection->generation == _dbus_current_generation);
+
+  old_refcount = _dbus_atomic_dec (&connection->refcount);
+
+  _dbus_connection_trace_ref (connection, old_refcount, old_refcount - 1, "unref");
+
+  if (old_refcount == 1)
+      _dbus_connection_last_unref_internal(connection, FALSE);
+}
+#endif
+
 /*
  * Note that the transport can disconnect itself (other end drops us)
  * and in that case this function never runs. So this function must
@@ -2978,6 +3055,26 @@ dbus_connection_get_is_authenticated (DBusConnection *connection)
   return res;
 }
 
+#ifdef ENABLE_KDBUS_TRANSPORT
+/**
+ * Sets authenticated status for connection. Needed for kdbus, where authentication is
+ * made in different manner.
+ * LOCK commented out because called with lock already set
+ * @param connection the connection
+ */
+dbus_bool_t
+dbus_connection_set_is_authenticated (DBusConnection *connection)
+{
+  _dbus_return_val_if_fail (connection != NULL, FALSE);
+
+//  CONNECTION_LOCK (connection);
+  connection->transport->authenticated = TRUE;
+//  CONNECTION_UNLOCK (connection);
+
+  return TRUE;
+}
+#endif
+
 /**
  * Gets whether the connection is not authenticated as a specific
  * user.  If the connection is not authenticated, this function
@@ -4224,7 +4321,7 @@ static DBusDispatchStatus
 _dbus_connection_get_dispatch_status_unlocked (DBusConnection *connection)
 {
   HAVE_LOCK_CHECK (connection);
-  
+
   if (connection->n_incoming > 0)
     return DBUS_DISPATCH_DATA_REMAINS;
   else if (!_dbus_transport_queue_messages (connection->transport))
@@ -4233,7 +4330,7 @@ _dbus_connection_get_dispatch_status_unlocked (DBusConnection *connection)
     {
       DBusDispatchStatus status;
       dbus_bool_t is_connected;
-      
+
       status = _dbus_transport_get_dispatch_status (connection->transport);
       is_connected = _dbus_transport_get_is_connected (connection->transport);
 
@@ -5136,7 +5233,6 @@ dbus_connection_get_socket(DBusConnection              *connection,
   return retval;
 }
 
-
 /**
  * Gets the UNIX user ID of the connection if known.  Returns #TRUE if
  * the uid is filled in.  Always returns #FALSE on non-UNIX platforms
@@ -5170,16 +5266,26 @@ dbus_connection_get_unix_user (DBusConnection *connection,
 
   CONNECTION_LOCK (connection);
 
-  if (!_dbus_transport_try_to_authenticate (connection->transport))
-    result = FALSE;
+#ifdef ENABLE_KDBUS_TRANSPORT
+  if (_dbus_connection_get_address (connection) != NULL)
+    {
+      if (!strncmp (_dbus_connection_get_address (connection), "kdbus:", strlen("kdbus:")))
+        result = kdbus_connection_get_unix_user (connection, dbus_bus_get_unique_name (connection), uid, NULL);
+    }
   else
-    result = _dbus_transport_get_unix_user (connection->transport,
-                                            uid);
+#endif
+    {
+      if (!_dbus_transport_try_to_authenticate (connection->transport))
+        result = FALSE;
+      else
+        result = _dbus_transport_get_unix_user (connection->transport,
+                                                uid);
+    }
 
 #ifdef DBUS_WIN
   _dbus_assert (!result);
 #endif
-  
+
   CONNECTION_UNLOCK (connection);
 
   return result;
@@ -5206,11 +5312,21 @@ dbus_connection_get_unix_process_id (DBusConnection *connection,
 
   CONNECTION_LOCK (connection);
 
-  if (!_dbus_transport_try_to_authenticate (connection->transport))
-    result = FALSE;
+#ifdef ENABLE_KDBUS_TRANSPORT
+  if (_dbus_connection_get_address (connection) != NULL)
+    {
+      if (!strncmp (_dbus_connection_get_address (connection), "kdbus:", strlen("kdbus:")))
+        result = kdbus_connection_get_unix_process_id (connection, dbus_bus_get_unique_name (connection), pid, NULL);
+    }
   else
-    result = _dbus_transport_get_unix_process_id (connection->transport,
-						  pid);
+#endif
+    {
+      if (!_dbus_transport_try_to_authenticate (connection->transport))
+        result = FALSE;
+      else
+        result = _dbus_transport_get_unix_process_id (connection->transport,
+                                                      pid);
+    }
 
   CONNECTION_UNLOCK (connection);
 
@@ -6278,7 +6394,6 @@ dbus_connection_get_outgoing_unix_fds (DBusConnection *connection)
   return res;
 }
 
-#ifdef DBUS_ENABLE_EMBEDDED_TESTS
 /**
  * Returns the address of the transport object of this connection
  *
@@ -6290,6 +6405,15 @@ _dbus_connection_get_address (DBusConnection *connection)
 {
   return _dbus_transport_get_address (connection->transport);
 }
+
+#ifdef ENABLE_KDBUS_TRANSPORT
+DBusTransport*
+dbus_connection_get_transport(DBusConnection *connection)
+{
+	_dbus_return_val_if_fail (connection != NULL, NULL);
+
+	return connection->transport;
+}
 #endif
 
 /** @} */
diff --git a/dbus/dbus-connection.h b/dbus/dbus-connection.h
index fe4d04e..b0cbe82 100644
--- a/dbus/dbus-connection.h
+++ b/dbus/dbus-connection.h
@@ -169,6 +169,11 @@ typedef void (* DBusPendingCallNotifyFunction) (DBusPendingCall *pending,
 typedef DBusHandlerResult (* DBusHandleMessageFunction) (DBusConnection     *connection,
                                                          DBusMessage        *message,
                                                          void               *user_data);
+
+DBUS_EXPORT
+DBusMessage *	   generate_local_error_message 				(dbus_uint32_t serial,
+												 char *error_name,
+												 char *error_msg);
 DBUS_EXPORT
 DBusConnection*    dbus_connection_open                         (const char                 *address,
                                                                  DBusError                  *error);
@@ -179,12 +184,20 @@ DBUS_EXPORT
 DBusConnection*    dbus_connection_ref                          (DBusConnection             *connection);
 DBUS_EXPORT
 void               dbus_connection_unref                        (DBusConnection             *connection);
+#ifdef ENABLE_KDBUS_TRANSPORT
+DBUS_EXPORT
+void               dbus_connection_unref_phantom               (DBusConnection             *connection);
+#endif
 DBUS_EXPORT
 void               dbus_connection_close                        (DBusConnection             *connection);
 DBUS_EXPORT
 dbus_bool_t        dbus_connection_get_is_connected             (DBusConnection             *connection);
 DBUS_EXPORT
 dbus_bool_t        dbus_connection_get_is_authenticated         (DBusConnection             *connection);
+#ifdef ENABLE_KDBUS_TRANSPORT
+DBUS_EXPORT
+dbus_bool_t        dbus_connection_set_is_authenticated         (DBusConnection             *connection);
+#endif
 DBUS_EXPORT
 dbus_bool_t        dbus_connection_get_is_anonymous             (DBusConnection             *connection);
 DBUS_EXPORT
@@ -264,6 +277,14 @@ dbus_bool_t        dbus_connection_get_unix_user                (DBusConnection
 DBUS_EXPORT
 dbus_bool_t        dbus_connection_get_unix_process_id          (DBusConnection             *connection,
                                                                  unsigned long              *pid);
+#ifdef ENABLE_KDBUS_TRANSPORT
+DBUS_EXPORT
+dbus_bool_t        dbus_connection_get_unix_user_dbus           (DBusConnection             *connection,
+                                                                 unsigned long              *uid);
+DBUS_EXPORT
+dbus_bool_t        dbus_connection_get_unix_process_id_dbus     (DBusConnection             *connection,
+                                                                 unsigned long              *pid);
+#endif
 DBUS_EXPORT
 dbus_bool_t        dbus_connection_get_adt_audit_session_data   (DBusConnection             *connection,
                                                                  void                      **data,
diff --git a/dbus/dbus-message.c b/dbus/dbus-message.c
index c6953d0..e57b9fd 100644
--- a/dbus/dbus-message.c
+++ b/dbus/dbus-message.c
@@ -34,6 +34,7 @@
 #include "dbus-memory.h"
 #include "dbus-list.h"
 #include "dbus-threads-internal.h"
+
 #ifdef HAVE_UNIX_FD_PASSING
 #include "dbus-sysdeps-unix.h"
 #endif
@@ -395,6 +396,14 @@ dbus_message_lock (DBusMessage  *message)
     }
 }
 
+#ifdef ENABLE_KDBUS_TRANSPORT
+void
+dbus_message_unlock (DBusMessage  *message)
+{
+	message->locked = FALSE;
+}
+#endif
+
 static dbus_bool_t
 set_or_delete_string_field (DBusMessage *message,
                             int          field,
diff --git a/dbus/dbus-message.h b/dbus/dbus-message.h
index 4fd44da..41b0a5d 100644
--- a/dbus/dbus-message.h
+++ b/dbus/dbus-message.h
@@ -266,6 +266,11 @@ void        dbus_message_iter_abandon_container  (DBusMessageIter *iter,
 DBUS_EXPORT
 void dbus_message_lock    (DBusMessage  *message);
 
+#ifdef ENABLE_KDBUS_TRANSPORT
+DBUS_EXPORT
+void dbus_message_unlock  (DBusMessage  *message);
+#endif
+
 DBUS_EXPORT
 dbus_bool_t  dbus_set_error_from_message  (DBusError    *error,
                                            DBusMessage  *message);
diff --git a/dbus/dbus-server.c b/dbus/dbus-server.c
index 19d8590..ba993d1 100644
--- a/dbus/dbus-server.c
+++ b/dbus/dbus-server.c
@@ -183,6 +183,55 @@ _dbus_server_init_base (DBusServer             *server,
   return FALSE;
 }
 
+#ifdef ENABLE_KDBUS_TRANSPORT
+static void mini_vtable_dummy_func(DBusServer *server)
+{
+    // Used to prevent assert errors. Pointer to function is passed to
+    // DBusServerVTable which is passed to server->vtable in
+    // dbus_server_init_mini function.
+}
+
+DBusServer*
+dbus_server_init_mini (char* address)
+{
+	DBusServer *server;
+
+    static const DBusServerVTable dbus_server_init_mini_vtable = {
+        mini_vtable_dummy_func,
+        mini_vtable_dummy_func
+    };
+
+	server = dbus_new0(struct DBusServer, 1);
+	if(server == NULL)
+		return NULL;
+
+	memset(server, 0, sizeof(struct DBusServer));
+	_dbus_rmutex_new_at_location (&server->mutex);
+	if (server->mutex == NULL)
+	    goto failed;
+	server->address = address;
+
+    server->vtable = &dbus_server_init_mini_vtable;
+
+    _dbus_atomic_inc (&server->refcount);
+
+    server->watches = _dbus_watch_list_new ();
+    if (server->watches == NULL)
+        goto failed;
+
+    server->timeouts = _dbus_timeout_list_new();
+    if (server->timeouts == NULL)
+        goto failed;
+
+	return server;
+
+failed:
+	dbus_free(server);
+	return NULL;
+}
+#endif
+
+
 /**
  * Finalizes the members of the DBusServer base class.
  * Chained up to by subclass finalizers.
diff --git a/dbus/dbus-server.h b/dbus/dbus-server.h
index bdbefa0..4266ddc 100644
--- a/dbus/dbus-server.h
+++ b/dbus/dbus-server.h
@@ -48,6 +48,11 @@ typedef void (* DBusNewConnectionFunction) (DBusServer     *server,
                                             DBusConnection *new_connection,
                                             void           *data);
 
+#ifdef ENABLE_KDBUS_TRANSPORT
+DBUS_EXPORT
+DBusServer* dbus_server_init_mini		 (char* address);
+#endif
+
 DBUS_EXPORT
 DBusServer* dbus_server_listen           (const char     *address,
                                           DBusError      *error);
diff --git a/dbus/dbus-transport-kdbus.c b/dbus/dbus-transport-kdbus.c
new file mode 100644
index 0000000..e5e91d8
--- /dev/null
+++ b/dbus/dbus-transport-kdbus.c
@@ -0,0 +1,2034 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+/* dbus-transport-kdbus.c  kdbus subclasses of DBusTransport
+ *
+ * Copyright (C) 2002, 2003, 2004, 2006  Red Hat Inc
+ * Copyright (C) 2013  Samsung Electronics
+ *
+ * Licensed under the Academic Free License version 2.1
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version and under the terms of the GNU
+ * Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+#include "dbus-transport.h"
+#include "dbus-transport-kdbus.h"
+#include "dbus-transport-protected.h"
+#include "dbus-connection-internal.h"
+#include "kdbus.h"
+#include "dbus-watch.h"
+#include "dbus-errors.h"
+#include "dbus-bus.h"
+#include "kdbus-common.h"
+#include <linux/types.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <limits.h>
+#include <sys/stat.h>
+
+/**
+ * @defgroup DBusTransportKdbus DBusTransport implementations for kdbus
+ * @ingroup  DBusInternals
+ * @brief Implementation details of DBusTransport on kdbus
+ *
+ * @{
+ */
+
+/** Size of the memory area for received non-memfd messages. */
+#define RECEIVE_POOL_SIZE (10 * 1024LU * 1024LU)
+
+/** Over this memfd is used to send (if it is not broadcast). */
+#define MEMFD_SIZE_THRESHOLD (2 * 1024 * 1024LU)
+
+/** Define max bytes read or written in one iteration.
+* This is to avoid blocking on reading or writing for too long. It is checked after each message is sent or received,
+* so if message is bigger than MAX_BYTES_PER_ITERATION it will be handled in one iteration, but sending/writing
+* will break after that message.
+**/
+#define MAX_BYTES_PER_ITERATION 16384
+
+#if (MEMFD_SIZE_THRESHOLD > KDBUS_MSG_MAX_PAYLOAD_VEC_SIZE)
+  #error  Memfd size threshold higher than max kdbus message payload vector size
+#endif
+
+/** Enables verbosing more information about kdbus message.
+ *  Works only if DBUS_VERBOSE=1 is used.
+ */
+#define KDBUS_MSG_DECODE_DEBUG 0
+
+#define ITER_APPEND_STR(string) \
+if (!dbus_message_iter_append_basic(&args, DBUS_TYPE_STRING, &string))   \
+{ \
+	ret_size = -1;  \
+	goto out;  \
+}\
+
+#define MSG_ITEM_BUILD_VEC(data, datasize)                                    \
+	item->type = KDBUS_ITEM_PAYLOAD_VEC;					\
+        item->size = KDBUS_ITEM_HEADER_SIZE + sizeof(struct kdbus_vec);		\
+        item->vec.address = (unsigned long) data;       			\
+        item->vec.size = datasize;
+
+#define KDBUS_PART_FOREACH(part, head, first)				\
+	for (part = (head)->first;					\
+	     (uint8_t *)(part) < (uint8_t *)(head) + (head)->size;	\
+	     part = KDBUS_PART_NEXT(part))
+
+/**
+ * Opaque object representing a transport.
+ */
+typedef struct DBusTransportKdbus DBusTransportKdbus;
+
+/**
+ * Implementation details of DBusTransportKdbus. All members are private.
+ */
+struct DBusTransportKdbus
+{
+  DBusTransport base;                   /**< Parent instance */
+  int fd;                               /**< File descriptor. */
+  DBusWatch *read_watch;                /**< Watch for readability. */
+  DBusWatch *write_watch;               /**< Watch for writability. */
+
+  int max_bytes_read_per_iteration;     /**< To avoid blocking too long. */
+  int max_bytes_written_per_iteration;  /**< To avoid blocking too long. */
+
+  void* kdbus_mmap_ptr;	                /**< Mapped memory where kdbus (kernel) writes
+                                         *   messages incoming to us.
+                                         */
+  int memfd;                            /**< File descriptor to special
+                                         *   memory pool for bulk data
+                                         *   transfer. Retrieved from
+                                         *   Kdbus kernel module.
+                                         */
+  __u64 bloom_size;						/**< bloom filter field size */
+  char* sender;                         /**< unique name of the sender */
+};
+
+/**
+ *  Gets size in bytes of bloom filter field.
+ *  This size is got from the bus during connection procedure.
+ *  @param transport transport
+ *  @returns size of bloom
+ */
+__u64 dbus_transport_get_bloom_size(DBusTransport* transport)
+{
+  return ((DBusTransportKdbus*)transport)->bloom_size;
+}
+
+/**
+ *  Gets pointer to the memory pool, wher received messages are
+ *  placed and some ioctls return their info
+ *  @param transport transport
+ *  @returns pointer to the pool
+ */
+void* dbus_transport_get_pool_pointer(DBusTransport* transport)
+{
+  return ((DBusTransportKdbus*)transport)->kdbus_mmap_ptr;
+}
+
+/**
+ * Puts locally generated message into received messages queue
+ * @param message message that will be added
+ * @param connection connection to which message will be added
+ * @returns TRUE on success, FALSE on memory allocation error
+ */
+static dbus_bool_t add_message_to_received(DBusMessage *message, DBusConnection* connection)
+{
+	DBusList *message_link;
+
+	message_link = _dbus_list_alloc_link (message);
+	if (message_link == NULL)
+	{
+		dbus_message_unref (message);
+		return FALSE;
+	}
+
+	_dbus_connection_queue_synthesized_message_link(connection, message_link);
+
+	return TRUE;
+}
+
+/**
+ * Generates local error message as a reply to message given as parameter
+ * and adds generated error message to received messages queue.
+ * @param error_type type of error, preferably DBUS_ERROR_(...)
+ * @param template Template of error description. It can has formatting
+ *  	  characters to print object string into it. Can be NULL.
+ * @param object String to print into error description. Can be NULL.
+ * 		  If object is not NULL while template is NULL, the object string
+ * 		  will be the only error description.
+ * @param message Message for which the error reply is generated.
+ * @param connection The connection.
+ * @returns 0 on success, otherwise -1
+ */
+static int reply_with_error(char* error_type, const char* template, const char* object, DBusMessage *message, DBusConnection* connection)
+{
+	DBusMessage *errMessage;
+	char* error_msg = "";
+
+	if(template)
+	{
+		error_msg = alloca(strlen(template) + strlen(object));
+		sprintf(error_msg, template, object);
+	}
+	else if(object)
+		error_msg = (char*)object;
+
+	errMessage = generate_local_error_message(dbus_message_get_serial(message), error_type, error_msg);
+	if(errMessage == NULL)
+		return -1;
+	if (add_message_to_received(errMessage, connection))
+		return 0;
+
+	return -1;
+}
+
+/**
+ *  Generates reply to the message given as a parameter with one item in the reply body
+ *  and adds generated reply message to received messages queue.
+ *  @param message The message we are replying to.
+ *  @param data_type Type of data sent in the reply.Use DBUS_TYPE_(...)
+ *  @param pData Address of data sent in the reply.
+ *  @param connection The connection
+ *  @returns 0 on success, otherwise -1
+ */
+static int reply_1_data(DBusMessage *message, int data_type, void* pData, DBusConnection* connection)
+{
+	DBusMessageIter args;
+	DBusMessage *reply;
+
+	reply = dbus_message_new_method_return(message);
+	if(reply == NULL)
+		return -1;
+	dbus_message_set_sender(reply, DBUS_SERVICE_DBUS);
+    dbus_message_iter_init_append(reply, &args);
+    if (!dbus_message_iter_append_basic(&args, data_type, pData))
+    {
+    	dbus_message_unref(reply);
+        return -1;
+    }
+    if(add_message_to_received(reply, connection))
+	return 0;
+
+    return -1;
+}
+
+/*
+static int reply_ack(DBusMessage *message, DBusConnection* connection)
+{
+	DBusMessage *reply;
+
+	reply = dbus_message_new_method_return(message);
+	if(reply == NULL)
+		return -1;
+    if(add_message_to_received(reply, connection))
+	return 0;
+    return -1;
+}*/
+
+/**
+ * Retrieves file descriptor to memory pool from kdbus module and stores
+ * it in kdbus_transport->memfd. It is then used to send large message.
+ * Triggered when message payload is over MEMFD_SIZE_THRESHOLD
+ * @param kdbus_transport DBusTransportKdbus transport structure
+ * @returns 0 on success, otherwise -1
+ */
+static int kdbus_init_memfd(DBusTransportKdbus* kdbus_transport)
+{
+	int memfd;
+
+		if (ioctl(kdbus_transport->fd, KDBUS_CMD_MEMFD_NEW, &memfd) < 0) {
+			_dbus_verbose("KDBUS_CMD_MEMFD_NEW failed: \n");
+			return -1;
+		}
+
+		kdbus_transport->memfd = memfd;
+		_dbus_verbose("kdbus_init_memfd: %d!!\n", kdbus_transport->memfd);
+	return 0;
+}
+
+/**
+ * Allocates and initializes kdbus message structure.
+ * @param name Well-known name or NULL. If NULL, dst_id must be supplied.
+ * @param dst_id Numeric id of recipient. Ignored if name is not NULL.
+ * @param body_size Size of message body (May be 0).
+ * @param use_memfd Flag to build memfd message.
+ * @param fds_count Number of file descriptors sent in the message.
+ * @param transport transport
+ * @returns initialized kdbus message or NULL if malloc failed
+ */
+static struct kdbus_msg* kdbus_init_msg(const char* name, __u64 dst_id, uint64_t body_size, dbus_bool_t use_memfd, int fds_count, DBusTransportKdbus *transport)
+{
+    struct kdbus_msg* msg;
+    uint64_t msg_size;
+
+    msg_size = sizeof(struct kdbus_msg);
+
+    if(use_memfd == TRUE)  // bulk data - memfd
+        msg_size += KDBUS_ITEM_SIZE(sizeof(struct kdbus_memfd));
+    else
+      {
+        msg_size += KDBUS_ITEM_SIZE(sizeof(struct kdbus_vec));  //header is a must
+        while(body_size > KDBUS_MSG_MAX_PAYLOAD_VEC_SIZE)
+          {
+            msg_size += KDBUS_ITEM_SIZE(sizeof(struct kdbus_vec));
+            body_size -= KDBUS_MSG_MAX_PAYLOAD_VEC_SIZE;
+          }
+        if(body_size)
+          msg_size += KDBUS_ITEM_SIZE(sizeof(struct kdbus_vec));
+      }
+
+    if(fds_count)
+	msg_size += KDBUS_ITEM_SIZE(sizeof(int)*fds_count);
+
+    if (name)
+	msg_size += KDBUS_ITEM_SIZE(strlen(name) + 1);
+    else if (dst_id == KDBUS_DST_ID_BROADCAST)
+	msg_size += KDBUS_ITEM_HEADER_SIZE + transport->bloom_size;
+
+    msg = malloc(msg_size);
+    if (!msg)
+    {
+	_dbus_verbose("Error allocating memory for: %s,%s\n", _dbus_strerror (errno), _dbus_error_from_errno (errno));
+		return NULL;
+    }
+
+    memset(msg, 0, msg_size);
+    msg->size = msg_size;
+    msg->payload_type = KDBUS_PAYLOAD_DBUS;
+    msg->dst_id = name ? 0 : dst_id;
+    msg->src_id = strtoull(dbus_bus_get_unique_name(transport->base.connection), NULL , 10);
+
+    return msg;
+}
+
+/**
+ * Sends DBus message using kdbus.
+ * Handles broadcasts and unicast messages, and passing of Unix fds.
+ * Also can locally generate error replies on some error returned by kernel.
+ *
+ * TODO refactor to be more compact - maybe we can send header always as a payload vector
+ *  and only message body as memfd if needed.
+ *
+ * @param transport Transport.
+ * @param message DBus message to be sent
+ * @param destination Destination of the message.
+ * @returns bytes sent or -1 if sending failed
+ */
+static int kdbus_write_msg(DBusTransportKdbus *transport, DBusMessage *message, const char* destination)
+{
+  struct kdbus_msg *msg = NULL;
+  struct kdbus_item *item;
+  uint64_t dst_id = KDBUS_DST_ID_BROADCAST;
+  const DBusString *header;
+  const DBusString *body;
+  uint64_t ret_size = 0;
+  uint64_t body_size = 0;
+  uint64_t header_size = 0;
+  dbus_bool_t use_memfd = FALSE;
+  const int *unix_fds;
+  unsigned fds_count;
+  dbus_bool_t autostart;
+
+  // determine destination and destination id
+  if(destination)
+    {
+      dst_id = KDBUS_DST_ID_NAME;
+      if((destination[0] == ':') && (destination[1] == '1') && (destination[2] == '.'))  /* if name starts with ":1." it is a unique name and should be send as number */
+        {
+          errno = 0;
+          dst_id = strtoull(&destination[3], NULL, 10);
+          if(errno)
+          {
+            _dbus_verbose("error: unique name is not a number: %s (%m)\n", destination);
+            ret_size = -1;
+            goto out;
+          }
+          destination = NULL;
+        }
+    }
+
+  _dbus_message_get_network_data (message, &header, &body);
+  header_size = _dbus_string_get_length(header);
+  body_size = _dbus_string_get_length(body);
+  ret_size = header_size + body_size;
+
+  // check whether we can and should use memfd
+  if((dst_id != KDBUS_DST_ID_BROADCAST) && (ret_size > MEMFD_SIZE_THRESHOLD))
+    {
+      if(kdbus_init_memfd(transport) == 0)
+        {
+          use_memfd = TRUE;
+        }
+    }
+
+  _dbus_message_get_unix_fds(message, &unix_fds, &fds_count);
+
+  // init basic message fields
+  msg = kdbus_init_msg(destination, dst_id, body_size, use_memfd, fds_count, transport);
+  if(msg == NULL)
+    {
+      _dbus_verbose("Can't alloc memory for new message\n");
+      ret_size = -1;
+      goto out;
+    }
+  msg->cookie = dbus_message_get_serial(message);
+  autostart = dbus_message_get_auto_start (message);
+  if(!autostart)
+    msg->flags |= KDBUS_MSG_FLAGS_NO_AUTO_START;
+
+  // build message contents
+  item = msg->items;
+
+  if(use_memfd == TRUE)
+    {
+      char *buf;
+
+      if(ioctl(transport->memfd, KDBUS_CMD_MEMFD_SEAL_SET, 0) < 0)
+        {
+          _dbus_verbose("memfd sealing failed: \n");
+          ret_size = -1;
+          goto out;
+        }
+
+      buf = mmap(NULL, ret_size, PROT_WRITE, MAP_SHARED, transport->memfd, 0);
+      if (buf == MAP_FAILED)
+        {
+          _dbus_verbose("mmap() fd=%i failed:%m", transport->memfd);
+          ret_size = -1;
+          goto out;
+        }
+
+      memcpy(buf, _dbus_string_get_const_data(header), header_size);
+      if(body_size) {
+          buf+=header_size;
+          memcpy(buf, _dbus_string_get_const_data(body),  body_size);
+          buf-=header_size;
+      }
+
+      munmap(buf, ret_size);
+
+      // seal data - kdbus module needs it
+      if(ioctl(transport->memfd, KDBUS_CMD_MEMFD_SEAL_SET, 1) < 0) {
+          _dbus_verbose("memfd sealing failed: %d (%m)\n", errno);
+          ret_size = -1;
+          goto out;
+      }
+
+      item->type = KDBUS_ITEM_PAYLOAD_MEMFD;
+      item->size = KDBUS_ITEM_HEADER_SIZE + sizeof(struct kdbus_memfd);
+      item->memfd.size = ret_size;
+      item->memfd.fd = transport->memfd;
+    }
+  else
+    {
+      _dbus_verbose("sending normal vector data\n");
+      MSG_ITEM_BUILD_VEC(_dbus_string_get_const_data(header), header_size);
+
+      if(body_size)
+        {
+          const char* body_data;
+
+          body_data = _dbus_string_get_const_data(body);
+          while(body_size > KDBUS_MSG_MAX_PAYLOAD_VEC_SIZE)
+            {
+              _dbus_verbose("body attaching\n");
+              item = KDBUS_PART_NEXT(item);
+              MSG_ITEM_BUILD_VEC(body_data, KDBUS_MSG_MAX_PAYLOAD_VEC_SIZE);
+              body_data += KDBUS_MSG_MAX_PAYLOAD_VEC_SIZE;
+              body_size -= KDBUS_MSG_MAX_PAYLOAD_VEC_SIZE;
+            }
+          if(body_size)
+            {
+              _dbus_verbose("body attaching\n");
+              item = KDBUS_PART_NEXT(item);
+              MSG_ITEM_BUILD_VEC(body_data, body_size);
+            }
+        }
+    }
+
+  if(fds_count)
+    {
+      item = KDBUS_PART_NEXT(item);
+      item->type = KDBUS_ITEM_FDS;
+      item->size = KDBUS_ITEM_HEADER_SIZE + (sizeof(int) * fds_count);
+      memcpy(item->fds, unix_fds, sizeof(int) * fds_count);
+    }
+
+  if (destination)
+    {
+      item = KDBUS_PART_NEXT(item);
+      item->type = KDBUS_ITEM_DST_NAME;
+      item->size = KDBUS_ITEM_HEADER_SIZE + strlen(destination) + 1;
+      memcpy(item->str, destination, item->size - KDBUS_ITEM_HEADER_SIZE);
+    }
+  else if (dst_id == KDBUS_DST_ID_BROADCAST)
+    {
+      item = KDBUS_PART_NEXT(item);
+      item->type = KDBUS_ITEM_BLOOM;
+      item->size = KDBUS_ITEM_HEADER_SIZE + transport->bloom_size;
+      strncpy(item->data, dbus_message_get_interface(message), transport->bloom_size);
+    }
+
+  again:
+  if (ioctl(transport->fd, KDBUS_CMD_MSG_SEND, msg))
+    {
+      if(errno == EINTR)
+        goto again;
+      else if(errno == ENXIO) //no such id on the bus
+        {
+          ret_size = 0;
+          if(!reply_with_error(DBUS_ERROR_NAME_HAS_NO_OWNER, "Name \"%s\" does not exist", dbus_message_get_destination(message), message, transport->base.connection))
+              goto out;
+
+        }
+      else if((errno == ESRCH) || (errno = EADDRNOTAVAIL))  //when well known name is not available on the bus
+        {
+          ret_size = 0;
+          if(autostart)
+            {
+              if(!reply_with_error(DBUS_ERROR_SERVICE_UNKNOWN, "The name %s was not provided by any .service files", dbus_message_get_destination(message), message, transport->base.connection))
+                  goto out;
+            }
+          else
+            if(!reply_with_error(DBUS_ERROR_NAME_HAS_NO_OWNER, "Name \"%s\" does not exist", dbus_message_get_destination(message), message, transport->base.connection))
+                goto out;
+        }
+      else
+        ret_size = -1;
+      _dbus_verbose("kdbus error sending message: err %d (%m)\n", errno);
+    }
+  out:
+  if(msg)
+    free(msg);
+  if(use_memfd)
+    close(transport->memfd);
+
+  return ret_size;
+}
+
+/**
+ * Performs kdbus hello - registration on the kdbus bus
+ * needed to send and receive messages on the bus,
+ * and configures transport.
+ * As a result unique id on he bus is obtained.
+ *
+ * @param name place to print id given by bus
+ * @param transportS transport structure
+ * @returns #TRUE on success
+ */
+static dbus_bool_t bus_register_kdbus(char* name, DBusTransportKdbus* transportS)
+{
+	struct kdbus_cmd_hello __attribute__ ((__aligned__(8))) hello;
+	memset(&hello, 0, sizeof(hello));
+
+	hello.conn_flags = KDBUS_HELLO_ACCEPT_FD/* |
+			   KDBUS_HELLO_ATTACH_COMM |
+			   KDBUS_HELLO_ATTACH_EXE |
+			   KDBUS_HELLO_ATTACH_CMDLINE |
+			   KDBUS_HELLO_ATTACH_CAPS |
+			   KDBUS_HELLO_ATTACH_CGROUP |
+			   KDBUS_HELLO_ATTACH_SECLABEL |
+			   KDBUS_HELLO_ATTACH_AUDIT*/;
+	hello.size = sizeof(struct kdbus_cmd_hello);
+	hello.pool_size = RECEIVE_POOL_SIZE;
+
+	if (ioctl(transportS->fd, KDBUS_CMD_HELLO, &hello))
+	{
+		_dbus_verbose ("Failed to send hello: %m, %d",errno);
+		return FALSE;
+	}
+
+	sprintf(name, "%llu", (unsigned long long)hello.id);
+	_dbus_verbose("-- Our peer ID is: %s\n", name);
+	transportS->bloom_size = hello.bloom_size;
+
+	transportS->kdbus_mmap_ptr = mmap(NULL, RECEIVE_POOL_SIZE, PROT_READ, MAP_SHARED, transportS->fd, 0);
+	if (transportS->kdbus_mmap_ptr == MAP_FAILED)
+	{
+		_dbus_verbose("Error when mmap: %m, %d",errno);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+/**
+ * Looks over messages sent to org.freedesktop.DBus. Hello message, which performs
+ * registration on the bus, is captured as it must be locally converted into
+ * appropriate ioctl. All the rest org.freedesktop.DBus methods are left untouched
+ * and they are sent to dbus-daemon in the same way as every other messages.
+ *
+ * @param transport Transport
+ * @param message Message being sent.
+ * @returns 1 if it is not Hello message and it should be passed to daemon
+ * 			0 if Hello message was handled correctly,
+ * 			-1 if Hello message was not handle correctly.
+ */
+static int capture_hello_message(DBusTransport *transport, const char* destination, DBusMessage *message)
+{
+  if(!strcmp(destination, DBUS_SERVICE_DBUS))
+    {
+      if(!strcmp(dbus_message_get_interface(message), DBUS_INTERFACE_DBUS))
+        {
+          if(!strcmp(dbus_message_get_member(message), "Hello"))
+            {
+              char* name = NULL;
+
+              name = malloc(snprintf(name, 0, ":1.%llu0", ULLONG_MAX));
+              if(name == NULL)
+                return -1;
+              strcpy(name, ":1.");
+              if(!bus_register_kdbus(&name[3], (DBusTransportKdbus*)transport))
+                goto out;
+#ifdef POLICY_TO_KDBUS
+              if(!register_kdbus_policy(&name[3], transport, geteuid()))
+                goto out;
+#endif
+              ((DBusTransportKdbus*)transport)->sender = name;
+
+              if(!reply_1_data(message, DBUS_TYPE_STRING, &name, transport->connection))
+                return 0;  //on success we can not free name
+
+              out:
+              free(name);
+              return -1;
+            }
+        }
+    }
+
+  return 1;  //send message to daemon
+}
+
+#if KDBUS_MSG_DECODE_DEBUG == 1
+static char *msg_id(uint64_t id, char *buf)
+{
+	if (id == 0)
+		return "KERNEL";
+	if (id == ~0ULL)
+		return "BROADCAST";
+	sprintf(buf, "%llu", (unsigned long long)id);
+	return buf;
+}
+#endif
+struct kdbus_enum_table {
+	long long id;
+	const char *name;
+};
+#define _STRINGIFY(x) #x
+#define STRINGIFY(x) _STRINGIFY(x)
+#define ELEMENTSOF(x) (sizeof(x)/sizeof((x)[0]))
+#define TABLE(what) static struct kdbus_enum_table kdbus_table_##what[]
+#define ENUM(_id) { .id=_id, .name=STRINGIFY(_id) }
+#define LOOKUP(what)								\
+	const char *enum_##what(long long id) {					\
+	size_t i; \
+		for (i = 0; i < ELEMENTSOF(kdbus_table_##what); i++)	\
+			if (id == kdbus_table_##what[i].id)			\
+				return kdbus_table_##what[i].name;		\
+		return "UNKNOWN";						\
+	}
+const char *enum_MSG(long long id);
+TABLE(MSG) = {
+	ENUM(_KDBUS_ITEM_NULL),
+	ENUM(KDBUS_ITEM_PAYLOAD_VEC),
+	ENUM(KDBUS_ITEM_PAYLOAD_OFF),
+	ENUM(KDBUS_ITEM_PAYLOAD_MEMFD),
+	ENUM(KDBUS_ITEM_FDS),
+	ENUM(KDBUS_ITEM_BLOOM),
+	ENUM(KDBUS_ITEM_DST_NAME),
+	ENUM(KDBUS_ITEM_CREDS),
+	ENUM(KDBUS_ITEM_PID_COMM),
+	ENUM(KDBUS_ITEM_TID_COMM),
+	ENUM(KDBUS_ITEM_EXE),
+	ENUM(KDBUS_ITEM_CMDLINE),
+	ENUM(KDBUS_ITEM_CGROUP),
+	ENUM(KDBUS_ITEM_CAPS),
+	ENUM(KDBUS_ITEM_SECLABEL),
+	ENUM(KDBUS_ITEM_AUDIT),
+	ENUM(KDBUS_ITEM_NAME),
+	ENUM(KDBUS_ITEM_TIMESTAMP),
+	ENUM(KDBUS_ITEM_NAME_ADD),
+	ENUM(KDBUS_ITEM_NAME_REMOVE),
+	ENUM(KDBUS_ITEM_NAME_CHANGE),
+	ENUM(KDBUS_ITEM_ID_ADD),
+	ENUM(KDBUS_ITEM_ID_REMOVE),
+	ENUM(KDBUS_ITEM_REPLY_TIMEOUT),
+	ENUM(KDBUS_ITEM_REPLY_DEAD),
+};
+LOOKUP(MSG);
+const char *enum_PAYLOAD(long long id);
+TABLE(PAYLOAD) = {
+	ENUM(KDBUS_PAYLOAD_KERNEL),
+	ENUM(KDBUS_PAYLOAD_DBUS),
+};
+LOOKUP(PAYLOAD);
+
+/**
+ * Finalizes locally generated DBus message
+ * and puts it into data buffer.
+ *
+ * @param message Message to load.
+ * @param data Place to load message.
+ * @returns Size of message loaded.
+ */
+static int put_message_into_data(DBusMessage *message, char* data)
+{
+	int ret_size;
+    const DBusString *header;
+    const DBusString *body;
+    int size;
+
+    dbus_message_set_serial(message, 1);
+    dbus_message_lock (message);
+    _dbus_message_get_network_data (message, &header, &body);
+    ret_size = _dbus_string_get_length(header);
+	memcpy(data, _dbus_string_get_const_data(header), ret_size);
+	data += ret_size;
+	size = _dbus_string_get_length(body);
+	memcpy(data, _dbus_string_get_const_data(body), size);
+	ret_size += size;
+
+	return ret_size;
+}
+
+/**
+ * Calculates length of the kdbus message content (payload).
+ *
+ * @param msg kdbus message
+ * @return the length of the kdbus message's payload.
+ */
+static int kdbus_message_size(const struct kdbus_msg* msg)
+{
+	const struct kdbus_item *item;
+	int ret_size = 0;
+
+	KDBUS_PART_FOREACH(item, msg, items)
+	{
+		if (item->size < KDBUS_ITEM_HEADER_SIZE)
+		{
+			_dbus_verbose("  +%s (%llu bytes) invalid data record\n", enum_MSG(item->type), item->size);
+			return -1;
+		}
+		switch (item->type)
+		{
+			case KDBUS_ITEM_PAYLOAD_OFF:
+				ret_size += item->vec.size;
+				break;
+			case KDBUS_ITEM_PAYLOAD_MEMFD:
+				ret_size += item->memfd.size;
+				break;
+			default:
+				break;
+		}
+	}
+
+	return ret_size;
+}
+
+/**
+ * Decodes kdbus message in order to extract DBus message and puts it into received data buffer
+ * and file descriptor's buffer. Also captures kdbus error messages and kdbus kernel broadcasts
+ * and converts all of them into appropriate DBus messages.
+ *
+ * @param msg kdbus message
+ * @param data place to copy DBus message to
+ * @param kdbus_transport transport
+ * @param fds place to store file descriptors received
+ * @param n_fds place to store quantity of file descriptors received
+ * @return number of DBus message's bytes received or -1 on error
+ */
+static int kdbus_decode_msg(const struct kdbus_msg* msg, char *data, DBusTransportKdbus* kdbus_transport, int* fds, int* n_fds)
+{
+	const struct kdbus_item *item;
+	int ret_size = 0;
+	DBusMessage *message = NULL;
+	DBusMessageIter args;
+	const char* emptyString = "";
+	const char* pString = NULL;
+	char dbus_name[128];
+	const char* pDBusName = dbus_name;
+#if KDBUS_MSG_DECODE_DEBUG == 1
+	char buf[32];
+#endif
+
+#if KDBUS_MSG_DECODE_DEBUG == 1
+	_dbus_verbose("MESSAGE: %s (%llu bytes) flags=0x%llx, %s → %s, cookie=%llu, timeout=%llu\n",
+		enum_PAYLOAD(msg->payload_type), (unsigned long long) msg->size,
+		(unsigned long long) msg->flags,
+		msg_id(msg->src_id, buf), msg_id(msg->dst_id, buf),
+		(unsigned long long) msg->cookie, (unsigned long long) msg->timeout_ns);
+#endif
+
+	*n_fds = 0;
+
+	KDBUS_PART_FOREACH(item, msg, items)
+	{
+		if (item->size < KDBUS_ITEM_HEADER_SIZE)
+		{
+			_dbus_verbose("  +%s (%llu bytes) invalid data record\n", enum_MSG(item->type), item->size);
+			ret_size = -1;
+			break;
+		}
+
+		switch (item->type)
+		{
+			case KDBUS_ITEM_PAYLOAD_OFF:
+				memcpy(data, (char *)kdbus_transport->kdbus_mmap_ptr + item->vec.offset, item->vec.size);
+				data += item->vec.size;
+				ret_size += item->vec.size;
+
+				_dbus_verbose("  +%s (%llu bytes) off=%llu size=%llu\n",
+					enum_MSG(item->type), item->size,
+					(unsigned long long)item->vec.offset,
+					(unsigned long long)item->vec.size);
+			break;
+
+			case KDBUS_ITEM_PAYLOAD_MEMFD:
+			{
+				char *buf;
+				uint64_t size;
+
+				size = item->memfd.size;
+				_dbus_verbose("memfd.size : %llu\n", (unsigned long long)size);
+
+				buf = mmap(NULL, size, PROT_READ , MAP_SHARED, item->memfd.fd, 0);
+				if (buf == MAP_FAILED)
+				{
+					_dbus_verbose("mmap() fd=%i failed:%m", item->memfd.fd);
+					return -1;
+				}
+
+				memcpy(data, buf, size);
+				data += size;
+				ret_size += size;
+
+				munmap(buf, size);
+
+                _dbus_verbose("  +%s (%llu bytes) off=%llu size=%llu\n",
+					   enum_MSG(item->type), item->size,
+					   (unsigned long long)item->vec.offset,
+					   (unsigned long long)item->vec.size);
+			break;
+			}
+
+			case KDBUS_ITEM_FDS:
+			{
+				int i;
+
+				*n_fds = (item->size - KDBUS_ITEM_HEADER_SIZE) / sizeof(int);
+				memcpy(fds, item->fds, *n_fds * sizeof(int));
+	            for (i = 0; i < *n_fds; i++)
+	              _dbus_fd_set_close_on_exec(fds[i]);
+			break;
+			}
+
+#if KDBUS_MSG_DECODE_DEBUG == 1
+			case KDBUS_ITEM_CREDS:
+				_dbus_verbose("  +%s (%llu bytes) uid=%lld, gid=%lld, pid=%lld, tid=%lld, starttime=%lld\n",
+					enum_MSG(item->type), item->size,
+					item->creds.uid, item->creds.gid,
+					item->creds.pid, item->creds.tid,
+					item->creds.starttime);
+			break;
+
+			case KDBUS_ITEM_PID_COMM:
+			case KDBUS_ITEM_TID_COMM:
+			case KDBUS_ITEM_EXE:
+			case KDBUS_ITEM_CGROUP:
+			case KDBUS_ITEM_SECLABEL:
+			case KDBUS_ITEM_DST_NAME:
+				_dbus_verbose("  +%s (%llu bytes) '%s' (%zu)\n",
+					   enum_MSG(item->type), item->size, item->str, strlen(item->str));
+				break;
+
+			case KDBUS_ITEM_CMDLINE:
+			case KDBUS_ITEM_NAME: {
+				__u64 size = item->size - KDBUS_ITEM_HEADER_SIZE;
+				const char *str = item->str;
+				int count = 0;
+
+				_dbus_verbose("  +%s (%llu bytes) ", enum_MSG(item->type), item->size);
+				while (size) {
+					_dbus_verbose("'%s' ", str);
+					size -= strlen(str) + 1;
+					str += strlen(str) + 1;
+					count++;
+				}
+
+				_dbus_verbose("(%d string%s)\n", count, (count == 1) ? "" : "s");
+				break;
+			}
+
+			case KDBUS_ITEM_AUDIT:
+				_dbus_verbose("  +%s (%llu bytes) loginuid=%llu sessionid=%llu\n",
+					   enum_MSG(item->type), item->size,
+					   (unsigned long long)item->data64[0],
+					   (unsigned long long)item->data64[1]);
+				break;
+
+			case KDBUS_ITEM_CAPS: {
+				int n;
+				const uint32_t *cap;
+				int i;
+
+				_dbus_verbose("  +%s (%llu bytes) len=%llu bytes)\n",
+					   enum_MSG(item->type), item->size,
+					   (unsigned long long)item->size - KDBUS_ITEM_HEADER_SIZE);
+
+				cap = item->data32;
+				n = (item->size - KDBUS_ITEM_HEADER_SIZE) / 4 / sizeof(uint32_t);
+
+				_dbus_verbose("    CapInh=");
+				for (i = 0; i < n; i++)
+					_dbus_verbose("%08x", cap[(0 * n) + (n - i - 1)]);
+
+				_dbus_verbose(" CapPrm=");
+				for (i = 0; i < n; i++)
+					_dbus_verbose("%08x", cap[(1 * n) + (n - i - 1)]);
+
+				_dbus_verbose(" CapEff=");
+				for (i = 0; i < n; i++)
+					_dbus_verbose("%08x", cap[(2 * n) + (n - i - 1)]);
+
+				_dbus_verbose(" CapInh=");
+				for (i = 0; i < n; i++)
+					_dbus_verbose("%08x", cap[(3 * n) + (n - i - 1)]);
+				_dbus_verbose("\n");
+				break;
+			}
+
+			case KDBUS_ITEM_TIMESTAMP:
+				_dbus_verbose("  +%s (%llu bytes) realtime=%lluns monotonic=%lluns\n",
+					   enum_MSG(item->type), item->size,
+					   (unsigned long long)item->timestamp.realtime_ns,
+					   (unsigned long long)item->timestamp.monotonic_ns);
+				break;
+#endif
+
+			case KDBUS_ITEM_REPLY_TIMEOUT:
+				_dbus_verbose("  +%s (%llu bytes) cookie=%llu\n",
+					   enum_MSG(item->type), item->size, msg->cookie_reply);
+
+				message = generate_local_error_message(msg->cookie_reply, DBUS_ERROR_NO_REPLY, NULL);
+				if(message == NULL)
+				{
+					ret_size = -1;
+					goto out;
+				}
+
+				ret_size = put_message_into_data(message, data);
+			break;
+
+			case KDBUS_ITEM_REPLY_DEAD:
+				_dbus_verbose("  +%s (%llu bytes) cookie=%llu\n",
+					   enum_MSG(item->type), item->size, msg->cookie_reply);
+
+				message = generate_local_error_message(msg->cookie_reply, DBUS_ERROR_NAME_HAS_NO_OWNER, NULL);
+				if(message == NULL)
+				{
+					ret_size = -1;
+					goto out;
+				}
+
+				ret_size = put_message_into_data(message, data);
+			break;
+
+			case KDBUS_ITEM_NAME_ADD:
+				_dbus_verbose("  +%s (%llu bytes) '%s', old id=%lld, new id=%lld, old flags=0x%llx, new flags=0x%llx\n",
+					enum_MSG(item->type), (unsigned long long) item->size,
+					item->name_change.name, item->name_change.old_id,
+					item->name_change.new_id, item->name_change.old_flags,
+					item->name_change.new_flags);
+
+				message = dbus_message_new_signal(DBUS_PATH_DBUS, DBUS_INTERFACE_DBUS, "NameOwnerChanged");
+				if(message == NULL)
+				{
+					ret_size = -1;
+					goto out;
+				}
+
+				sprintf(dbus_name,":1.%llu",item->name_change.new_id);
+				pString = item->name_change.name;
+				_dbus_verbose ("Name added: %s\n", pString);
+			    dbus_message_iter_init_append(message, &args);
+			    ITER_APPEND_STR(pString)
+			    ITER_APPEND_STR(emptyString)
+			    ITER_APPEND_STR(pDBusName)
+				dbus_message_set_sender(message, DBUS_SERVICE_DBUS);
+
+				ret_size = put_message_into_data(message, data);
+			break;
+
+			case KDBUS_ITEM_NAME_REMOVE:
+				_dbus_verbose("  +%s (%llu bytes) '%s', old id=%lld, new id=%lld, old flags=0x%llx, new flags=0x%llx\n",
+					enum_MSG(item->type), (unsigned long long) item->size,
+					item->name_change.name, item->name_change.old_id,
+					item->name_change.new_id, item->name_change.old_flags,
+					item->name_change.new_flags);
+
+				message = dbus_message_new_signal(DBUS_PATH_DBUS, DBUS_INTERFACE_DBUS, "NameOwnerChanged"); // name of the signal
+				if(message == NULL)
+				{
+					ret_size = -1;
+					goto out;
+				}
+
+				sprintf(dbus_name,":1.%llu",item->name_change.old_id);
+				pString = item->name_change.name;
+				_dbus_verbose ("Name removed: %s\n", pString);
+			    dbus_message_iter_init_append(message, &args);
+			    ITER_APPEND_STR(pString)
+			    ITER_APPEND_STR(pDBusName)
+			    ITER_APPEND_STR(emptyString)
+				dbus_message_set_sender(message, DBUS_SERVICE_DBUS);
+
+				ret_size = put_message_into_data(message, data);
+			break;
+
+			case KDBUS_ITEM_NAME_CHANGE:
+				_dbus_verbose("  +%s (%llu bytes) '%s', old id=%lld, new id=%lld, old flags=0x%llx, new flags=0x%llx\n",
+					enum_MSG(item->type), (unsigned long long) item->size,
+					item->name_change.name, item->name_change.old_id,
+					item->name_change.new_id, item->name_change.old_flags,
+					item->name_change.new_flags);
+
+				message = dbus_message_new_signal(DBUS_PATH_DBUS, DBUS_INTERFACE_DBUS, "NameOwnerChanged");
+				if(message == NULL)
+				{
+					ret_size = -1;
+					goto out;
+				}
+
+				sprintf(dbus_name,":1.%llu",item->name_change.old_id);
+				pString = item->name_change.name;
+				_dbus_verbose ("Name changed: %s\n", pString);
+			    dbus_message_iter_init_append(message, &args);
+			    ITER_APPEND_STR(pString)
+			    ITER_APPEND_STR(pDBusName)
+			    sprintf(&dbus_name[3],"%llu",item->name_change.new_id);
+			    _dbus_verbose ("New id: %s\n", pDBusName);
+			    ITER_APPEND_STR(pDBusName)
+				dbus_message_set_sender(message, DBUS_SERVICE_DBUS);
+
+				ret_size = put_message_into_data(message, data);
+			break;
+
+			case KDBUS_ITEM_ID_ADD:
+				_dbus_verbose("  +%s (%llu bytes) id=%llu flags=%llu\n",
+					   enum_MSG(item->type), (unsigned long long) item->size,
+					   (unsigned long long) item->id_change.id,
+					   (unsigned long long) item->id_change.flags);
+
+				message = dbus_message_new_signal(DBUS_PATH_DBUS, DBUS_INTERFACE_DBUS, "NameOwnerChanged");
+				if(message == NULL)
+				{
+					ret_size = -1;
+					goto out;
+				}
+
+				sprintf(dbus_name,":1.%llu",item->id_change.id);
+			    dbus_message_iter_init_append(message, &args);
+			    ITER_APPEND_STR(pDBusName)
+			    ITER_APPEND_STR(emptyString)
+			    ITER_APPEND_STR(pDBusName)
+				dbus_message_set_sender(message, DBUS_SERVICE_DBUS);
+
+				ret_size = put_message_into_data(message, data);
+			break;
+
+			case KDBUS_ITEM_ID_REMOVE:
+				_dbus_verbose("  +%s (%llu bytes) id=%llu flags=%llu\n",
+					   enum_MSG(item->type), (unsigned long long) item->size,
+					   (unsigned long long) item->id_change.id,
+					   (unsigned long long) item->id_change.flags);
+
+				message = dbus_message_new_signal(DBUS_PATH_DBUS, DBUS_INTERFACE_DBUS, "NameOwnerChanged");
+				if(message == NULL)
+				{
+					ret_size = -1;
+					goto out;
+				}
+
+				sprintf(dbus_name,":1.%llu",item->id_change.id);
+			    dbus_message_iter_init_append(message, &args);
+			    ITER_APPEND_STR(pDBusName)
+			    ITER_APPEND_STR(pDBusName)
+			    ITER_APPEND_STR(emptyString)
+				dbus_message_set_sender(message, DBUS_SERVICE_DBUS);
+
+				ret_size = put_message_into_data(message, data);
+			break;
+#if KDBUS_MSG_DECODE_DEBUG == 1
+			default:
+				_dbus_verbose("  +%s (%llu bytes)\n", enum_MSG(item->type), item->size);
+			break;
+#endif
+		}
+	}
+
+#if KDBUS_MSG_DECODE_DEBUG == 1
+
+	if ((char *)item - ((char *)msg + msg->size) >= 8)
+		_dbus_verbose("invalid padding at end of message\n");
+#endif
+
+out:
+	if(message)
+		dbus_message_unref(message);
+	return ret_size;
+}
+
+/**
+ * Reads message from kdbus and puts it into DBus buffers
+ *
+ * @param kdbus_transport transport
+ * @param buffer place to copy received message to
+ * @param fds place to store file descriptors received with the message
+ * @param n_fds place to store quantity of file descriptors received
+ * @return size of received message on success, -1 on error
+ */
+static int kdbus_read_message(DBusTransportKdbus *kdbus_transport, DBusString *buffer, int* fds, int* n_fds)
+{
+	int ret_size, buf_size;
+	uint64_t __attribute__ ((__aligned__(8))) offset;
+	struct kdbus_msg *msg;
+	char *data;
+	int start;
+
+	start = _dbus_string_get_length (buffer);
+
+	again:
+	if (ioctl(kdbus_transport->fd, KDBUS_CMD_MSG_RECV, &offset) < 0)
+	{
+		if(errno == EINTR)
+			goto again;
+		_dbus_verbose("kdbus error receiving message: %d (%m)\n", errno);
+		_dbus_string_set_length (buffer, start);
+		return -1;
+	}
+
+	msg = (struct kdbus_msg *)((char*)kdbus_transport->kdbus_mmap_ptr + offset);
+
+	buf_size = kdbus_message_size(msg);
+	if (buf_size == -1)
+	{
+		_dbus_verbose("kdbus error - too short message: %d (%m)\n", errno);
+		return -1;
+	}
+
+	/* What is the maximum size of the locally generated message?
+	   I just assume 2048 bytes */
+	buf_size = MAX(buf_size, 2048);
+
+	if (!_dbus_string_lengthen (buffer, buf_size))
+	{
+		errno = ENOMEM;
+		return -1;
+	}
+	data = _dbus_string_get_data_len (buffer, start, buf_size);
+
+	ret_size = kdbus_decode_msg(msg, data, kdbus_transport, fds, n_fds);
+
+	if(ret_size == -1) /* error */
+	{
+		_dbus_string_set_length (buffer, start);
+		return -1;
+	}
+	else if (buf_size != ret_size) /* case of locally generated message */
+	{
+		_dbus_string_set_length (buffer, start + ret_size);
+	}
+
+	again2:
+	if (ioctl(kdbus_transport->fd, KDBUS_CMD_FREE, &offset) < 0)
+	{
+		if(errno == EINTR)
+			goto again2;
+		_dbus_verbose("kdbus error freeing message: %d (%m)\n", errno);
+		return -1;
+	}
+
+	return ret_size;
+}
+
+/**
+ * Copy-paste from socket transport. Only renames done.
+ */
+static void
+free_watches (DBusTransport *transport)
+{
+  DBusTransportKdbus *kdbus_transport = (DBusTransportKdbus*) transport;
+
+  _dbus_verbose ("start\n");
+
+  if (kdbus_transport->read_watch)
+    {
+      if (transport->connection)
+        _dbus_connection_remove_watch_unlocked (transport->connection,
+                                                kdbus_transport->read_watch);
+      _dbus_watch_invalidate (kdbus_transport->read_watch);
+      _dbus_watch_unref (kdbus_transport->read_watch);
+      kdbus_transport->read_watch = NULL;
+    }
+
+  if (kdbus_transport->write_watch)
+    {
+      if (transport->connection)
+        _dbus_connection_remove_watch_unlocked (transport->connection,
+                                                kdbus_transport->write_watch);
+      _dbus_watch_invalidate (kdbus_transport->write_watch);
+      _dbus_watch_unref (kdbus_transport->write_watch);
+      kdbus_transport->write_watch = NULL;
+    }
+
+  _dbus_verbose ("end\n");
+}
+
+/**
+ * Copy-paste from socket transport. Only done needed renames and removed
+ * lines related to encoded messages.
+ */
+static void
+transport_finalize (DBusTransport *transport)
+{
+  _dbus_verbose ("\n");
+
+  free_watches (transport);
+
+  _dbus_transport_finalize_base (transport);
+
+  _dbus_assert (((DBusTransportKdbus*) transport)->read_watch == NULL);
+  _dbus_assert (((DBusTransportKdbus*) transport)->write_watch == NULL);
+
+  dbus_free (transport);
+}
+
+/**
+ * Copy-paste from socket transport. Removed code related to authentication,
+ * socket_transport replaced by kdbus_transport.
+ */
+static void
+check_write_watch (DBusTransport *transport)
+{
+  DBusTransportKdbus *kdbus_transport = (DBusTransportKdbus*) transport;
+  dbus_bool_t needed;
+
+  if (transport->connection == NULL)
+    return;
+
+  if (transport->disconnected)
+    {
+      _dbus_assert (kdbus_transport->write_watch == NULL);
+      return;
+    }
+
+  _dbus_transport_ref (transport);
+
+  needed = _dbus_connection_has_messages_to_send_unlocked (transport->connection);
+
+  _dbus_verbose ("check_write_watch(): needed = %d on connection %p watch %p fd = %d outgoing messages exist %d\n",
+                 needed, transport->connection, kdbus_transport->write_watch,
+                 kdbus_transport->fd,
+                 _dbus_connection_has_messages_to_send_unlocked (transport->connection));
+
+  _dbus_connection_toggle_watch_unlocked (transport->connection,
+                                          kdbus_transport->write_watch,
+                                          needed);
+
+  _dbus_transport_unref (transport);
+}
+
+/**
+ * Copy-paste from socket transport. Removed code related to authentication,
+ * socket_transport replaced by kdbus_transport.
+ */
+static void
+check_read_watch (DBusTransport *transport)
+{
+  DBusTransportKdbus *kdbus_transport = (DBusTransportKdbus*) transport;
+  dbus_bool_t need_read_watch;
+
+  _dbus_verbose ("fd = %d\n",kdbus_transport->fd);
+
+  if (transport->connection == NULL)
+    return;
+
+  if (transport->disconnected)
+    {
+      _dbus_assert (kdbus_transport->read_watch == NULL);
+      return;
+    }
+
+  _dbus_transport_ref (transport);
+
+   need_read_watch =
+      (_dbus_counter_get_size_value (transport->live_messages) < transport->max_live_messages_size) &&
+      (_dbus_counter_get_unix_fd_value (transport->live_messages) < transport->max_live_messages_unix_fds);
+
+  _dbus_verbose ("  setting read watch enabled = %d\n", need_read_watch);
+  _dbus_connection_toggle_watch_unlocked (transport->connection,
+                                          kdbus_transport->read_watch,
+                                          need_read_watch);
+
+  _dbus_transport_unref (transport);
+}
+
+/**
+ * Copy-paste from socket transport.
+ */
+static void
+do_io_error (DBusTransport *transport)
+{
+  _dbus_transport_ref (transport);
+  _dbus_transport_disconnect (transport);
+  _dbus_transport_unref (transport);
+}
+
+/**
+ *  Based on do_writing from socket transport.
+ *  Removed authentication code and code related to encoded messages
+ *  and adapted to kdbus transport.
+ *  In socket transport returns false on out-of-memory. Here this won't happen,
+ *  so it always returns TRUE.
+ */
+static dbus_bool_t
+do_writing (DBusTransport *transport)
+{
+  DBusTransportKdbus *kdbus_transport = (DBusTransportKdbus*) transport;
+  int total = 0;
+
+  if (transport->disconnected)
+    {
+      _dbus_verbose ("Not connected, not writing anything\n");
+      return TRUE;
+    }
+
+  _dbus_verbose ("do_writing(), have_messages = %d, fd = %d\n",
+      _dbus_connection_has_messages_to_send_unlocked (transport->connection),
+      kdbus_transport->fd);
+
+  while (!transport->disconnected && _dbus_connection_has_messages_to_send_unlocked (transport->connection))
+    {
+      int bytes_written;
+      DBusMessage *message;
+      const DBusString *header;
+      const DBusString *body;
+      int total_bytes_to_write;
+      const char* pDestination;
+
+      if (total > kdbus_transport->max_bytes_written_per_iteration)
+        {
+          _dbus_verbose ("%d bytes exceeds %d bytes written per iteration, returning\n",
+                         total, kdbus_transport->max_bytes_written_per_iteration);
+          goto out;
+        }
+
+      message = _dbus_connection_get_message_to_send (transport->connection);
+      _dbus_assert (message != NULL);
+      if(dbus_message_get_sender(message) == NULL)  //needed for daemon to pass pending activation messages
+        {
+          dbus_message_unlock(message);
+          dbus_message_set_sender(message, kdbus_transport->sender);
+          dbus_message_lock (message);
+        }
+      _dbus_message_get_network_data (message, &header, &body);
+      total_bytes_to_write = _dbus_string_get_length(header) + _dbus_string_get_length(body);
+      pDestination = dbus_message_get_destination(message);
+
+      if(pDestination)
+        {
+          int ret;
+
+          ret = capture_hello_message(transport, pDestination, message);
+          if(ret < 0)  //error
+            {
+              bytes_written = -1;
+              goto written;
+            }
+          else if(ret == 0)  //hello message captured and handled correctly
+            {
+              bytes_written = total_bytes_to_write;
+              goto written;
+            }
+          //else send as regular message
+        }
+
+      bytes_written = kdbus_write_msg(kdbus_transport, message, pDestination);
+
+      written:
+      if (bytes_written < 0)
+        {
+          /* EINTR already handled for us */
+
+          /* For some discussion of why we also ignore EPIPE here, see
+           * http://lists.freedesktop.org/archives/dbus/2008-March/009526.html
+           */
+
+          if (_dbus_get_is_errno_eagain_or_ewouldblock () || _dbus_get_is_errno_epipe ())
+            goto out;
+          else
+            {
+              _dbus_verbose ("Error writing to remote app: %s\n", _dbus_strerror_from_errno ());
+              do_io_error (transport);
+              goto out;
+            }
+        }
+      else if (bytes_written == 0)
+        {
+           _dbus_verbose ("Destination is not available\n");
+           _dbus_connection_message_sent_unlocked (transport->connection,
+                   message);
+        }
+      else
+        {
+          _dbus_verbose (" wrote %d bytes of %d\n", bytes_written,
+              total_bytes_to_write);
+
+          total += bytes_written;
+
+          _dbus_assert (bytes_written == total_bytes_to_write);
+
+          _dbus_connection_message_sent_unlocked (transport->connection,
+                  message);
+        }
+    }
+
+  out:
+  return TRUE;
+}
+
+/**
+ *  Based on do_reading from socket transport.
+ *  Removed authentication code and code related to encoded messages
+ *  and adapted to kdbus transport.
+ *  returns false on out-of-memory
+ */
+static dbus_bool_t
+do_reading (DBusTransport *transport)
+{
+  DBusTransportKdbus *kdbus_transport = (DBusTransportKdbus*) transport;
+  DBusString *buffer;
+  int bytes_read;
+  dbus_bool_t oom = FALSE;
+  int *fds, n_fds;
+  int total = 0;
+
+  _dbus_verbose ("fd = %d\n",kdbus_transport->fd);
+
+ again:
+
+  /* See if we've exceeded max messages and need to disable reading */
+  check_read_watch (transport);
+
+  if (total > kdbus_transport->max_bytes_read_per_iteration)
+    {
+      _dbus_verbose ("%d bytes exceeds %d bytes read per iteration, returning\n",
+                     total, kdbus_transport->max_bytes_read_per_iteration);
+      goto out;
+    }
+
+  _dbus_assert (kdbus_transport->read_watch != NULL ||
+                transport->disconnected);
+
+  if (transport->disconnected)
+    goto out;
+
+  if (!dbus_watch_get_enabled (kdbus_transport->read_watch))
+    return TRUE;
+
+  if (!_dbus_message_loader_get_unix_fds(transport->loader, &fds, &n_fds))
+  {
+      _dbus_verbose ("Out of memory reading file descriptors\n");
+      oom = TRUE;
+      goto out;
+  }
+  _dbus_message_loader_get_buffer (transport->loader, &buffer);
+
+  bytes_read = kdbus_read_message(kdbus_transport, buffer, fds, &n_fds);
+
+  if (bytes_read >= 0 && n_fds > 0)
+    _dbus_verbose("Read %i unix fds\n", n_fds);
+
+  _dbus_message_loader_return_buffer (transport->loader,
+                                      buffer);
+  _dbus_message_loader_return_unix_fds(transport->loader, fds, bytes_read < 0 ? 0 : n_fds);
+
+  if (bytes_read < 0)
+    {
+      /* EINTR already handled for us */
+
+      if (_dbus_get_is_errno_enomem ())
+        {
+          _dbus_verbose ("Out of memory in read()/do_reading()\n");
+          oom = TRUE;
+          goto out;
+        }
+      else if (_dbus_get_is_errno_eagain_or_ewouldblock ())
+        goto out;
+      else
+        {
+          _dbus_verbose ("Error reading from remote app: %s\n",
+                         _dbus_strerror_from_errno ());
+          do_io_error (transport);
+          goto out;
+        }
+    }
+  else if (bytes_read == 0)
+    {
+      _dbus_verbose ("Disconnected from remote app\n");
+      do_io_error (transport);
+      goto out;
+    }
+  else
+    {
+      _dbus_verbose (" read %d bytes\n", bytes_read);
+
+      total += bytes_read;
+
+      if (!_dbus_transport_queue_messages (transport))
+        {
+          oom = TRUE;
+          _dbus_verbose (" out of memory when queueing messages we just read in the transport\n");
+          goto out;
+        }
+
+      /* Try reading more data until we get EAGAIN and return, or
+       * exceed max bytes per iteration.  If in blocking mode of
+       * course we'll block instead of returning.
+       */
+      goto again;
+    }
+
+ out:
+  if (oom)
+    return FALSE;
+  return TRUE;
+}
+
+/**
+ * Copy-paste from socket transport, with socket replaced by kdbus.
+ */
+static dbus_bool_t
+unix_error_with_read_to_come (DBusTransport *itransport,
+                              DBusWatch     *watch,
+                              unsigned int   flags)
+{
+   DBusTransportKdbus *transport = (DBusTransportKdbus *) itransport;
+
+   if (!((flags & DBUS_WATCH_HANGUP) || (flags & DBUS_WATCH_ERROR)))
+      return FALSE;
+
+  /* If we have a read watch enabled ...
+     we -might have data incoming ... => handle the HANGUP there */
+   if (watch != transport->read_watch && _dbus_watch_get_enabled (transport->read_watch))
+      return FALSE;
+
+   return TRUE;
+}
+
+/**
+ *  Copy-paste from socket transport. Removed authentication related code
+ *  and renamed socket_transport to kdbus_transport.
+ */
+static dbus_bool_t
+kdbus_handle_watch (DBusTransport *transport,
+                   DBusWatch     *watch,
+                   unsigned int   flags)
+{
+  DBusTransportKdbus *kdbus_transport = (DBusTransportKdbus*) transport;
+
+  _dbus_assert (watch == kdbus_transport->read_watch ||
+                watch == kdbus_transport->write_watch);
+  _dbus_assert (watch != NULL);
+
+  /* If we hit an error here on a write watch, don't disconnect the transport yet because data can
+   * still be in the buffer and do_reading may need several iteration to read
+   * it all (because of its max_bytes_read_per_iteration limit).
+   */
+  if (!(flags & DBUS_WATCH_READABLE) && unix_error_with_read_to_come (transport, watch, flags))
+    {
+      _dbus_verbose ("Hang up or error on watch\n");
+      _dbus_transport_disconnect (transport);
+      return TRUE;
+    }
+
+  if (watch == kdbus_transport->read_watch &&
+      (flags & DBUS_WATCH_READABLE))
+    {
+      _dbus_verbose ("handling read watch %p flags = %x\n",
+                     watch, flags);
+
+	  if (!do_reading (transport))
+	    {
+	      _dbus_verbose ("no memory to read\n");
+	      return FALSE;
+	    }
+
+    }
+  else if (watch == kdbus_transport->write_watch &&
+           (flags & DBUS_WATCH_WRITABLE))
+    {
+      _dbus_verbose ("handling write watch, have_outgoing_messages = %d\n",
+                     _dbus_connection_has_messages_to_send_unlocked (transport->connection));
+
+      if (!do_writing (transport))
+        {
+          _dbus_verbose ("no memory to write\n");
+          return FALSE;
+        }
+
+      /* See if we still need the write watch */
+      check_write_watch (transport);
+    }
+
+  return TRUE;
+}
+
+/**
+ * Copy-paste from socket transport, but socket_transport renamed to kdbus_transport
+ * and _dbus_close_socket replaced with close().
+ */
+static void
+kdbus_disconnect (DBusTransport *transport)
+{
+  DBusTransportKdbus *kdbus_transport = (DBusTransportKdbus*) transport;
+
+  _dbus_verbose ("\n");
+
+  free_watches (transport);
+
+  again:
+   if (close (kdbus_transport->fd) < 0)
+     {
+       if (errno == EINTR)
+         goto again;
+     }
+
+  kdbus_transport->fd = -1;
+}
+
+/**
+ *  Copy-paste from socket transport. Renamed socket_transport to
+ *  kdbus_transport and added dbus_connection_set_is_authenticated, because
+ *  we do not perform authentication in kdbus, so we have mark is as already done
+ *  to make everything work.
+ */
+static dbus_bool_t
+kdbus_connection_set (DBusTransport *transport)
+{
+  DBusTransportKdbus *kdbus_transport = (DBusTransportKdbus*) transport;
+
+  dbus_connection_set_is_authenticated(transport->connection); //now we don't have authentication in kdbus, so mark it done
+
+  _dbus_watch_set_handler (kdbus_transport->write_watch,
+                           _dbus_connection_handle_watch,
+                           transport->connection, NULL);
+
+  _dbus_watch_set_handler (kdbus_transport->read_watch,
+                           _dbus_connection_handle_watch,
+                           transport->connection, NULL);
+
+  if (!_dbus_connection_add_watch_unlocked (transport->connection,
+                                            kdbus_transport->write_watch))
+    return FALSE;
+
+  if (!_dbus_connection_add_watch_unlocked (transport->connection,
+                                            kdbus_transport->read_watch))
+    {
+      _dbus_connection_remove_watch_unlocked (transport->connection,
+                                              kdbus_transport->write_watch);
+      return FALSE;
+    }
+
+  check_read_watch (transport);
+  check_write_watch (transport);
+
+  return TRUE;
+}
+
+/**
+ *  Copy-paste from socket_transport.
+ *  Socket_transport renamed to kdbus_transport
+ *
+ *   Original dbus copy-pasted @todo comment below.
+ * @todo We need to have a way to wake up the select sleep if
+ * a new iteration request comes in with a flag (read/write) that
+ * we're not currently serving. Otherwise a call that just reads
+ * could block a write call forever (if there are no incoming
+ * messages).
+ */
+static  void
+kdbus_do_iteration (DBusTransport *transport,
+                   unsigned int   flags,
+                   int            timeout_milliseconds)
+{
+	DBusTransportKdbus *kdbus_transport = (DBusTransportKdbus*) transport;
+	DBusPollFD poll_fd;
+	int poll_res;
+	int poll_timeout;
+
+	_dbus_verbose (" iteration flags = %s%s timeout = %d read_watch = %p write_watch = %p fd = %d\n",
+                 flags & DBUS_ITERATION_DO_READING ? "read" : "",
+                 flags & DBUS_ITERATION_DO_WRITING ? "write" : "",
+                 timeout_milliseconds,
+                 kdbus_transport->read_watch,
+                 kdbus_transport->write_watch,
+                 kdbus_transport->fd);
+
+   poll_fd.fd = kdbus_transport->fd;
+   poll_fd.events = 0;
+
+   /* This is kind of a hack; if we have stuff to write, then try
+    * to avoid the poll. This is probably about a 5% speedup on an
+    * echo client/server.
+    *
+    * If both reading and writing were requested, we want to avoid this
+    * since it could have funky effects:
+    *   - both ends spinning waiting for the other one to read
+    *     data so they can finish writing
+    *   - prioritizing all writing ahead of reading
+    */
+   if ((flags & DBUS_ITERATION_DO_WRITING) &&
+       !(flags & (DBUS_ITERATION_DO_READING | DBUS_ITERATION_BLOCK)) &&
+       !transport->disconnected &&
+       _dbus_connection_has_messages_to_send_unlocked (transport->connection))
+     {
+       do_writing (transport);
+
+       if (transport->disconnected ||
+           !_dbus_connection_has_messages_to_send_unlocked (transport->connection))
+         goto out;
+     }
+
+   /* If we get here, we decided to do the poll() after all */
+   _dbus_assert (kdbus_transport->read_watch);
+   if (flags & DBUS_ITERATION_DO_READING)
+     poll_fd.events |= _DBUS_POLLIN;
+
+   _dbus_assert (kdbus_transport->write_watch);
+   if (flags & DBUS_ITERATION_DO_WRITING)
+     poll_fd.events |= _DBUS_POLLOUT;
+
+   if (poll_fd.events)
+   {
+      if (flags & DBUS_ITERATION_BLOCK)
+	     poll_timeout = timeout_milliseconds;
+      else
+	     poll_timeout = 0;
+
+      /* For blocking selects we drop the connection lock here
+       * to avoid blocking out connection access during a potentially
+       * indefinite blocking call. The io path is still protected
+       * by the io_path_cond condvar, so we won't reenter this.
+       */
+      if (flags & DBUS_ITERATION_BLOCK)
+      {
+         _dbus_verbose ("unlock pre poll\n");
+         _dbus_connection_unlock (transport->connection);
+      }
+
+    again:
+      poll_res = _dbus_poll (&poll_fd, 1, poll_timeout);
+
+      if (poll_res < 0 && _dbus_get_is_errno_eintr ())
+        goto again;
+
+      if (flags & DBUS_ITERATION_BLOCK)
+      {
+         _dbus_verbose ("lock post poll\n");
+         _dbus_connection_lock (transport->connection);
+      }
+
+      if (poll_res >= 0)
+      {
+         if (poll_res == 0)
+            poll_fd.revents = 0; /* some concern that posix does not guarantee this;
+                                  * valgrind flags it as an error. though it probably
+                                  * is guaranteed on linux at least.
+                                  */
+
+         if (poll_fd.revents & _DBUS_POLLERR)
+            do_io_error (transport);
+         else
+         {
+            dbus_bool_t need_read = (poll_fd.revents & _DBUS_POLLIN) > 0;
+            dbus_bool_t need_write = (poll_fd.revents & _DBUS_POLLOUT) > 0;
+
+            _dbus_verbose ("in iteration, need_read=%d need_write=%d\n",
+                             need_read, need_write);
+
+            if (need_read && (flags & DBUS_ITERATION_DO_READING))
+               do_reading (transport);
+            if (need_write && (flags & DBUS_ITERATION_DO_WRITING))
+               do_writing (transport);
+         }
+      }
+      else
+         _dbus_verbose ("Error from _dbus_poll(): %s\n", _dbus_strerror_from_errno ());
+   }
+
+ out:
+  /* We need to install the write watch only if we did not
+   * successfully write everything. Note we need to be careful that we
+   * don't call check_write_watch *before* do_writing, since it's
+   * inefficient to add the write watch, and we can avoid it most of
+   * the time since we can write immediately.
+   *
+   * However, we MUST always call check_write_watch(); DBusConnection code
+   * relies on the fact that running an iteration will notice that
+   * messages are pending.
+   */
+   check_write_watch (transport);
+
+   _dbus_verbose (" ... leaving do_iteration()\n");
+}
+
+/**
+ * Copy-paste from socket transport.
+ */
+static void
+kdbus_live_messages_changed (DBusTransport *transport)
+{
+  /* See if we should look for incoming messages again */
+  check_read_watch (transport);
+}
+
+/**
+ * Gets file descriptor of the kdbus bus.
+ * @param transport transport
+ * @param fd_p place to write fd to
+ * @returns always TRUE
+ */
+static dbus_bool_t
+kdbus_get_kdbus_fd (DBusTransport *transport,
+                      int           *fd_p)
+{
+  DBusTransportKdbus *kdbus_transport = (DBusTransportKdbus*) transport;
+
+  *fd_p = kdbus_transport->fd;
+
+  return TRUE;
+}
+
+static const DBusTransportVTable kdbus_vtable = {
+  transport_finalize,
+  kdbus_handle_watch,
+  kdbus_disconnect,
+  kdbus_connection_set,
+  kdbus_do_iteration,
+  kdbus_live_messages_changed,
+  kdbus_get_kdbus_fd
+};
+
+/**
+ * Copy-paste from dbus_transport_socket with needed changes.
+ *
+ * Creates a new transport for the given kdbus file descriptor and address.
+ * The file descriptor must be nonblocking.
+ *
+ * @param fd the file descriptor.
+ * @param address the transport's address
+ * @returns the new transport, or #NULL if no memory.
+ */
+static DBusTransport*
+new_kdbus_transport (int fd, const DBusString *address)
+{
+	DBusTransportKdbus *kdbus_transport;
+
+  kdbus_transport = dbus_new0 (DBusTransportKdbus, 1);
+  if (kdbus_transport == NULL)
+    return NULL;
+
+  kdbus_transport->write_watch = _dbus_watch_new (fd,
+                                                 DBUS_WATCH_WRITABLE,
+                                                 FALSE,
+                                                 NULL, NULL, NULL);
+  if (kdbus_transport->write_watch == NULL)
+    goto failed_2;
+
+  kdbus_transport->read_watch = _dbus_watch_new (fd,
+                                                DBUS_WATCH_READABLE,
+                                                FALSE,
+                                                NULL, NULL, NULL);
+  if (kdbus_transport->read_watch == NULL)
+    goto failed_3;
+
+  if (!_dbus_transport_init_base (&kdbus_transport->base,
+                                  &kdbus_vtable,
+                                  NULL, address))
+    goto failed_4;
+
+  kdbus_transport->fd = fd;
+
+  /* These values should probably be tunable or something. */
+  kdbus_transport->max_bytes_read_per_iteration = MAX_BYTES_PER_ITERATION;
+  kdbus_transport->max_bytes_written_per_iteration = MAX_BYTES_PER_ITERATION;
+
+  kdbus_transport->kdbus_mmap_ptr = NULL;
+  kdbus_transport->memfd = -1;
+  
+  return (DBusTransport*) kdbus_transport;
+
+ failed_4:
+  _dbus_watch_invalidate (kdbus_transport->read_watch);
+  _dbus_watch_unref (kdbus_transport->read_watch);
+ failed_3:
+  _dbus_watch_invalidate (kdbus_transport->write_watch);
+  _dbus_watch_unref (kdbus_transport->write_watch);
+ failed_2:
+  dbus_free (kdbus_transport);
+  return NULL;
+}
+
+/**
+ * Opens a connection to the kdbus bus
+ *
+ * @param path the path to kdbus bus
+ * @param error return location for error code
+ * @returns connection file descriptor or -1 on error
+ */
+static int _dbus_connect_kdbus (const char *path, DBusError *error)
+{
+	int fd;
+
+	_DBUS_ASSERT_ERROR_IS_CLEAR (error);
+	_dbus_verbose ("connecting to kdbus bus %s\n", path);
+
+	fd = open(path, O_RDWR|O_CLOEXEC|O_NONBLOCK);
+	if (fd < 0)
+		dbus_set_error(error, _dbus_error_from_errno (errno), "Failed to open file descriptor: %s", _dbus_strerror (errno));
+
+	return fd;
+}
+
+/**
+ * Connects to kdbus, creates and sets-up transport.
+ *
+ * @param path the path to the bus.
+ * @param error address where an error can be returned.
+ * @returns a new transport, or #NULL on failure.
+ */
+static DBusTransport* _dbus_transport_new_for_kdbus (const char *path, DBusError *error)
+{
+	int fd;
+	DBusTransport *transport;
+	DBusString address;
+
+	_DBUS_ASSERT_ERROR_IS_CLEAR (error);
+
+	if (!_dbus_string_init (&address))
+    {
+		dbus_set_error (error, DBUS_ERROR_NO_MEMORY, NULL);
+		return NULL;
+    }
+
+	fd = -1;
+
+	if ((!_dbus_string_append (&address, "kdbus:path=")) || (!_dbus_string_append (&address, path)))
+    {
+		dbus_set_error (error, DBUS_ERROR_NO_MEMORY, NULL);
+		goto failed_0;
+    }
+
+	fd = _dbus_connect_kdbus (path, error);
+	if (fd < 0)
+    {
+		_DBUS_ASSERT_ERROR_IS_SET (error);
+		goto failed_0;
+    }
+
+	_dbus_verbose ("Successfully connected to kdbus bus %s\n", path);
+
+	transport = new_kdbus_transport (fd, &address);
+	if (transport == NULL)
+    {
+		dbus_set_error (error, DBUS_ERROR_NO_MEMORY, NULL);
+		goto failed_1;
+    }
+
+	_dbus_string_free (&address);
+
+	return transport;
+
+	failed_1:
+  again:
+   if (close (fd) < 0)
+     {
+       if (errno == EINTR)
+         goto again;
+     }
+  failed_0:
+	_dbus_string_free (&address);
+  return NULL;
+}
+
+
+/**
+ * Opens kdbus transport if method from address entry is kdbus
+ *
+ * @param entry the address entry to open
+ * @param transport_p return location for the opened transport
+ * @param error place to store error
+ * @returns result of the attempt as a DBusTransportOpenResult enum
+ */
+DBusTransportOpenResult _dbus_transport_open_kdbus(DBusAddressEntry  *entry,
+							   DBusTransport    **transport_p,
+							   DBusError         *error)
+{
+	const char *method;
+
+	method = dbus_address_entry_get_method (entry);
+	_dbus_assert (method != NULL);
+
+	if (strcmp (method, "kdbus") == 0)
+    {
+		const char *path = dbus_address_entry_get_value (entry, "path");
+
+		if (path == NULL)
+        {
+			_dbus_set_bad_address (error, "kdbus", "path", NULL);
+			return DBUS_TRANSPORT_OPEN_BAD_ADDRESS;
+        }
+
+        *transport_p = _dbus_transport_new_for_kdbus (path, error);
+
+        if (*transport_p == NULL)
+        {
+		_DBUS_ASSERT_ERROR_IS_SET (error);
+		return DBUS_TRANSPORT_OPEN_DID_NOT_CONNECT;
+        }
+        else
+        {
+		_DBUS_ASSERT_ERROR_IS_CLEAR (error);
+		return DBUS_TRANSPORT_OPEN_OK;
+        }
+    }
+	else
+    {
+		_DBUS_ASSERT_ERROR_IS_CLEAR (error);
+		return DBUS_TRANSPORT_OPEN_NOT_HANDLED;
+    }
+}
+
+/** @} */
diff --git a/dbus/dbus-transport-kdbus.h b/dbus/dbus-transport-kdbus.h
new file mode 100644
index 0000000..f070dac
--- /dev/null
+++ b/dbus/dbus-transport-kdbus.h
@@ -0,0 +1,37 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+/* dbus-transport-kdbus.h kdbus subclasses of DBusTransport
+ *
+ * Copyright (C) 2002, 2006  Red Hat Inc.
+ * Copyright (C) 2013  Samsung Electronics
+ *
+ * Licensed under the Academic Free License version 2.1
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version and under the terms of the GNU
+ * Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+#ifndef DBUS_TRANSPORT_KDBUS_H_
+#define DBUS_TRANSPORT_KDBUS_H_
+
+#include "dbus-transport-protected.h"
+#include <linux/types.h>
+
+__u64 dbus_transport_get_bloom_size(DBusTransport* transport);
+void* dbus_transport_get_pool_pointer(DBusTransport* transport);
+DBusTransportOpenResult _dbus_transport_open_kdbus(DBusAddressEntry *entry, DBusTransport **transport_p, DBusError *error);
+
+#endif
diff --git a/dbus/dbus-transport-socket.c b/dbus/dbus-transport-socket.c
index 774f459..20ddc2f 100644
--- a/dbus/dbus-transport-socket.c
+++ b/dbus/dbus-transport-socket.c
@@ -807,7 +807,7 @@ do_reading (DBusTransport *transport)
       _dbus_message_loader_return_buffer (transport->loader,
                                           buffer);
     }
-  
+
   if (bytes_read < 0)
     {
       /* EINTR already handled for us */
diff --git a/dbus/dbus-transport.c b/dbus/dbus-transport.c
index ecc3182..1105f81 100644
--- a/dbus/dbus-transport.c
+++ b/dbus/dbus-transport.c
@@ -2,6 +2,7 @@
 /* dbus-transport.c DBusTransport object (internal to D-Bus implementation)
  *
  * Copyright (C) 2002, 2003  Red Hat Inc.
+ * Copyright (C) 2013  Samsung Electronics
  *
  * Licensed under the Academic Free License version 2.1
  * 
@@ -21,7 +22,8 @@
  *
  */
 
-#include <config.h>
+
+#include <../config.h>
 #include "dbus-transport-protected.h"
 #include "dbus-transport-unix.h"
 #include "dbus-transport-socket.h"
@@ -32,6 +34,10 @@
 #include "dbus-credentials.h"
 #include "dbus-mainloop.h"
 #include "dbus-message.h"
+
+#ifdef ENABLE_KDBUS_TRANSPORT
+#include "dbus-transport-kdbus.h"
+#endif
 #ifdef DBUS_ENABLE_EMBEDDED_TESTS
 #include "dbus-server-debug-pipe.h"
 #endif
@@ -107,7 +113,7 @@ _dbus_transport_init_base (DBusTransport             *transport,
   DBusMessageLoader *loader;
   DBusAuth *auth;
   DBusCounter *counter;
-  char *address_copy;
+  char *address_copy = NULL;
   DBusCredentials *creds;
   
   loader = _dbus_message_loader_new ();
@@ -117,10 +123,28 @@ _dbus_transport_init_base (DBusTransport             *transport,
   if (server_guid)
     auth = _dbus_auth_server_new (server_guid);
   else
-    auth = _dbus_auth_client_new ();
+  {
+	  _dbus_assert (address != NULL);
+	  if (!_dbus_string_copy_data (address, &address_copy))
+        {
+          _dbus_message_loader_unref (loader);
+          return FALSE;
+        }
+#ifdef ENABLE_KDBUS_TRANSPORT
+      if(address_copy == strstr(address_copy, "kdbus:path="))
+	  auth = _dbus_auth_client_new_kdbus();
+	  else
+#endif
+		  auth = _dbus_auth_client_new ();
+  }
+
   if (auth == NULL)
     {
       _dbus_message_loader_unref (loader);
+
+      if (address_copy != NULL)
+        dbus_free(address_copy);
+
       return FALSE;
     }
 
@@ -129,6 +153,10 @@ _dbus_transport_init_base (DBusTransport             *transport,
     {
       _dbus_auth_unref (auth);
       _dbus_message_loader_unref (loader);
+
+      if (address_copy != NULL)
+        dbus_free(address_copy);
+
       return FALSE;
     }  
 
@@ -138,6 +166,10 @@ _dbus_transport_init_base (DBusTransport             *transport,
       _dbus_counter_unref (counter);
       _dbus_auth_unref (auth);
       _dbus_message_loader_unref (loader);
+
+      if (address_copy != NULL)
+        dbus_free(address_copy);
+
       return FALSE;
     }
   
@@ -146,19 +178,6 @@ _dbus_transport_init_base (DBusTransport             *transport,
       _dbus_assert (address == NULL);
       address_copy = NULL;
     }
-  else
-    {
-      _dbus_assert (address != NULL);
-
-      if (!_dbus_string_copy_data (address, &address_copy))
-        {
-          _dbus_credentials_unref (creds);
-          _dbus_counter_unref (counter);
-          _dbus_auth_unref (auth);
-          _dbus_message_loader_unref (loader);
-          return FALSE;
-        }
-    }
   
   transport->refcount = 1;
   transport->vtable = vtable;
@@ -347,6 +366,9 @@ static const struct {
                                     DBusTransport   **transport_p,
                                     DBusError        *error);
 } open_funcs[] = {
+#ifdef ENABLE_KDBUS_TRANSPORT
+  { _dbus_transport_open_kdbus },
+#endif
   { _dbus_transport_open_socket },
   { _dbus_transport_open_platform_specific },
   { _dbus_transport_open_autolaunch }
@@ -1014,7 +1036,7 @@ recover_unused_bytes (DBusTransport *transport)
       const DBusString *encoded;
       DBusString *buffer;
       int orig_len;
-      
+
       if (!_dbus_string_init (&plaintext))
         goto nomem;
       
@@ -1027,12 +1049,12 @@ recover_unused_bytes (DBusTransport *transport)
           _dbus_string_free (&plaintext);
           goto nomem;
         }
-      
+
       _dbus_message_loader_get_buffer (transport->loader,
                                        &buffer);
       
       orig_len = _dbus_string_get_length (buffer);
-      
+
       if (!_dbus_string_move (&plaintext, 0, buffer,
                               orig_len))
         {
@@ -1062,7 +1084,7 @@ recover_unused_bytes (DBusTransport *transport)
                                        &buffer);
                 
       orig_len = _dbus_string_get_length (buffer);
-                
+
       _dbus_auth_get_unused_bytes (transport->auth,
                                    &bytes);
 
diff --git a/dbus/dbus-transport.h b/dbus/dbus-transport.h
index 80fa24e..04f512f 100644
--- a/dbus/dbus-transport.h
+++ b/dbus/dbus-transport.h
@@ -98,6 +98,11 @@ dbus_bool_t        _dbus_transport_set_auth_mechanisms    (DBusTransport
 void               _dbus_transport_set_allow_anonymous    (DBusTransport              *transport,
                                                            dbus_bool_t                 value);
 
+#ifdef ENABLE_KDBUS_TRANSPORT
+DBUS_EXPORT
+DBusTransport* 	dbus_connection_get_transport	   (DBusConnection *connection);
+#endif
+
 /* if DBUS_ENABLE_STATS */
 void _dbus_transport_get_stats (DBusTransport  *transport,
                                 dbus_uint32_t  *queue_bytes,
diff --git a/dbus/kdbus-common.c b/dbus/kdbus-common.c
new file mode 100644
index 0000000..837ed91
--- /dev/null
+++ b/dbus/kdbus-common.c
@@ -0,0 +1,386 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+/* kdbus-common.c  kdbus related utils for daemon and libdbus
+ *
+ * Copyright (C) 2013  Samsung Electronics
+ *
+ * Licensed under the Academic Free License version 2.1
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version and under the terms of the GNU
+ * Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+#include "kdbus.h"
+#include "kdbus-common.h"
+#include "dbus-transport-kdbus.h"
+#include <string.h>
+#include <stddef.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <unistd.h>
+#include <dbus/dbus-internals.h>
+#include <dbus/dbus-shared.h>
+
+static struct kdbus_item *make_policy_name(const char *name)
+{
+  struct kdbus_item *p;
+  __u64 size;
+
+  size = offsetof(struct kdbus_item, policy.name) + strlen(name) + 1;
+  p = malloc(size);
+  if (!p)
+	  return NULL;
+  memset(p, 0, size);
+  p->size = size;
+  p->type = KDBUS_ITEM_POLICY_NAME;
+  memcpy(p->policy.name, name, strlen(name) + 1);
+
+  return p;
+}
+
+static  struct kdbus_item *make_policy_access(__u64 type, __u64 bits, __u64 id)
+{
+  struct kdbus_item *p;
+  __u64 size = sizeof(*p);
+
+  p = malloc(size);
+  if (!p)
+	  return NULL;
+
+  memset(p, 0, size);
+  p->size = size;
+  p->type = KDBUS_ITEM_POLICY_ACCESS;
+  p->policy.access.type = type;
+  p->policy.access.bits = bits;
+  p->policy.access.id = id;
+
+  return p;
+}
+
+static void append_policy(struct kdbus_cmd_policy *cmd_policy, struct kdbus_item *policy, __u64 max_size)
+{
+  struct kdbus_item *dst = (struct kdbus_item *) ((char *) cmd_policy + cmd_policy->size);
+
+  if (cmd_policy->size + policy->size > max_size)
+	  return;
+
+  memcpy(dst, policy, policy->size);
+  cmd_policy->size += KDBUS_ALIGN8(policy->size);
+  free(policy);
+}
+
+/**
+ * Registers kdbus policy for given connection.
+ *
+ * Policy sets rights of the name (unique or well known) on the bus. Without policy it is
+ * not possible to send or receive messages. It must be set separately for unique id and
+ * well known name of the connection. It is set after registering on the bus, but before
+ * requesting for name. The policy is valid for the given name, not for the connection.
+ *
+ * Name of the policy equals name on the bus.
+ *
+ * @param name name of the policy = name of the connection
+ * @param transport - transport
+ * @param owner_uid - uid or euid of the process being owner of the name
+ *
+ * @returns #TRUE on success
+ */
+dbus_bool_t register_kdbus_policy(const char* name, DBusTransport *transport, unsigned long int owner_uid)
+{
+  struct kdbus_cmd_policy *cmd_policy;
+  struct kdbus_item *policy;
+  int size = 0xffff;
+  int fd;
+
+  if(!_dbus_transport_get_socket_fd (transport, &fd))
+    return FALSE;
+
+  cmd_policy = alloca(size);
+  memset(cmd_policy, 0, size);
+
+  policy = (struct kdbus_item *) cmd_policy->policies;
+  cmd_policy->size = offsetof(struct kdbus_cmd_policy, policies);
+
+  policy = make_policy_name(name);
+  append_policy(cmd_policy, policy, size);
+
+  policy = make_policy_access(KDBUS_POLICY_ACCESS_USER, KDBUS_POLICY_OWN, owner_uid);
+  append_policy(cmd_policy, policy, size);
+
+  policy = make_policy_access(KDBUS_POLICY_ACCESS_WORLD, KDBUS_POLICY_RECV, 0);
+  append_policy(cmd_policy, policy, size);
+
+  policy = make_policy_access(KDBUS_POLICY_ACCESS_WORLD, KDBUS_POLICY_SEND, 0);
+  append_policy(cmd_policy, policy, size);
+
+  if (ioctl(fd, KDBUS_CMD_EP_POLICY_SET, cmd_policy) < 0)
+    {
+      _dbus_verbose ("Error setting policy: %m, %d\n", errno);
+      return FALSE;
+    }
+
+  _dbus_verbose("Policy %s set correctly\n", name);
+  return TRUE;
+}
+
+/**
+ *
+ * Asks the bus to assign the given name to the connection.
+ *
+ * Use same flags as original dbus version with one exception below.
+ * Result flag #DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER is currently
+ * never returned by kdbus, instead DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER
+ * is returned by kdbus.
+ *
+ * @param fd - file descriptor of the connection
+ * @param name the name to request
+ * @param flags flags
+ * @param id unique id of the connection for which the name is being registered
+ * @returns a DBus result code on success, -errno on error
+ */
+int request_kdbus_name(int fd, const char *name, const __u64 flags, __u64 id)
+{
+  struct kdbus_cmd_name *cmd_name;
+
+  __u64 size = sizeof(*cmd_name) + strlen(name) + 1;
+  __u64 flags_kdbus = 0;
+
+  cmd_name = alloca(size);
+
+  strcpy(cmd_name->name, name);
+  cmd_name->size = size;
+
+  if(flags & DBUS_NAME_FLAG_ALLOW_REPLACEMENT)
+    flags_kdbus |= KDBUS_NAME_ALLOW_REPLACEMENT;
+  if(!(flags & DBUS_NAME_FLAG_DO_NOT_QUEUE))
+    flags_kdbus |= KDBUS_NAME_QUEUE;
+  if(flags & DBUS_NAME_FLAG_REPLACE_EXISTING)
+    flags_kdbus |= KDBUS_NAME_REPLACE_EXISTING;
+  if(flags & KDBUS_NAME_STARTER_NAME)
+    flags_kdbus |= KDBUS_NAME_STARTER_NAME;
+
+  cmd_name->flags = flags_kdbus;
+  cmd_name->id = id;
+
+  _dbus_verbose("Request name - flags sent: 0x%llx       !!!!!!!!!\n", cmd_name->flags);
+
+  if (ioctl(fd, KDBUS_CMD_NAME_ACQUIRE, cmd_name))
+    {
+      _dbus_verbose ("error acquiring name '%s': %m, %d\n", name, errno);
+      if(errno == EEXIST)
+        return DBUS_REQUEST_NAME_REPLY_EXISTS;
+      if(errno == EALREADY)
+        return DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER;
+      return -errno;
+    }
+
+  _dbus_verbose("Request name - received flag: 0x%llx       !!!!!!!!!\n", cmd_name->flags);
+
+  if(cmd_name->flags & KDBUS_NAME_IN_QUEUE)
+    return DBUS_REQUEST_NAME_REPLY_IN_QUEUE;
+  else
+    return DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER;
+}
+
+/**
+ *
+ * Releases well-known name - the connections resign from the name
+ * which can be then assigned to another connection or the connection
+ * is being removed from the queue for that name
+ *
+ * @param fd - file descriptor of the connection
+ * @param name the name to request
+ * @param id unique id of the connection for which the name is being released
+ * @returns a DBus result code on success, -errno on error
+ */
+int release_kdbus_name(int fd, const char *name, __u64 id)
+{
+  struct kdbus_cmd_name *cmd_name;
+
+  __u64 size = sizeof(*cmd_name) + strlen(name) + 1;
+
+  cmd_name = alloca(size);
+  cmd_name->id = id;
+  strcpy(cmd_name->name, name);
+  cmd_name->size = size;
+
+  if (ioctl(fd, KDBUS_CMD_NAME_RELEASE, cmd_name))
+    {
+      if((errno == ESRCH) || (errno == ENXIO))
+        return DBUS_RELEASE_NAME_REPLY_NON_EXISTENT;
+      else if (errno == EPERM)
+        return DBUS_RELEASE_NAME_REPLY_NOT_OWNER;
+      _dbus_verbose ("error releasing name '%s' for id:%llu. Error: %m, %d\n", name, (unsigned long long)id, errno);
+      return -errno;
+    }
+
+  _dbus_verbose("Name '%s' released\n", name);
+
+  return DBUS_RELEASE_NAME_REPLY_RELEASED;
+}
+
+/**
+ * Performs kdbus query of id of the given name
+ *
+ * @param name name to query for
+ * @param transport transport
+ * @param pInfo nameInfo structure address to store info about the name
+ * @return 0 on success, -errno if failed
+ */
+int kdbus_NameQuery(const char* name, DBusTransport* transport, struct nameInfo* pInfo)
+{
+  struct kdbus_cmd_conn_info *cmd;
+  int ret;
+  int fd;
+  uint64_t size;
+  __u64 id = 0;
+
+  memset(pInfo, 0, sizeof(struct nameInfo));
+
+  if(!_dbus_transport_get_socket_fd(transport, &fd))
+    return -EPERM;
+
+  size = sizeof(struct kdbus_cmd_conn_info);
+  if((name[0] == ':') && (name[1] == '1') && (name[2] == '.'))  /* if name starts with ":1." it is a unique name and should be send as number */
+     id = strtoull(&name[3], NULL, 10);
+  if(id == 0)
+    size += strlen(name) + 1;
+
+  cmd = alloca(size);
+  if (!cmd)
+  {
+    _dbus_verbose("Error allocating memory for: %s,%s\n", _dbus_strerror (errno), _dbus_error_from_errno (errno));
+    return -errno;
+  }
+
+  memset(cmd, 0, sizeof(struct kdbus_cmd_conn_info));
+  cmd->size = size;
+  cmd->id = id;
+  if(id == 0)
+    memcpy(cmd->name, name, strlen(name) + 1);
+
+  again:
+  ret = ioctl(fd, KDBUS_CMD_CONN_INFO, cmd);
+  if (ret < 0)
+  {
+    if(errno == EINTR)
+      goto again;
+    pInfo->uniqueId = 0;
+    return -errno;
+  }
+  else
+  {
+    struct kdbus_conn_info *info;
+    struct kdbus_item *item;
+
+    info = (struct kdbus_conn_info *)((char*)dbus_transport_get_pool_pointer(transport) + cmd->offset);
+    pInfo->uniqueId = info->id;
+
+    item = info->items;
+    while((uint8_t *)(item) < (uint8_t *)(info) + info->size)
+    {
+      if(item->type == KDBUS_ITEM_CREDS)
+        {
+          pInfo->userId = item->creds.uid;
+          pInfo->processId = item->creds.pid;
+        }
+
+      if(item->type == KDBUS_ITEM_SECLABEL)
+        {
+          pInfo->sec_label_len = item->size - KDBUS_ITEM_HEADER_SIZE - 1;
+          if(pInfo->sec_label_len != 0)
+            {
+              pInfo->sec_label = malloc(pInfo->sec_label_len);
+              if(pInfo->sec_label == NULL)
+                ret = -1;
+              else
+                memcpy(pInfo->sec_label, item->data, pInfo->sec_label_len);
+            }
+        }
+
+      item = KDBUS_PART_NEXT(item);
+    }
+
+    again2:
+    if (ioctl(fd, KDBUS_CMD_FREE, &cmd->offset) < 0)
+    {
+      if(errno == EINTR)
+        goto again2;
+      _dbus_verbose("kdbus error freeing pool: %d (%m)\n", errno);
+      return -errno;
+    }
+  }
+
+  return ret;
+}
+
+/*
+ *  Asks kdbus for uid of the owner of the name given in the message
+ */
+dbus_bool_t kdbus_connection_get_unix_user(DBusConnection* connection, const char* name, unsigned long* uid, DBusError* error)
+{
+  struct nameInfo info;
+  int inter_ret;
+  dbus_bool_t ret = FALSE;
+
+  inter_ret = kdbus_NameQuery(name, dbus_connection_get_transport(connection), &info);
+  if(inter_ret == 0) //name found
+  {
+    _dbus_verbose("User id:%llu\n", (unsigned long long) info.userId);
+    *uid = info.userId;
+    return TRUE;
+  }
+  else if((inter_ret == -ENOENT) || (inter_ret == -ENXIO)) //name has no owner
+    {
+      _dbus_verbose ("Name %s has no owner.\n", name);
+      dbus_set_error (error, DBUS_ERROR_FAILED, "Could not get UID of name '%s': no such name", name);
+    }
+
+  else
+  {
+    _dbus_verbose("kdbus error determining UID: err %d (%m)\n", errno);
+    dbus_set_error (error, DBUS_ERROR_FAILED, "Could not determine UID for '%s'", name);
+  }
+
+  return ret;
+}
+
+/*
+ *  Asks kdbus for pid of the owner of the name given in the message
+ */
+dbus_bool_t kdbus_connection_get_unix_process_id(DBusConnection* connection, const char* name, unsigned long* pid, DBusError* error)
+{
+	struct nameInfo info;
+	int inter_ret;
+	dbus_bool_t ret = FALSE;
+
+	inter_ret = kdbus_NameQuery(name, dbus_connection_get_transport(connection), &info);
+	if(inter_ret == 0) //name found
+	{
+		_dbus_verbose("Process id:%llu\n", (unsigned long long) info.processId);
+		*pid = info.processId;
+		return TRUE;
+	}
+	else if((inter_ret == -ENOENT) || (inter_ret == -ENXIO)) //name has no owner
+		dbus_set_error (error, DBUS_ERROR_FAILED, "Could not get PID of name '%s': no such name", name);
+	else
+	{
+		_dbus_verbose("kdbus error determining PID: err %d (%m)\n", errno);
+		dbus_set_error (error, DBUS_ERROR_FAILED, "Could not determine PID for '%s'", name);
+	}
+
+	return ret;
+}
diff --git a/dbus/kdbus-common.h b/dbus/kdbus-common.h
new file mode 100644
index 0000000..4b84a31
--- /dev/null
+++ b/dbus/kdbus-common.h
@@ -0,0 +1,60 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+/* kdbus-common.h  kdbus related utils for daemon and libdbus
+ *
+ * Copyright (C) 2013  Samsung Electronics
+ *
+ * Licensed under the Academic Free License version 2.1
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version and under the terms of the GNU
+ * Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef KDBUS_COMMON_H_
+#define KDBUS_COMMON_H_
+
+#include <dbus/dbus-types.h>
+#include <dbus/dbus-transport.h>
+#include <dbus/kdbus.h>
+
+#define KDBUS_ALIGN8(l) (((l) + 7) & ~7)
+#define KDBUS_PART_NEXT(part) \
+	(typeof(part))(((uint8_t *)part) + KDBUS_ALIGN8((part)->size))
+#define KDBUS_MSG_MAX_PAYLOAD_VEC_SIZE  0x00800000              /* maximum size of message header and items */
+#define KDBUS_ITEM_HEADER_SIZE          offsetof(struct kdbus_item, data)
+#define KDBUS_ITEM_SIZE(s) KDBUS_ALIGN8((s) + KDBUS_ITEM_HEADER_SIZE)
+
+//todo restore if DBus policy will be applied in kdbus somehow
+//#define POLICY_TO_KDBUS
+
+struct nameInfo
+{
+  __u64 uniqueId;
+  __u64 userId;
+  __u64 processId;
+  __u32 sec_label_len;
+  char *sec_label;
+};
+int kdbus_NameQuery(const char *name, DBusTransport *transport, struct nameInfo *pInfo);
+dbus_bool_t kdbus_connection_get_unix_user(DBusConnection *connection, const char *name, unsigned long *uid, DBusError *error);
+dbus_bool_t kdbus_connection_get_unix_process_id(DBusConnection *connection, const char *name, unsigned long *uid, DBusError *error);
+
+dbus_bool_t register_kdbus_policy(const char *name, DBusTransport *transport, unsigned long int uid);
+int request_kdbus_name(int fd, const char *name, const __u64 flags, __u64 id);
+int release_kdbus_name(int fd, const char *name, __u64 id);
+
+#endif /* KDBUS_COMMON_H_ */
diff --git a/dbus/kdbus.h b/dbus/kdbus.h
new file mode 100644
index 0000000..8b44bbd
--- /dev/null
+++ b/dbus/kdbus.h
@@ -0,0 +1,857 @@
+/*
+ * Copyright (C) 2013 Kay Sievers
+ * Copyright (C) 2013 Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+ * Copyright (C) 2013 Linux Foundation
+ * Copyright (C) 2013 Lennart Poettering
+ * Copyright (C) 2013 Daniel Mack <daniel@zonque.org>
+ *
+ * kdbus is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU Lesser General Public License as published by the
+ * Free Software Foundation; either version 2.1 of the License, or (at
+ * your option) any later version.
+ */
+
+#ifndef _KDBUS_H_
+#define _KDBUS_H_
+
+#ifndef __KERNEL__
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <linux/types.h>
+#endif
+
+#define KDBUS_IOC_MAGIC			0x95
+#define KDBUS_SRC_ID_KERNEL		(0)
+#define KDBUS_DST_ID_NAME		(0)
+#define KDBUS_MATCH_SRC_ID_ANY		(~0ULL)
+#define KDBUS_DST_ID_BROADCAST		(~0ULL)
+
+/**
+ * struct kdbus_notify_name_change - name registry change message
+ * @old_id:		Former owner of a name
+ * @new_id:		New owner of a name
+ * @old_flags:		flags from KDBUS_NAME_* the name entry used to have
+ * @new_flags:		flags from KDBUS_NAME_* the name entry has now
+ * @name:		Well-known name
+ *
+ * Sent from kernel to userspace when the owner or activator of
+ * a well-known name changes.
+ *
+ * Attached to:
+ *   KDBUS_ITEM_NAME_ADD
+ *   KDBUS_ITEM_NAME_REMOVE
+ *   KDBUS_ITEM_NAME_CHANGE
+ */
+struct kdbus_notify_name_change {
+	__u64 old_id;
+	__u64 new_id;
+	__u64 old_flags;
+	__u64 new_flags;
+	char name[0];
+};
+
+/**
+ * struct kdbus_notify_id_change - name registry change message
+ * @id:			New or former owner of the name
+ * @flags:		flags field from KDBUS_HELLO_*
+ *
+ * Sent from kernel to userspace when the owner or activator of
+ * a well-known name changes.
+ *
+ * Attached to:
+ *   KDBUS_ITEM_ID_ADD
+ *   KDBUS_ITEM_ID_REMOVE
+ */
+struct kdbus_notify_id_change {
+	__u64 id;
+	__u64 flags;
+};
+
+/**
+ * struct kdbus_creds - process credentials
+ * @uid:		User ID
+ * @gid:		Group ID
+ * @pid:		Process ID
+ * @tid:		Thread ID
+ * @starttime:		Starttime of the process
+ *
+ * The starttime of the process PID. This is useful to detect PID overruns
+ * from the client side. i.e. if you use the PID to look something up in
+ * /proc/$PID/ you can afterwards check the starttime field of it, to ensure
+ * you didn't run into a PID overrun.
+ *
+ * Attached to:
+ *   KDBUS_ITEM_CREDS
+ */
+struct kdbus_creds {
+	__u64 uid;
+	__u64 gid;
+	__u64 pid;
+	__u64 tid;
+	__u64 starttime;
+};
+
+/**
+ * struct kdbus_audit - audit information
+ * @sessionid:		The audit session ID
+ * @loginuid:		The audit login uid
+ *
+ * Attached to:
+ *   KDBUS_ITEM_AUDIT
+ */
+struct kdbus_audit {
+	__u64 sessionid;
+	__u64 loginuid;
+};
+
+/**
+ * struct kdbus_timestamp
+ * @monotonic_ns:	Monotonic timestamp, in nanoseconds
+ * @realtime_ns:	Realtime timestamp, in nanoseconds
+ *
+ * Attached to:
+ *   KDBUS_ITEM_TIMESTAMP
+ */
+struct kdbus_timestamp {
+	__u64 monotonic_ns;
+	__u64 realtime_ns;
+};
+
+/**
+ * struct kdbus_vec - I/O vector for kdbus payload items
+ * @size:		The size of the vector
+ * @address:		Memory address for memory addresses
+ * @offset:		Offset in the in-message payload memory
+ *
+ * Attached to:
+ *   KDBUS_ITEM_PAYLOAD_VEC
+ */
+struct kdbus_vec {
+	__u64 size;
+	union {
+		__u64 address;
+		__u64 offset;
+	};
+};
+
+/**
+ * struct kdbus_memfd - a kdbus memfd
+ * @size:		The memfd's size
+ * @fd:			The file descriptor number
+ * @__pad:		Padding to make the struct aligned
+ *
+ * Attached to:
+ *   KDBUS_ITEM_PAYLOAD_MEMFD
+ */
+struct kdbus_memfd {
+	__u64 size;
+	int fd;
+	__u32 __pad;
+};
+
+/**
+ * struct kdbus_name - a registered well-known name with its flags
+ * @flags:		flags from KDBUS_NAME_*
+ * @name:		well-known name
+ *
+ * Attached to:
+ *   KDBUS_ITEM_NAME
+ */
+struct kdbus_name {
+	__u64 flags;
+	char name[0];
+};
+
+/**
+ * struct kdbus_policy_access - policy access item
+ * @type:		One of KDBUS_POLICY_ACCESS_* types
+ * @bits:		Access to grant. One of KDBUS_POLICY_*
+ * @id:			For KDBUS_POLICY_ACCESS_USER, the uid
+ * 			For KDBUS_POLICY_ACCESS_GROUP, the gid
+ *
+ * Embedded in:
+ *   struct kdbus_policy
+ */
+struct kdbus_policy_access {
+	__u64 type;	/* USER, GROUP, WORLD */
+	__u64 bits;	/* RECV, SEND, OWN */
+	__u64 id;	/* uid, gid, 0 */
+};
+
+/**
+ * struct kdbus_policy - a policy item
+ * @access:		Policy access details
+ * @name:		Well-known name to grant access to
+ *
+ * Attached to:
+ *   KDBUS_POLICY_ACCESS
+ *   KDBUS_ITEM_POLICY_NAME
+ */
+struct kdbus_policy {
+	union {
+		struct kdbus_policy_access access;
+		char name[0];
+	};
+};
+
+/**
+ * enum kdbus_item_type - item types to chain data in a list
+ * @KDBUS_ITEM_PAYLOAD_VEC:	Vector to data
+ * @KDBUS_ITEM_PAYLOAD_OFF:	Data at returned offset in the pool
+ * @KDBUS_ITEM_PAYLOAD_MEMFD:	Data as sealed memfd
+ * @KDBUS_ITEM_FDS:		Attached file descriptors
+ * @KDBUS_ITEM_BLOOM:		For broadcasts, carries bloom filter
+ * @KDBUS_ITEM_BLOOM_SIZE:	Desired bloom size, used by KDBUS_CMD_BUS_MAKE
+ * @KDBUS_ITEM_DST_NAME:	Destination's well-known name
+ * @KDBUS_ITEM_PRIORITY:	Queue priority for message
+ * @KDBUS_ITEM_MAKE_NAME:	Name of namespace, bus, endpoint
+ * @KDBUS_ITEM_POLICY_NAME:	Policy in struct kdbus_policy
+ * @KDBUS_ITEM_POLICY_ACCESS:	Policy in struct kdbus_policy
+ * @KDBUS_ITEM_NAME:		Well-know name with flags
+ * @KDBUS_ITEM_TIMESTAMP:	Timestamp
+ * @KDBUS_ITEM_CREDS:		Process credential
+ * @KDBUS_ITEM_PID_COMM:	Process ID "comm" identifier
+ * @KDBUS_ITEM_TID_COMM:	Thread ID "comm" identifier
+ * @KDBUS_ITEM_EXE:		The path of the executable
+ * @KDBUS_ITEM_CMDLINE:		The process command line
+ * @KDBUS_ITEM_CGROUP:		The croup membership
+ * @KDBUS_ITEM_CAPS:		The process capabilities
+ * @KDBUS_ITEM_SECLABEL:	The security label
+ * @KDBUS_ITEM_AUDIT:		The audit IDs
+ * @KDBUS_ITEM_NAME_ADD:	Notify in struct kdbus_notify_name_change
+ * @KDBUS_ITEM_NAME_REMOVE:	Notify in struct kdbus_notify_name_change
+ * @KDBUS_ITEM_NAME_CHANGE:	Notify in struct kdbus_notify_name_change
+ * @KDBUS_ITEM_ID_ADD:		Notify in struct kdbus_notify_id_change
+ * @KDBUS_ITEM_ID_REMOVE:	Notify in struct kdbus_notify_id_change
+ * @KDBUS_ITEM_REPLY_TIMEOUT:	Timeout has been reached
+ * @KDBUS_ITEM_REPLY_DEAD:	Destination died
+ */
+enum kdbus_item_type {
+	_KDBUS_ITEM_NULL,
+	_KDBUS_ITEM_USER_BASE,
+	KDBUS_ITEM_PAYLOAD_VEC	= _KDBUS_ITEM_USER_BASE,
+	KDBUS_ITEM_PAYLOAD_OFF,
+	KDBUS_ITEM_PAYLOAD_MEMFD,
+	KDBUS_ITEM_FDS,
+	KDBUS_ITEM_BLOOM,
+	KDBUS_ITEM_BLOOM_SIZE,
+	KDBUS_ITEM_DST_NAME,
+	KDBUS_ITEM_PRIORITY,
+	KDBUS_ITEM_MAKE_NAME,
+
+	_KDBUS_ITEM_POLICY_BASE	= 0x400,
+	KDBUS_ITEM_POLICY_NAME = _KDBUS_ITEM_POLICY_BASE,
+	KDBUS_ITEM_POLICY_ACCESS,
+
+	_KDBUS_ITEM_ATTACH_BASE	= 0x600,
+	KDBUS_ITEM_NAME		= _KDBUS_ITEM_ATTACH_BASE,
+	KDBUS_ITEM_TIMESTAMP,
+	KDBUS_ITEM_CREDS,
+	KDBUS_ITEM_PID_COMM,
+	KDBUS_ITEM_TID_COMM,
+	KDBUS_ITEM_EXE,
+	KDBUS_ITEM_CMDLINE,
+	KDBUS_ITEM_CGROUP,
+	KDBUS_ITEM_CAPS,
+	KDBUS_ITEM_SECLABEL,
+	KDBUS_ITEM_AUDIT,
+
+#ifdef KDBUS_FOR_SBB
+	KDBUS_ITEM_SBB_DST_NAME,		/* destination name for sbb agent purpose */
+	KDBUS_ITEM_SBB_BLOOM,
+#endif
+
+	_KDBUS_ITEM_KERNEL_BASE	= 0x800,
+	KDBUS_ITEM_NAME_ADD	= _KDBUS_ITEM_KERNEL_BASE,
+	KDBUS_ITEM_NAME_REMOVE,
+	KDBUS_ITEM_NAME_CHANGE,
+	KDBUS_ITEM_ID_ADD,
+	KDBUS_ITEM_ID_REMOVE,
+	KDBUS_ITEM_REPLY_TIMEOUT,
+	KDBUS_ITEM_REPLY_DEAD,
+};
+
+/**
+ * struct kdbus_item - chain of data blocks
+ * @size:		Overall data record size
+ * @type:		Kdbus_item type of data
+ * @data:		Generic bytes
+ * @data32:		Generic 32 bit array
+ * @data64:		Generic 64 bit array
+ * @str:		Generic string
+ * @id:			Connection ID
+ * @vec:		KDBUS_ITEM_PAYLOAD_VEC
+ * @creds:		KDBUS_ITEM_CREDS
+ * @audit:		KDBUS_ITEM_AUDIT
+ * @timestamp:		KDBUS_ITEM_TIMESTAMP
+ * @name:		KDBUS_ITEM_NAME
+ * @memfd:		KDBUS_ITEM_PAYLOAD_MEMFD
+ * @name_change:	KDBUS_ITEM_NAME_ADD
+ * 			KDBUS_ITEM_NAME_REMOVE
+ * 			KDBUS_ITEM_NAME_CHANGE
+ * @id_change:		KDBUS_ITEM_ID_ADD
+ * 			KDBUS_ITEM_ID_REMOVE
+ * @policy:		KDBUS_ITEM_POLICY_NAME
+ * 			KDBUS_ITEM_POLICY_ACCESS
+ */
+struct kdbus_item {
+	__u64 size;
+	__u64 type;
+	union {
+		__u8 data[0];
+		__u32 data32[0];
+		__u64 data64[0];
+		char str[0];
+
+		__u64 id;
+		struct kdbus_vec vec;
+		struct kdbus_creds creds;
+		struct kdbus_audit audit;
+		struct kdbus_timestamp timestamp;
+		struct kdbus_name name;
+		struct kdbus_memfd memfd;
+		int fds[0];
+		struct kdbus_notify_name_change name_change;
+		struct kdbus_notify_id_change id_change;
+		struct kdbus_policy policy;
+	};
+};
+
+/**
+ * enum kdbus_msg_flags - type of message
+ * @KDBUS_MSG_FLAGS_EXPECT_REPLY:	Expect a reply message, used for method
+ * 					calls. The cookie identifies the
+ * 					message and the respective reply
+ * @KDBUS_MSG_FLAGS_NO_AUTO_START:	Do not start a service, if the addressed
+ * 					name is not currently active
+ */
+enum kdbus_msg_flags {
+	KDBUS_MSG_FLAGS_EXPECT_REPLY	= 1 << 0,
+	KDBUS_MSG_FLAGS_NO_AUTO_START	= 1 << 1,
+};
+
+/**
+ * enum kdbus_payload_type - type of payload carried by message
+ * @KDBUS_PAYLOAD_KERNEL:	Kernel-generated simple message
+ * @KDBUS_PAYLOAD_DBUS:	        D-Bus marshalling
+ */
+enum kdbus_payload_type {
+	KDBUS_PAYLOAD_KERNEL,
+	KDBUS_PAYLOAD_DBUS	= 0x4442757344427573ULL, /* 'DBusDBus' */
+};
+
+/**
+ * struct kdbus_msg - the representation of a kdbus message
+ * @size:		Total size of the message
+ * @flags:		Message flags (KDBUS_MSG_FLAGS_*)
+ * @dst_id:		64-bit ID of the destination connection
+ * @src_id:		64-bit ID of the source connection
+ * @payload_type:	Payload type (KDBUS_PAYLOAD_*)
+ * @cookie:		Userspace-supplied cookie
+ * @cookie_reply:	For kernel-generated messages, this is the cookie
+ * 			the message is a reply to
+ * @timeout_ns:		For non-kernel-generated messages, this denotes the
+ * 			message timeout in nanoseconds. A message has to be
+ * 			received with KDBUS_CMD_MSG_RECV by the destination
+ * 			connection within this time frame. For messages that
+ * 			have KDBUS_MSG_FLAGS_EXPECT_REPLY set in @flags,
+ * 			this value also denotes the timeout for the reply to
+ * 			this message. If there is no reply, or the message is
+ * 			not received in time by the other side, a
+ * 			kernel-generated message with an attached
+ * 			KDBUS_ITEM_REPLY_TIMEOUT item is sent to @src_id.
+ * 			A 0-value is only valid if KDBUS_MSG_FLAGS_EXPECT_REPLY
+ * 			is unset in @flags.
+ * @items:		A list of kdbus_items containing the message payload
+ */
+struct kdbus_msg {
+	__u64 size;
+	__u64 flags;
+	__u64 dst_id;
+	__u64 src_id;
+	__u64 payload_type;
+	__u64 cookie;
+	union {
+		__u64 cookie_reply;
+		__u64 timeout_ns;
+	};
+	struct kdbus_item items[0];
+} __attribute__((aligned(8)));
+
+/**
+ * enum kdbus_policy_access_type - permissions of a policy record
+ * @KDBUS_POLICY_ACCESS_USER:	Grant access to a uid
+ * @KDBUS_POLICY_ACCESS_GROUP:	Grant access to gid
+ * @KDBUS_POLICY_ACCESS_WORLD:	World-accessible
+ */
+enum kdbus_policy_access_type {
+	_KDBUS_POLICY_ACCESS_NULL,
+	KDBUS_POLICY_ACCESS_USER,
+	KDBUS_POLICY_ACCESS_GROUP,
+	KDBUS_POLICY_ACCESS_WORLD,
+};
+
+/**
+ * enum kdbus_policy_access_flags - mode flags
+ * @KDBUS_POLICY_RECV:		Allow receive
+ * @KDBUS_POLICY_SEND:		Allow send
+ * @KDBUS_POLICY_OWN:		Allow to own a well-known name
+ */
+enum kdbus_policy_type {
+	KDBUS_POLICY_RECV		= 1 <<  2,
+	KDBUS_POLICY_SEND		= 1 <<  1,
+	KDBUS_POLICY_OWN		= 1 <<  0,
+};
+
+/**
+ * struct kdbus_cmd_policy - a series of policies to upload
+ * @size:		The total size of the structure
+ * @policies:		The policies to upload
+ *
+ * A KDBUS_POLICY_NAME must always preceeds a KDBUS_POLICY_ACCESS entry.
+ * A new KDBUS_POLICY_NAME can be added after KDBUS_POLICY_ACCESS for
+ * chaining multiple policies together.
+ */
+struct kdbus_cmd_policy {
+	__u64 size;
+	struct kdbus_item policies[0];
+} __attribute__((aligned(8)));
+
+/**
+ * enum kdbus_hello_flags - flags for struct kdbus_cmd_hello
+ * @KDBUS_HELLO_ACCEPT_FD:	The connection allows the receiving of
+ * 				any passed file descriptors
+ * @KDBUS_HELLO_ACTIVATOR:	Special-purpose connection which registers
+ * 				a well-know name for a process to be started
+ * 				when traffic arrives
+ * @KDBUS_HELLO_MONITOR:	Special-purpose connection to monitor
+ * 				bus traffic
+ */
+enum kdbus_hello_flags {
+	KDBUS_HELLO_ACCEPT_FD		=  1 <<  0,
+	KDBUS_HELLO_ACTIVATOR		=  1 <<  1,
+	KDBUS_HELLO_MONITOR		=  1 <<  2,
+#ifdef KDBUS_FOR_SBB
+	/*Flags for SBB*/
+	KDBUS_HELLO_IAMAGENT		=  1 << 30,
+#endif
+
+};
+
+/**
+ * enum kdbus_attach_flags - flags for metadata attachments
+ * @KDBUS_ATTACH_TIMESTAMP:	Timestamp
+ * @KDBUS_ATTACH_CREDS:		Credentials
+ * @KDBUS_ATTACH_NAMES:		Well-known names
+ * @KDBUS_ATTACH_COMM:		The "comm" process identifier
+ * @KDBUS_ATTACH_EXE:		The path of the executable
+ * @KDBUS_ATTACH_CMDLINE:	The process command line
+ * @KDBUS_ATTACH_CGROUP:	The croup membership
+ * @KDBUS_ATTACH_CAPS:		The process capabilities
+ * @KDBUS_ATTACH_SECLABEL:	The security label
+ * @KDBUS_ATTACH_AUDIT:		The audit IDs
+ */
+enum kdbus_attach_flags {
+	KDBUS_ATTACH_TIMESTAMP		=  1 <<  0,
+	KDBUS_ATTACH_CREDS		=  1 <<  1,
+	KDBUS_ATTACH_NAMES		=  1 <<  2,
+	KDBUS_ATTACH_COMM		=  1 <<  3,
+	KDBUS_ATTACH_EXE		=  1 <<  4,
+	KDBUS_ATTACH_CMDLINE		=  1 <<  5,
+	KDBUS_ATTACH_CGROUP		=  1 <<  6,
+	KDBUS_ATTACH_CAPS		=  1 <<  7,
+	KDBUS_ATTACH_SECLABEL		=  1 <<  8,
+	KDBUS_ATTACH_AUDIT		=  1 <<  9,
+};
+
+/**
+ * struct kdbus_cmd_hello - struct to say hello to kdbus
+ * @size:		The total size of the structure
+ * @conn_flags:		Connection flags (KDBUS_HELLO_*). The kernel will
+ * 			return its capabilities in that field.
+ * @attach_flags:	Mask of metadata to attach to each message sent
+ * 			(KDBUS_ATTACH_*)
+ * @bus_flags:		The flags field copied verbatim from the original
+ * 			KDBUS_CMD_BUS_MAKE ioctl. It's intended to be useful
+ *			to do negotiation of features of the payload that is
+ *			transferred (kernel → userspace)
+ * @id:			The ID of this connection (kernel → userspace)
+ * @bloom_size:		The bloom filter size chosen by the owner
+ * 			(kernel → userspace)
+ * @pool_size:		Maximum size of the pool buffer (kernel → userspace)
+ * @id128:		Unique 128-bit ID of the bus (kernel → userspace)
+ * @items:		A list of items
+ *
+ * This struct is used with the KDBUS_CMD_HELLO ioctl. See the ioctl
+ * documentation for more information.
+ */
+struct kdbus_cmd_hello {
+	__u64 size;
+	__u64 conn_flags;
+	__u64 attach_flags;
+	__u64 bus_flags;
+	__u64 id;
+	__u64 bloom_size;
+	__u64 pool_size;
+	__u8 id128[16];
+	struct kdbus_item items[0];
+} __attribute__((aligned(8)));
+
+/* Flags for KDBUS_CMD_{BUS,EP,NS}_MAKE */
+enum kdbus_make_flags {
+	KDBUS_MAKE_ACCESS_GROUP		= 1 <<  0,
+	KDBUS_MAKE_ACCESS_WORLD		= 1 <<  1,
+	KDBUS_MAKE_POLICY_OPEN		= 1 <<  2,
+
+#ifdef KDBUS_FOR_SBB
+	KDBUS_MAKE_SBB_OFFSET		= (__u64)1 << 31,
+#endif
+};
+
+/**
+ * struct kdbus_cmd_make - struct to make a bus, an endpoint or a namespace
+ * @size:		The total size of the struct
+ * @flags:		Properties for the bus/ep/ns to create
+ * @items:		Items describing details
+ *
+ * This structure is used with the KDBUS_CMD_BUS_MAKE, KDBUS_CMD_EP_MAKE and
+ * KDBUS_CMD_NS_MAKE ioctls.
+ */
+struct kdbus_cmd_make {
+	__u64 size;
+	__u64 flags;
+	struct kdbus_item items[0];
+} __attribute__((aligned(8)));
+
+/**
+ * enum kdbus_name_flags - properties of a well-known name
+ * @KDBUS_NAME_REPLACE_EXISTING:	Try to replace name of other connections
+ * @KDBUS_NAME_ALLOW_REPLACEMENT:	Allow the replacement of the name
+ * @KDBUS_NAME_QUEUE:			Name should be queued if busy
+ * @KDBUS_NAME_IN_QUEUE:		Name is queued
+ * @KDBUS_NAME_ACTIVATOR:		Name is owned by a activator connection
+ */
+enum kdbus_name_flags {
+	KDBUS_NAME_REPLACE_EXISTING		= 1 <<  0,
+	KDBUS_NAME_ALLOW_REPLACEMENT		= 1 <<  1,
+	KDBUS_NAME_QUEUE			= 1 <<  2,
+	KDBUS_NAME_IN_QUEUE			= 1 <<  3,
+	KDBUS_NAME_ACTIVATOR			= 1 <<  4,
+	KDBUS_NAME_STARTER_NAME			= 1 <<  7,
+};
+
+/**
+ * struct kdbus_cmd_name - struct to describe a well-known name
+ * @size:		The total size of the struct
+ * @flags:		Flags for a name entry (KDBUS_NAME_*)
+ * @id:			Privileged users may use this field to (de)register
+ * 			names on behalf of other peers.
+ * @conn_flags:		The flags of the owning connection (KDBUS_HELLO_*)
+ * @name:		The well-known name
+ *
+ * This structure is used with the KDBUS_CMD_NAME_ACQUIRE ioctl.
+ */
+struct kdbus_cmd_name {
+	__u64 size;
+	__u64 flags;
+	__u64 id;
+	__u64 conn_flags;
+	char name[0];
+} __attribute__((aligned(8)));
+
+/**
+ * enum kdbus_name_list_flags - what to include into the returned list
+ * @KDBUS_NAME_LIST_UNIQUE:	All active connections
+ * @KDBUS_NAME_LIST_NAMES:	All known well-known names
+ * @KDBUS_NAME_LIST_ACTIVATORS:	All activator connections
+ * @KDBUS_NAME_LIST_QUEUED:	All queued-up names
+ */
+enum kdbus_name_list_flags {
+	KDBUS_NAME_LIST_UNIQUE		= 1 <<  0,
+	KDBUS_NAME_LIST_NAMES		= 1 <<  1,
+	KDBUS_NAME_LIST_ACTIVATORS	= 1 <<  2,
+	KDBUS_NAME_LIST_QUEUED		= 1 <<  3,
+};
+
+/**
+ * struct kdbus_cmd_name_list - request a list of name entries
+ * @flags:		Flags for the query (KDBUS_NAME_LIST_*)
+ * @offset:		The returned offset in the caller's pool buffer.
+ *			The user must use KDBUS_CMD_FREE to free the
+ *			allocated memory.
+ *
+ * This structure is used with the KDBUS_CMD_NAME_LIST ioctl.
+ */
+struct kdbus_cmd_name_list {
+	__u64 flags;
+	__u64 offset;
+} __attribute__((aligned(8)));
+
+/**
+ * struct kdbus_name_list - information returned by KDBUS_CMD_NAME_LIST
+ * @size:		The total size of the structure
+ * @names:		A list of names
+ *
+ * Note that the user is responsible for freeing the allocated memory with
+ * the KDBUS_CMD_FREE ioctl.
+ */
+struct kdbus_name_list {
+	__u64 size;
+	struct kdbus_cmd_name names[0];
+};
+
+/**
+ * struct kdbus_cmd_conn_info - struct used for KDBUS_CMD_CONN_INFO ioctl
+ * @size:		The total size of the struct
+ * @flags:		KDBUS_ATTACH_* flags
+ * @id:			The 64-bit ID of the connection. If set to zero, passing
+ * 			@name is required. kdbus will look up the name to determine
+ * 			the ID in this case.
+ * @offset:		Returned offset in the caller's pool buffer where the
+ * 			kdbus_conn_info struct result is stored. The user must
+ * 			use KDBUS_CMD_FREE to free the allocated memory.
+ * @name:		The optional well-known name to look up. Only needed in
+ * 			case @id is zero.
+ *
+ * On success, the KDBUS_CMD_CONN_INFO ioctl will return 0 and @offset will
+ * tell the user the offset in the connection pool buffer at which to find the
+ * result in a struct kdbus_conn_info.
+ */
+struct kdbus_cmd_conn_info {
+	__u64 size;
+	__u64 flags;
+	__u64 id;
+	__u64 offset;
+	char name[0];
+} __attribute__((aligned(8)));
+
+/**
+ * struct kdbus_conn_info - information returned by KDBUS_CMD_CONN_INFO
+ * @size:		The total size of the struct
+ * @id:			The connection's 64-bit ID
+ * @flags:		The connection's flags
+ * @items:		A list of struct kdbus_item
+ *
+ * Note that the user is responsible for freeing the allocated memory with
+ * the KDBUS_CMD_FREE ioctl.
+ */
+struct kdbus_conn_info {
+	__u64 size;
+	__u64 id;
+	__u64 flags;
+	struct kdbus_item items[0];
+};
+
+/**
+ * enum kdbus_match_type - type of match record
+ * @KDBUS_MATCH_BLOOM:		Matches against KDBUS_MSG_BLOOM
+ * @KDBUS_MATCH_SRC_NAME:	Matches a name string
+ * @KDBUS_MATCH_NAME_ADD:	Matches a name string
+ * @KDBUS_MATCH_NAME_REMOVE:	Matches a name string
+ * @KDBUS_MATCH_NAME_CHANGE:	Matches a name string
+ * @KDBUS_MATCH_ID_ADD:		Matches an ID
+ * @KDBUS_MATCH_ID_REMOVE:	Matches an ID
+ */
+enum kdbus_match_type {
+	_KDBUS_MATCH_NULL,
+	KDBUS_MATCH_BLOOM,
+	KDBUS_MATCH_SRC_NAME,
+	KDBUS_MATCH_NAME_ADD,
+	KDBUS_MATCH_NAME_REMOVE,
+	KDBUS_MATCH_NAME_CHANGE,
+	KDBUS_MATCH_ID_ADD,
+	KDBUS_MATCH_ID_REMOVE,
+};
+
+/**
+ * struct kdbus_cmd_match - struct to add or remove matches
+ * @size:		The total size of the struct
+ * @id:			Privileged users may (de)register matches on behalf
+ * 			of other peers. In other cases, set to 0.
+ * @cookie:		Userspace supplied cookie. When removing, the cookie
+ * 			identifies the match to remove.
+ * @src_id:		The source ID to match against. Use
+ * 			KDBUS_MATCH_SRC_ID_ANY or any other value for a unique
+ * 			match.
+ * @items:		A list of items for additional information
+ *
+ * This structure is used with the KDBUS_CMD_ADD_MATCH and
+ * KDBUS_CMD_REMOVE_MATCH ioctl.
+ */
+struct kdbus_cmd_match {
+	__u64 size;
+	__u64 id;
+	__u64 cookie;
+	__u64 src_id;
+	struct kdbus_item items[0];
+} __attribute__((aligned(8)));
+
+/**
+ * enum kdbus_ioctl_type - Ioctl API
+ * @KDBUS_CMD_BUS_MAKE:		After opening the "control" device node, this
+ * 				command creates a new bus with the specified
+ * 				name. The bus is immediately shut down and
+ * 				cleaned up when the opened "control" device node
+ * 				is closed.
+ * @KDBUS_CMD_NS_MAKE:		Similar to KDBUS_CMD_BUS_MAKE, but it creates a
+ * 				new kdbus namespace.
+ * @KDBUS_CMD_EP_MAKE:		Creates a new named special endpoint to talk to
+ * 				the bus. Such endpoints usually carry a more
+ * 				restrictive policy and grant restricted access
+ * 				to specific applications.
+ * @KDBUS_CMD_HELLO:		By opening the bus device node a connection is
+ * 				created. After a HELLO the opened connection
+ * 				becomes an active peer on the bus.
+ * @KDBUS_CMD_MSG_SEND:		Send a message and pass data from userspace to
+ * 				the kernel.
+ * @KDBUS_CMD_MSG_RECV:		Receive a message from the kernel which is
+ * 				placed in the receiver's pool.
+ * @KDBUS_CMD_FREE:		Release the allocated memory in the receiver's
+ * 				pool.
+ * @KDBUS_CMD_DROP:		Drop and free the next queued message and all
+ * 				its ressources without actually receiveing it.
+ * @KDBUS_CMD_SRC:		Return the sender's connection ID of the next
+ * 				queued message.
+ * @KDBUS_CMD_NAME_ACQUIRE:	Request a well-known bus name to associate with
+ * 				the connection. Well-known names are used to
+ * 				address a peer on the bus.
+ * @KDBUS_CMD_NAME_RELEASE:	Release a well-known name the connection
+ * 				currently owns.
+ * @KDBUS_CMD_NAME_LIST:	Retrieve the list of all currently registered
+ * 				well-known and unique names.
+ * @KDBUS_CMD_CONN_INFO:	Retrieve credentials and properties of the
+ * 				initial creator of the connection. The data was
+ * 				stored at registration time and does not
+ * 				necessarily represent the connected process or
+ * 				the actual state of the process.
+ * @KDBUS_CMD_MATCH_ADD:	Install a match which broadcast messages should
+ * 				be delivered to the connection.
+ * @KDBUS_CMD_MATCH_REMOVE:	Remove a current match for broadcast messages.
+ * @KDBUS_CMD_EP_POLICY_SET:	Set the policy of an endpoint. It is used to
+ * 				restrict the access for endpoints created with
+ * 				KDBUS_CMD_EP_MAKE.
+ * @KDBUS_CMD_MEMFD_NEW:	Return a new file descriptor which provides an
+ * 				anonymous shared memory file and which can be
+ * 				used to pass around larger chunks of data.
+ * 				Kdbus memfd files can be sealed, which allows
+ * 				the receiver to trust the data it has received.
+ * 				Kdbus memfd files expose only very limited
+ * 				operations, they can be mmap()ed, seek()ed,
+ * 				(p)read(v)() and (p)write(v)(); most other
+ * 				common file operations are not implemented.
+ * 				Special caution needs to be taken with
+ * 				read(v)()/write(v)() on a shared file; the
+ * 				underlying file position is always shared
+ * 				between all users of the file and race against
+ * 				each other, pread(v)()/pwrite(v)() avoid these
+ * 				issues.
+ * @KDBUS_CMD_MEMFD_SIZE_GET:	Return the size of the underlying file, which
+ * 				changes with write().
+ * @KDBUS_CMD_MEMFD_SIZE_SET:	Truncate the underlying file to the specified
+ * 				size.
+ * @KDBUS_CMD_MEMFD_SEAL_GET:	Return the state of the file sealing.
+ * @KDBUS_CMD_MEMFD_SEAL_SET:	Seal or break a seal of the file. Only files
+ * 				which are not shared with other processes and
+ * 				which are currently not mapped can be sealed.
+ * 				The current process needs to be the one and
+ * 				single owner of the file, the sealing cannot
+ * 				be changed as long as the file is shared.
+ */
+enum kdbus_ioctl_type {
+	KDBUS_CMD_BUS_MAKE =		_IOW (KDBUS_IOC_MAGIC, 0x00, struct kdbus_cmd_make),
+	KDBUS_CMD_NS_MAKE =		_IOR (KDBUS_IOC_MAGIC, 0x10, struct kdbus_cmd_make),
+	KDBUS_CMD_EP_MAKE =		_IOW (KDBUS_IOC_MAGIC, 0x20, struct kdbus_cmd_make),
+
+	KDBUS_CMD_HELLO =		_IOWR(KDBUS_IOC_MAGIC, 0x30, struct kdbus_cmd_hello),
+
+	KDBUS_CMD_MSG_SEND =		_IOW (KDBUS_IOC_MAGIC, 0x40, struct kdbus_msg),
+	KDBUS_CMD_MSG_RECV =		_IOR (KDBUS_IOC_MAGIC, 0x41, __u64 *),
+	KDBUS_CMD_FREE =		_IOW (KDBUS_IOC_MAGIC, 0x42, __u64 *),
+	KDBUS_CMD_MSG_DROP =		_IO  (KDBUS_IOC_MAGIC, 0x43),
+	KDBUS_CMD_MSG_SRC =		_IOR (KDBUS_IOC_MAGIC, 0x44, __u64 *),
+
+	KDBUS_CMD_NAME_ACQUIRE =	_IOWR(KDBUS_IOC_MAGIC, 0x50, struct kdbus_cmd_name),
+	KDBUS_CMD_NAME_RELEASE =	_IOW (KDBUS_IOC_MAGIC, 0x51, struct kdbus_cmd_name),
+	KDBUS_CMD_NAME_LIST =		_IOWR(KDBUS_IOC_MAGIC, 0x52, struct kdbus_cmd_name_list),
+	KDBUS_CMD_NAME_LIST_QUEUED = _IOWR(KDBUS_IOC_MAGIC, 0x58, struct kdbus_cmd_conn_info),
+
+	KDBUS_CMD_CONN_INFO =		_IOWR(KDBUS_IOC_MAGIC, 0x60, struct kdbus_cmd_conn_info),
+
+	KDBUS_CMD_MATCH_ADD =		_IOW (KDBUS_IOC_MAGIC, 0x70, struct kdbus_cmd_match),
+	KDBUS_CMD_MATCH_REMOVE =	_IOW (KDBUS_IOC_MAGIC, 0x71, struct kdbus_cmd_match),
+
+	KDBUS_CMD_EP_POLICY_SET =	_IOW (KDBUS_IOC_MAGIC, 0x80, struct kdbus_cmd_policy),
+
+	KDBUS_CMD_MEMFD_NEW =		_IOR (KDBUS_IOC_MAGIC, 0x90, int *),
+	KDBUS_CMD_MEMFD_SIZE_GET =	_IOR (KDBUS_IOC_MAGIC, 0x91, __u64 *),
+	KDBUS_CMD_MEMFD_SIZE_SET =	_IOW (KDBUS_IOC_MAGIC, 0x92, __u64 *),
+	KDBUS_CMD_MEMFD_SEAL_GET =	_IOR (KDBUS_IOC_MAGIC, 0x93, int *),
+	KDBUS_CMD_MEMFD_SEAL_SET =	_IO  (KDBUS_IOC_MAGIC, 0x94),
+};
+
+#ifdef KDBUS_FOR_SBB
+#define SBB_AGENT_ID_MASK		((__u64)1 << 63)
+//FIXME KDBUS_DST_ID_BROADCAST has "remote" mask
+#endif
+
+/*
+ * errno - api error codes
+ * @E2BIG:		A message contains too many records or items.
+ * @EADDRINUSE:		A well-known bus name is already taken by another
+ * 			connection.
+ * @EADDRNOTAVAIL:	A message flagged not to activate a service, addressed
+ * 			a service which is not currently running.
+ * @EAGAIN:		No messages are queued at the moment.
+ * @EBADF:		File descriptors passed with the message are not valid.
+ * @EBADFD:		A bus connection is in a corrupted state.
+ * @EBADMSG:		Passed data contains a combination of conflicting or
+ * 			inconsistent types.
+ * @ECONNRESET:		A connection is shut down, no further operations are
+ * 			possible.
+ * @ECOMM:		A peer does not accept the file descriptors addressed
+ * 			to it.
+ * @EDESTADDRREQ:	The well-known bus name is required but missing.
+ * @EDOM:		The size of data does not match the expectations. Used
+ * 			for the size of the bloom filter bit field.
+ * @EEXIST:		A requested namespace, bus or endpoint with the same
+ * 			name already exists.  A specific data type, which is
+ * 			only expected once, is provided multiple times.
+ * @EFAULT:		The supplied memory could not be accessed, or the data
+ * 			is not properly aligned.
+ * @EINVAL:		The provided data does not match its type or other
+ * 			expectations, like a string which is not NUL terminated,
+ * 			or a string length that points behind the first
+ * 			\0-byte in the string.
+ * @EMEDIUMTYPE:	A file descriptor which is not a kdbus memfd was
+ * 			refused to send as KDBUS_MSG_PAYLOAD_MEMFD.
+ * @EMFILE:		Too many file descriptors have been supplied with a
+ * 			message.
+ * @EMSGSIZE:		The supplied data is larger than the allowed maximum
+ * 			size.
+ * @ENAMETOOLONG:	The requested name is larger than the allowed maximum
+ * 			size.
+ * @ENOBUFS:		There is no space left for the submitted data to fit
+ * 			into the receiver's pool.
+ * @ENOMEM:		Out of memory.
+ * @ENOSYS:		The requested functionality is not available.
+ * @ENOTCONN:		The addressed peer is not an active connection.
+ * @ENOTSUPP:		The feature negotiation failed, a not supported feature
+ * 			was requested, or an unknown item type was received.
+ * @ENOTTY:		An unknown ioctl command was received.
+ * @ENOTUNIQ:		A specific data type was addressed to a broadcast
+ * 			address, but only direct addresses support this kind of
+ * 			data.
+ * @ENXIO:		A unique address does not exist, or an offset in the
+ * 			receiver's pool does not represent a queued message.
+ * @EPERM:		The policy prevented an operation. The requested
+ * 			resource is owned by another entity.
+ * @ESHUTDOWN:		A namespace or endpoint is currently shutting down;
+ * 			no further operations will be possible.
+ * @ESRCH:		A requested well-known bus name is not found.
+ * @ETXTBSY:		A kdbus memfd file cannot be sealed or the seal removed,
+ * 			because it is shared with other processes or still
+ * 			mmap()ed.
+ * @EXFULL:		The size limits in the pool are reached, no data of
+ * 			the size tried to submit can be queued.
+ */
+#endif
diff --git a/doc-kdbus/HOWTO.txt b/doc-kdbus/HOWTO.txt
new file mode 100644
index 0000000..4b2ba89
--- /dev/null
+++ b/doc-kdbus/HOWTO.txt
@@ -0,0 +1,62 @@
+IMPORTANT!!!
+------------
+Modified version of kdbus (from tizen.org) is required to run kdbus transport in dbus.
+
+
+
+
+kdbus-root : directory where kdbus project is
+dbus-root  : directory where dbus project is
+
+
+----------KDBUS----------
+
+[Build kdbus project]
+#cd /kdbus-root/
+#make
+
+[Load kdbus kernel module]
+#sudo insmod kdbus.ko
+
+
+----------LIBDBUS--------
+
+[Build libdbus project]
+#./autogen.sh --enable-kdbus-transport
+(resolve missing dependencies)
+#make
+
+[Run custom dbus-daemon]
+#dbus-root/bus/dbus-daemon --config-file=/etc/dbus-1/session.conf --address=kdbus:
+
+[Check if kdbus bus is created and has permissions to read-write]
+#ls -la /dev/kdbus/`id -u`-kdbus/bus
+
+[Set variable to use custom library instead of system one]
+#export LD_LIBRARY_PATH=/dbus-root/dbus/.libs/
+
+[Set variable to use kdbus as session bus]
+#export DBUS_SESSION_BUS_ADDRESS=kdbus:path=/dev/kdbus/`id -u`-kdbus/bus
+
+----------TEST -----------
+
+[Build test binaries]
+#cd /dbus-root/samsung_tools
+#make
+
+[Check if test binary correctly links custom libdbus]
+#ldd ping-server
+
+[Run test binary server in terminal 1]
+#./ping-server
+
+[Run test binary client in terminal 2]
+#./ping-client
+
+-------OPTIONAL--------
+
+[set variable to see debug info]
+[Build libdbus project]
+#./autogen.sh --enable-kdbus-transport --enable-verbose-mode
+#make
+#export DBUS_VERBOSE=1
diff --git a/doc-kdbus/kdbus_transport_for_dbus.pdf b/doc-kdbus/kdbus_transport_for_dbus.pdf
new file mode 100644
index 0000000..f4fe9b3
Binary files /dev/null and b/doc-kdbus/kdbus_transport_for_dbus.pdf differ
diff --git a/doc-kdbus/status.txt b/doc-kdbus/status.txt
new file mode 100644
index 0000000..d76db1c
--- /dev/null
+++ b/doc-kdbus/status.txt
@@ -0,0 +1,30 @@
+Status given below covers intentional coding progress. Extensive testing and bug
+fixing is still ahead.
+
+Please observe known limitations in architecture desciption.
+
+
+
+2013-10-23
+----------
+* Modified libdbus – 100%
+  All expected functions are already there. Code is confirmed to work on x86
+  and ARM.
+
+* Modified libgio – 80%
+  First working code is available (tested on x86 and ARM), however it has to
+  be cleaned a bit before upload.
+
+* DBus daemon – 100%
+  Accompanying tools (like dbus-launch) have to be reviewed and adjusted
+  if necessary. Code is successfully tested on both x86 and ARM.
+
+* Kdbus – 100%
+  Possibility to run on 3.8.2 kernel is provided. Code is successfully tested
+  on both x86 and ARM.
+
+
+2013-10-28
+----------
+* Modified libgio – 90%
+  Code uploaded.
diff --git a/packaging/conf_dbus.tar.gz b/packaging/conf_dbus.tar.gz
new file mode 100644
index 0000000..45ddebc
Binary files /dev/null and b/packaging/conf_dbus.tar.gz differ
diff --git a/packaging/conf_kdbus.tar.gz b/packaging/conf_kdbus.tar.gz
new file mode 100644
index 0000000..6cdbd2c
Binary files /dev/null and b/packaging/conf_kdbus.tar.gz differ
diff --git a/packaging/dbus-user.service b/packaging/dbus-user.service
new file mode 100644
index 0000000..cd1358e
--- /dev/null
+++ b/packaging/dbus-user.service
@@ -0,0 +1,13 @@
+
+#
+# This is the D-Bus service for the session
+#
+
+[Unit]
+Description=D-Bus Session Message Bus
+Requires=dbus.socket
+
+[Service]
+ExecStart=/usr/bin/dbus-daemon --session --address=systemd: --nofork --systemd-activation
+ExecReload=/usr/bin/dbus-send --print-reply --session --type=method_call --dest=org.freedesktop.DBus / org.freedesktop.DBus.ReloadConfig
+OOMScoreAdjust=-850
diff --git a/packaging/dbus-user.socket b/packaging/dbus-user.socket
new file mode 100644
index 0000000..06b01a5
--- /dev/null
+++ b/packaging/dbus-user.socket
@@ -0,0 +1,10 @@
+
+#
+# This is the D-Bus socket for the session bus
+#
+
+[Unit]
+Description=D-Bus Session Message Bus Socket
+
+[Socket]
+ListenStream=%t/dbus/user_bus_socket
diff --git a/packaging/dbus.spec b/packaging/dbus.spec
new file mode 100644
index 0000000..04c0783
--- /dev/null
+++ b/packaging/dbus.spec
@@ -0,0 +1,144 @@
+Name:		dbus
+Summary:	D-Bus message bus with kdbus support
+Version:	1.7.5+tv+kdbus
+Release:	1
+Group:		System/Libraries
+License:	GPLv2+ or AFL
+Source0:    	%{name}-%{version}.tar.gz
+Source2:	dbus-user.socket
+Source3:	dbus-user.service
+Source4:	system.conf
+Source5:	switch-to-dbus.sh
+Source6:	switch-to-kdbus.sh
+Source7:	conf_dbus.tar.gz
+Source8:	conf_kdbus.tar.gz
+BuildRequires:  which
+BuildRequires:  expat-devel
+BuildRequires:  libtool
+BuildRequires:  openssl-devel
+BuildRequires:  pkgconfig(x11)
+
+
+%description
+D-Bus message bus with kdbus support
+
+%package libs
+Summary:    Libraries for accessing D-Bus
+Group:      System/Libraries
+#FIXME: This is circular dependency
+Requires:   %{name} = %{version}-%{release}
+
+%description libs
+Lowlevel libraries for accessing D-Bus.
+
+%package devel
+Summary:    Libraries and headers for D-Bus
+Group:      Development/Libraries
+Requires:   %{name} = %{version}-%{release}
+Requires:   pkgconfig
+
+%description devel
+Headers and static libraries for D-Bus.
+
+%prep
+%setup -q -n %{name}-%{version}
+
+
+%build
+./autogen.sh --enable-abstract-sockets --enable-x11-autolaunch --with-x \
+    --enable-kdbus-transport \
+    --enable-kdbus-for-sbb \
+    --disable-static \
+    --exec-prefix=/ \
+    --bindir=%{_bindir} \
+    --libexecdir=%{_libdir}/dbus-1 \
+    --sysconfdir=%{_sysconfdir} \
+    --libdir=%{_libdir} \
+    --includedir=%{_includedir} \
+    --localstatedir=%{_localstatedir} \
+    --docdir=%{_docdir} \
+    --disable-asserts \
+    --disable-xml-docs \
+    --disable-selinux \
+    --disable-libaudit \
+    --enable-tests=no \
+    --with-system-pid-file=%{_localstatedir}/run/messagebus.pid \
+    --with-dbus-user=root \
+    --with-systemdsystemunitdir=%{_libdir}/systemd/system
+
+# When compiled using gbs with --enable-abstract-sockets param autogen.sh creates a config.h in
+# /GBS-ROOT/local/BUILD-ROOTS/scratch.armv7l.0 with # /* #undef HAVE_ABSTRACT_SOCKETS */.
+# Code changes it to #define HAVE_ABSTRACT_SOCKETS 1.
+if grep -q "#define HAVE_ABSTRACT_SOCKETS\s1" config.h; then
+	echo HAVE_ABSTRACT_SOCKETS found.
+else
+	echo HAVE_ABSTRACT_SOCKETS not found. Adding it.
+	sed -i 's/\/\* #undef HAVE_ABSTRACT_SOCKETS \*\//#define HAVE_ABSTRACT_SOCKETS 1/' config.h
+fi
+
+make %{?jobs:-j%jobs}
+
+%install
+%make_install
+%remove_docs
+
+install -m644 %{SOURCE4} %{buildroot}/etc/dbus-1/system.conf.systemd
+install -m644 %{SOURCE4} %{buildroot}/etc/dbus-1/system.conf
+
+mkdir -p %{buildroot}%{_libdir}/pkgconfig
+# Change the arch-deps.h include directory to /usr/lib instead of /lib
+sed -e 's@-I${libdir}@-I${prefix}/%{_lib}@' %{buildroot}%{_libdir}/pkgconfig/dbus-1.pc
+
+mkdir -p %{buildroot}%{_datadir}/dbus-1/interfaces
+
+mkdir -p %{buildroot}%{_libdir}/systemd/user
+install -m0644 %{SOURCE2} %{buildroot}%{_libdir}/systemd/user/dbus.socket
+install -m0644 %{SOURCE3} %{buildroot}%{_libdir}/systemd/user/dbus.service
+
+install -m0755 %{SOURCE5} %{buildroot}%{_bindir}/switch-to-dbus.sh
+install -m0755 %{SOURCE6} %{buildroot}%{_bindir}/switch-to-kdbus.sh
+
+tar -xvzf %{SOURCE7} -C %{buildroot}/etc/dbus-1
+tar -xvzf %{SOURCE8} -C %{buildroot}/etc/dbus-1
+
+%post
+mkdir -p /opt/var/lib/dbus
+
+%post libs -p /sbin/ldconfig
+
+%postun libs -p /sbin/ldconfig
+
+%files
+%{_bindir}/dbus-cleanup-sockets
+%{_bindir}/dbus-daemon
+%{_bindir}/dbus-monitor
+%{_bindir}/dbus-send
+%{_bindir}/dbus-uuidgen
+%{_bindir}/dbus-launch
+%{_bindir}/dbus-run-session
+%dir %{_sysconfdir}/dbus-1
+%config(noreplace) %{_sysconfdir}/dbus-1/session.conf
+%dir %{_sysconfdir}/dbus-1/session.d
+%config(noreplace) %{_sysconfdir}/dbus-1/system.conf
+%config(noreplace) %{_sysconfdir}/dbus-1/system.conf.systemd
+%dir %{_sysconfdir}/dbus-1/system.d
+%dir %{_libdir}/dbus-1
+%attr(4750,root,dbus) %{_libdir}/dbus-1/dbus-daemon-launch-helper
+%{_libdir}/systemd/system/*
+%{_libdir}/systemd/user/*
+%dir %{_datadir}/dbus-1
+%{_datadir}/dbus-1/interfaces
+%{_bindir}/switch-to-dbus.sh
+%{_bindir}/switch-to-kdbus.sh
+%{_sysconfdir}/dbus-1/conf_dbus
+%{_sysconfdir}/dbus-1/conf_kdbus
+
+%files libs
+%{_libdir}/libdbus-1.so.3*
+
+%files devel
+%{_libdir}/libdbus-1.so
+%{_includedir}/dbus-1.0/dbus/dbus*.h
+%dir %{_libdir}/dbus-1.0
+%{_libdir}/dbus-1.0/include/dbus/dbus-arch-deps.h
+%{_libdir}/pkgconfig/dbus-1.pc
diff --git a/packaging/switch-to-dbus.sh b/packaging/switch-to-dbus.sh
new file mode 100755
index 0000000..8fd5f8e
--- /dev/null
+++ b/packaging/switch-to-dbus.sh
@@ -0,0 +1,18 @@
+#!/bin/sh
+
+CONF_DIR_PATH="/etc/dbus-1/conf_dbus"
+
+echo "copying legacy dbus modified service files..."
+rm /usr/lib/systemd/system/graphical.target.wants/xorg.target 2>/dev/null
+rm -rf /usr/lib/systemd/system/xorg* 2>/dev/null
+rm /usr/lib/systemd/user/tizen-middleware.target.wants/dbus.service 2>/dev/null
+ln -s /usr/lib/systemd/user/xorg.service /usr/lib/systemd/user/xorg.target.wants/
+ln -s /usr/lib/systemd/user/xorg_done.service /usr/lib/systemd/user/xorg.target.wants/
+cp -a $CONF_DIR_PATH/* /
+if [ "$?" -ne 0 ]; then
+	echo "error occured on copying!"
+else
+	echo "syncing..."
+	sync
+	echo "now reset and flash the kernel not using kdbus"
+fi
diff --git a/packaging/switch-to-kdbus.sh b/packaging/switch-to-kdbus.sh
new file mode 100755
index 0000000..0b5694e
--- /dev/null
+++ b/packaging/switch-to-kdbus.sh
@@ -0,0 +1,14 @@
+#!/bin/sh
+
+CONF_DIR_PATH="/etc/dbus-1/conf_kdbus"
+
+echo "copying kdbus-modified service files..."
+rm /usr/lib/systemd/user/xorg.target.wants/* 2>/dev/null
+cp -a $CONF_DIR_PATH/* /
+if [ "$?" -ne 0 ]; then
+	echo "error occured on copying!"
+else
+	echo "syncing..."
+	sync
+	echo "now reset and flash the kernel using kdbus"
+fi
diff --git a/packaging/system.conf b/packaging/system.conf
new file mode 100755
index 0000000..9493882
--- /dev/null
+++ b/packaging/system.conf
@@ -0,0 +1,79 @@
+<!-- This configuration file controls the systemwide message bus.
+     Add a system-local.conf and edit that rather than changing this
+     file directly. -->
+
+<!-- Note that there are any number of ways you can hose yourself
+     security-wise by screwing up this file; in particular, you
+     probably don't want to listen on any more addresses, add any more
+     auth mechanisms, run as a different user, etc. -->
+
+<!DOCTYPE busconfig PUBLIC "-//freedesktop//DTD D-Bus Bus Configuration 1.0//EN"
+ "http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd">
+<busconfig>
+
+  <!-- Our well-known bus type, do not change this -->
+  <type>system</type>
+
+  <!-- Run as special user -->
+  <!-- <user>root</user> -->
+
+  <!-- Fork into daemon mode -->
+  <fork/>
+
+  <servicedir>/usr/share/dbus-1/services</servicedir>
+
+  <!-- Write a pid file -->
+  <pidfile>/var/run/messagebus.pid</pidfile>
+
+  <!-- Enable logging to syslog -->
+  <syslog/>
+
+  <!-- Only allow socket-credentials-based authentication -->
+  <auth>EXTERNAL</auth>
+
+  <!-- Only listen on a local socket. (abstract=/path/to/socket
+       means use abstract namespace, don't really create filesystem
+       file; only Linux supports this. Use path=/whatever on other
+       systems.) -->
+  <listen>unix:path=/var/run/dbus/system_bus_socket</listen>
+
+  <policy context="default">
+    <!-- All users can connect to system bus -->
+    <allow user="*"/>
+
+    <!-- Holes must be punched in service configuration files for
+         name ownership and sending method calls -->
+    <allow own="*"/>
+    <allow send_type="method_call"/>
+
+    <!-- Signals and reply messages (method returns, errors) are allowed
+         by default -->
+    <allow send_type="signal"/>
+    <allow send_requested_reply="true" send_type="method_return"/>
+    <allow send_requested_reply="true" send_type="error"/>
+
+    <!-- All messages may be received by default -->
+    <allow receive_type="method_call"/>
+    <allow receive_type="method_return"/>
+    <allow receive_type="error"/>
+    <allow receive_type="signal"/>
+
+    <!-- Allow anyone to talk to the message bus -->
+    <allow send_destination="org.freedesktop.DBus"/>
+    <!-- But disallow some specific bus services -->
+    <deny send_destination="org.freedesktop.DBus"
+          send_interface="org.freedesktop.DBus"
+          send_member="UpdateActivationEnvironment"/>
+  </policy>
+
+  <!-- Config files are placed here that among other things, punch
+       holes in the above policy for specific services. -->
+  <includedir>system.d</includedir>
+
+  <!-- This is included last so local configuration can override what's
+       in this standard file -->
+  <include ignore_missing="yes">system-local.conf</include>
+
+  <include if_selinux_enabled="yes" selinux_root_relative="yes">contexts/dbus_contexts</include>
+
+</busconfig>
diff --git a/samsung_tools/Makefile.am b/samsung_tools/Makefile.am
new file mode 100644
index 0000000..a74261f
--- /dev/null
+++ b/samsung_tools/Makefile.am
@@ -0,0 +1,36 @@
+SUBDIRS = . test_foxp_latency
+DIST_SUBDIRS = test_foxp_latency
+
+EXTRA_DIST = test-foxp-latency
+
+configdir=$(sysconfdir)/dbus-1
+
+AM_CPPFLAGS = \
+	-I$(top_srcdir) \
+	$(DBUS_STATIC_BUILD_CPPFLAGS) \
+	$(DBUS_X_CFLAGS) \
+	-DDBUS_COMPILATION \
+	-DDBUS_MACHINE_UUID_FILE=\""$(localstatedir)/lib/dbus/machine-id"\" \
+	$(NULL)
+
+# if assertions are enabled, improve backtraces
+AM_LDFLAGS = @R_DYNAMIC_LDFLAG@
+
+bin_PROGRAMS = \
+	ping-server \
+	ping-client \
+	$(NULL)
+
+ping_server_SOURCES =				\
+	serwer.c
+
+ping_server_LDADD =				\
+	$(top_builddir)/dbus/libdbus-1.la \
+	$(NULL)
+
+ping_client_SOURCES =				\
+	client.c
+
+ping_client_LDADD =				\
+	$(top_builddir)/dbus/libdbus-1.la \
+	$(NULL)
diff --git a/samsung_tools/client.c b/samsung_tools/client.c
new file mode 100644
index 0000000..4720cd8
--- /dev/null
+++ b/samsung_tools/client.c
@@ -0,0 +1,114 @@
+#include <stdio.h>
+
+#include <dbus/dbus.h>
+
+#include <string.h>
+#include <sys/time.h>
+#include <stdlib.h>
+
+#define DBUS_NAME "com.samsung.pingpong"
+#define DBUS_PATH "/com/samsung/pingpong"
+#define DBUS_IFACE "com.samsung.pingpong"
+
+DBusConnection *dbus_conn;
+struct timeval tv_start, tv_end;
+unsigned int message_serial;
+long int iterations = 0;
+long int avg = 0;
+long int sum = 0;
+static char* ping = "pingping";
+#define MSG_SIZE 3 * 1024 * 1024
+
+void
+shutdown_dbus ()
+{
+	if (dbus_conn) {
+		dbus_connection_close (dbus_conn);
+	}
+}
+
+DBusHandlerResult handler(DBusConnection *conn, DBusMessage *msg, void *user_data)
+{
+	//char buffer[1024];
+	DBusError error;
+	const char *dbus_data;
+	long int delta = 0;
+	DBusMessage *message;
+
+	if (dbus_message_get_reply_serial (msg) != message_serial) {
+		return DBUS_HANDLER_RESULT_HANDLED;
+	}
+
+	dbus_error_init (&error);
+	if(!dbus_message_get_args (msg,&error,DBUS_TYPE_STRING,&dbus_data,DBUS_TYPE_INVALID)) 	{
+		fprintf (stderr,"error: %s\n",error.message);
+		return -1;
+	} else {
+		gettimeofday (&tv_end, NULL);
+		delta = (1000000*tv_end.tv_sec + tv_end.tv_usec) - (1000000*tv_start.tv_sec + tv_start.tv_usec);
+		//printf ("delta: %ld us\n", delta);
+		sum += delta;
+		iterations++;
+		if(iterations == 120) {
+			avg = sum / iterations;
+			printf ("avg RTT: %ld us\n", avg);
+			shutdown_dbus ();
+		}
+		gettimeofday (&tv_start, NULL);
+		message = dbus_message_new_method_call (DBUS_NAME, DBUS_PATH, DBUS_IFACE, "PING");
+		dbus_message_append_args (message, DBUS_TYPE_STRING, &ping, DBUS_TYPE_INVALID);
+		dbus_connection_send (dbus_conn, message, &message_serial);
+		dbus_message_unref (message);
+	}
+	return DBUS_HANDLER_RESULT_HANDLED;
+}
+
+int
+init_dbus ()
+{
+	DBusError error;
+	dbus_error_init (&error);
+
+	dbus_conn = dbus_bus_get_private(DBUS_BUS_SESSION, &error);
+
+	if (dbus_error_is_set (&error)) {
+		fprintf (stderr, "Couldn't initialize DBus: %s\n", error.message);
+
+		return -1;
+	}
+
+	return 0;
+}
+
+int
+main (int argc, char **argv)
+{
+
+	DBusMessage *message;
+	int i;
+	if (init_dbus () < 0) {
+		fprintf (stderr, "Cannot initialize DBus\n");
+		return 1;
+	}
+
+	dbus_connection_add_filter (dbus_conn, handler, NULL, NULL);
+
+	//ping = malloc(MSG_SIZE);
+	//for(i = 0; i < MSG_SIZE; i++) ping[i] = 'v';
+	//ping[MSG_SIZE] = '\0';
+
+	message = dbus_message_new_method_call (DBUS_NAME, DBUS_PATH, DBUS_IFACE, "PING");
+	dbus_message_append_args (message, DBUS_TYPE_STRING, &ping, DBUS_TYPE_INVALID);
+	dbus_connection_send (dbus_conn, message, &message_serial);
+
+	gettimeofday (&tv_start, NULL);
+
+	dbus_message_unref (message);
+	while (dbus_connection_read_write (dbus_conn, -1)) {
+		while (dbus_connection_dispatch (dbus_conn) != DBUS_DISPATCH_COMPLETE) {
+		}
+	}
+	//free(ping);
+
+	return 0;
+}
diff --git a/samsung_tools/serwer.c b/samsung_tools/serwer.c
new file mode 100644
index 0000000..9cd186b
--- /dev/null
+++ b/samsung_tools/serwer.c
@@ -0,0 +1,118 @@
+//gcc -o server serwer.c -Wall -g -O0 `pkg-config --cflags --libs dbus-1`
+
+#include <dbus/dbus.h>
+#include <stdio.h>
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#define DBUS_NAME "com.samsung.pingpong"
+#define DBUS_PATH "/com/samsung/pingpong"
+#define DBUS_IFACE "com.samsung.pingpong"
+
+DBusConnection *dbus_conn;
+DBusObjectPathVTable *dbus_vtable;
+
+static DBusHandlerResult
+handler_function(DBusConnection *conn, DBusMessage *msg, void *user_data)
+{
+	DBusMessage *reply;
+
+	DBusError error;
+	dbus_error_init(&error);
+
+	char * ping;
+
+	if (!dbus_message_get_args ( msg,
+					&error,
+					DBUS_TYPE_STRING,
+					&ping,
+					DBUS_TYPE_INVALID))
+	{
+		fprintf(stderr, "Error - Invalid ping message!");
+		reply = dbus_message_new_error(msg, "com.misiek.pingpong.PingError","ping message corrupted");
+	} else {
+		printf ("Received from client%s\n", ping);
+		reply = dbus_message_new_method_return(msg);
+		dbus_message_append_args (reply, DBUS_TYPE_STRING, &ping, DBUS_TYPE_INVALID);
+	}
+	dbus_connection_send(dbus_conn, reply, NULL);
+	dbus_message_unref(reply);
+
+	return DBUS_HANDLER_RESULT_HANDLED;
+}
+
+int
+init_dbus()
+{
+	DBusError error;
+	int flag;
+	dbus_error_init(&error);
+
+	dbus_conn = dbus_bus_get_private(DBUS_BUS_SESSION,&error);
+
+	if(dbus_error_is_set(&error))
+	{
+		fprintf(stderr,"Error- could not initizalize dbus session: %s \n", error.message);
+		return -1;
+	}
+
+	switch(flag = dbus_bus_request_name(dbus_conn, DBUS_NAME, DBUS_NAME_FLAG_DO_NOT_QUEUE, &error))
+	{
+		case DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER:
+		case DBUS_REQUEST_NAME_REPLY_IN_QUEUE:
+			//printf("serwer.c request_name flags %d\n",flag);
+			//printf("serwer.c Name registered as %s\n",DBUS_NAME);
+			break;
+		default:
+			printf("serwer.c Error - could not request name. Flag: %d\n", flag);
+			return -1;
+	}
+
+	dbus_vtable = malloc(sizeof(DBusObjectPathVTable));
+	dbus_vtable->unregister_function = NULL;
+
+	dbus_vtable->message_function = handler_function;
+
+	if(!dbus_connection_register_object_path(dbus_conn,
+						DBUS_PATH,
+						dbus_vtable,
+						NULL))
+	{
+		printf("Error - could not register object path");
+		return -1;
+	}
+
+	return 0;
+
+}
+
+void
+shutdown_dbus ()
+{
+	if (dbus_conn) {
+		dbus_connection_close(dbus_conn);
+		free(dbus_vtable);
+	}
+}
+
+
+int
+main(int argc, char **argv)
+{
+
+	if (init_dbus() < 0) {
+		fprintf(stderr, "serwer.c Error initializing dbus\n");
+	}
+	fprintf(stderr,"Waiting for clients\n");
+
+	while (dbus_connection_read_write(dbus_conn, -1)) {
+		while (dbus_connection_dispatch( dbus_conn) != DBUS_DISPATCH_COMPLETE){
+		}
+	}
+
+	shutdown_dbus();
+	return 0;
+}
diff --git a/samsung_tools/test-foxp-latency b/samsung_tools/test-foxp-latency
new file mode 100755
index 0000000..b350af3
--- /dev/null
+++ b/samsung_tools/test-foxp-latency
@@ -0,0 +1,134 @@
+#!/usr/bin/expect
+
+set TARGET_HOST "localhost"
+set ROOT_DIR "/home/mike/JJ"
+set NUM_PASSES 50
+set RESULT_FILE [clock format [clock seconds] -format "latency-results-%Y.%m.%d.%H.%M.%S.csv"]
+
+set INVOCATIONS [list \
+    { "TTV default" "DISPLAY=:0" } \
+    [list "Custom lib, kdbus transport" "LD_LIBRARY_PATH=$ROOT_DIR/libs DBUS_SESSION_BUS_ADDRESS='kdbus:path=/dev/kdbus/1000-testtest/bus'"] \
+]
+
+#    [list "Custom lib, dbus transport" "DISPLAY=:0 LD_LIBRARY_PATH=$ROOT_DIR/libs"] \
+
+#set PROBES { \
+#    1000   { 1000 } \
+#    2000   { 1000 2000 } \
+#    5000   { 1000 2000 5000 } \
+#    10000  { 1000 2000 5000 10000 } \
+#    20000  { 1000 2000 5000 10000 20000 } \
+#    50000  { 1000 2000 5000 10000 20000 50000 } \
+#    75000  { 1000 2000 5000 10000 20000 50000 75000 } \
+#    100000 { 1000 2000 5000 10000 20000 50000 75000 } \
+#    200000 { 1000 2000 5000 10000 20000 50000 75000 } \
+#    300000 { 1000 2000 5000 10000 20000 50000 75000 } \
+#}
+
+
+# ***************************************************************************************************************************************************
+
+
+proc run_server { invocation } {
+    global TARGET_HOST ROOT_DIR
+    spawn ssh -t $TARGET_HOST "cd $ROOT_DIR/ipc-test; $invocation ./ping-server"
+    expect {
+        "Waiting for clients"    { return $spawn_id }
+        default                 {
+            puts ">>> ERROR <<<"
+            puts $expect_out(buffer)
+            puts ">>> ----- <<<"
+            return 0
+        }
+    }
+}
+
+
+proc terminate_server { server_id } {
+    set spawn_id $server_id
+    send "\x03"
+    expect {
+        "closed."   { return 1 }
+        default     { return 0 }
+    }
+}
+
+
+proc run_client { invocation } {
+    global TARGET_HOST ROOT_DIR
+    spawn ssh -t $TARGET_HOST "$invocation $ROOT_DIR/ipc-test/ping-client"
+    set round_trip_time 0
+    expect  {
+        -timeout 60
+        -re {avg RTT: (\d+) us} {
+            set round_trip_time $expect_out(1,string)
+        }
+        timeout { puts "ctrl-C"; send "\x03" }
+    }
+    return $round_trip_time
+}
+
+
+proc log_result { data { new_file 0 } } {
+    global RESULT_FILE
+    if { $new_file } {
+        puts "Storing results into file $RESULT_FILE"
+    }
+    set pl [open $RESULT_FILE [expr {$new_file ? "w" : "a"}]]
+    puts $pl [join $data ","]
+    close $pl
+}
+
+# ***************************************************************************************************************************************************
+
+
+log_user 0
+
+log_result { {"Test environment"} {"Round Trip Time [us]"} } 1
+
+# iterate over different invocations
+foreach invocation $INVOCATIONS {
+    set test_env [lindex $invocation 0]
+    puts "Test environment: $test_env"
+    puts ""
+    puts -nonewline "Bringing up server... "
+    set server [run_server [lindex $invocation 1]]
+    if { $server == 0 } {
+        puts "failed!"
+        continue
+    }
+    puts "OK!"
+
+    flush stdout
+    # average several passes to get more stable figures
+    set total 0
+    set passes 0
+    for { set run 1 } { $run <= $NUM_PASSES } { incr run } {
+        set result [run_client [lindex $invocation 1]]
+        if { $result > 0 } {
+            #puts -nonewline "."
+	    puts "$result us"
+            incr total $result
+            incr passes
+        } else {
+            puts -nonewline "!"
+        }
+        flush stdout
+    }
+    if { $passes > 0 } {
+        set avg [expr $total / $passes]
+        puts " $avg us"
+        log_result [list "\"$test_env\"" $avg]
+    } else {
+        puts " no results!"
+    }
+    flush stdout
+
+
+    puts -nonewline "Terminating server... "
+    terminate_server $server
+    puts "OK!"
+    puts ""
+}
+
+log_user 1
diff --git a/samsung_tools/test_foxp_latency/Makefile.am b/samsung_tools/test_foxp_latency/Makefile.am
new file mode 100644
index 0000000..9bbeecd
--- /dev/null
+++ b/samsung_tools/test_foxp_latency/Makefile.am
@@ -0,0 +1,33 @@
+configdir=$(sysconfdir)/dbus-1
+
+EXTRA_DIST = test-foxp-latency
+
+AM_CPPFLAGS = \
+	-I$(top_srcdir) \
+	$(DBUS_STATIC_BUILD_CPPFLAGS) \
+	$(DBUS_X_CFLAGS) \
+	-DDBUS_COMPILATION \
+	-DDBUS_MACHINE_UUID_FILE=\""$(localstatedir)/lib/dbus/machine-id"\" \
+	$(NULL)
+
+# if assertions are enabled, improve backtraces
+AM_LDFLAGS = @R_DYNAMIC_LDFLAG@
+
+bin_PROGRAMS = \
+	ping-server \
+	ping-client \
+	$(NULL)
+
+ping_server_SOURCES =				\
+	ping-server.c
+
+ping_server_LDADD =				\
+	$(top_builddir)/dbus/libdbus-1.la \
+	$(NULL)
+
+ping_client_SOURCES =				\
+	ping-client.c
+
+ping_client_LDADD =				\
+	$(top_builddir)/dbus/libdbus-1.la \
+	$(NULL)
diff --git a/samsung_tools/test_foxp_latency/README b/samsung_tools/test_foxp_latency/README
new file mode 100644
index 0000000..c071446
--- /dev/null
+++ b/samsung_tools/test_foxp_latency/README
@@ -0,0 +1 @@
+.git directory is needed by GBS, just copy any .git dir here
diff --git a/samsung_tools/test_foxp_latency/packaging/test_foxp_ping.manifest b/samsung_tools/test_foxp_latency/packaging/test_foxp_ping.manifest
new file mode 100644
index 0000000..f5a44ec
--- /dev/null
+++ b/samsung_tools/test_foxp_latency/packaging/test_foxp_ping.manifest
@@ -0,0 +1,5 @@
+<manifest>
+        <request>
+                <domain name="_"/>
+        </request>
+</manifest>
diff --git a/samsung_tools/test_foxp_latency/packaging/test_foxp_ping.spec b/samsung_tools/test_foxp_latency/packaging/test_foxp_ping.spec
new file mode 100644
index 0000000..63ad17d
--- /dev/null
+++ b/samsung_tools/test_foxp_latency/packaging/test_foxp_ping.spec
@@ -0,0 +1,39 @@
+#
+# Do not Edit! Generated by:
+# spectacle version 0.13
+#
+# >> macros
+# << macros
+
+Name:       test_foxp_ping
+Summary:    test_foxp_ping
+Version:    1
+Release:    1.0
+Group:      System/Base
+License:    GPLv2
+URL:        none
+Source0:    %{name}-%{version}.tar.gz
+Source100:  test_foxp_ping.yaml
+Source1001: %{name}.manifest
+BuildRequires: pkgconfig(dbus-1)
+#BuildRequires: pkgconfig(sqlite3)
+
+%description
+Test for foxp
+
+%prep
+%setup -q -n %{name}-%{version}
+
+# >> setup
+# << setup
+
+%build
+# >> build pre
+# << build pre
+
+cp %{SOURCE1001} .
+make %{?jobs:-j%jobs}
+
+# >> build post
+# << build post
+%install
diff --git a/samsung_tools/test_foxp_latency/packaging/test_foxp_ping.yaml b/samsung_tools/test_foxp_latency/packaging/test_foxp_ping.yaml
new file mode 100644
index 0000000..93b3143
--- /dev/null
+++ b/samsung_tools/test_foxp_latency/packaging/test_foxp_ping.yaml
@@ -0,0 +1,13 @@
+Name: test_foxp_ping
+Summary: GDBus example application 2
+Version: 1
+Release: 1.0
+Group: System/Base
+License: GPLv2
+URL: none
+Sources:
+    - "%{name}-%{version}.tar.gz"
+Description: test_foxp_ping.
+
+PkgBR: none
+Configure: none
diff --git a/samsung_tools/test_foxp_latency/ping-client.c b/samsung_tools/test_foxp_latency/ping-client.c
new file mode 100644
index 0000000..2a389b2
--- /dev/null
+++ b/samsung_tools/test_foxp_latency/ping-client.c
@@ -0,0 +1,125 @@
+#include <stdio.h>
+
+#include <dbus/dbus.h>
+
+#include <string.h>
+#include <sys/time.h>
+#include <stdlib.h>
+
+#define DBUS_NAME "com.samsung.pingpong"
+#define DBUS_PATH "/com/samsung/pingpong"
+#define DBUS_IFACE "com.samsung.pingpong"
+
+DBusConnection *dbus_conn;
+struct timeval tv_start, tv_end;
+unsigned int message_serial;
+long int iterations = 0;
+long int avg = 0;
+long int sum = 0;
+static char* ping = "pingping";
+int MSG_SIZE  = 1024*1024;
+//#define MSG_SIZE 3 * 1024 * 1024
+
+void
+shutdown_dbus ()
+{
+	if (dbus_conn) {
+		dbus_connection_close (dbus_conn);
+	}
+}
+
+DBusHandlerResult handler(DBusConnection *conn, DBusMessage *msg, void *user_data)
+{
+	//char buffer[1024];
+	DBusError error;
+	const char *dbus_data;
+	long int delta = 0;
+	DBusMessage *message;
+
+	if (dbus_message_get_reply_serial (msg) != message_serial) {
+		return DBUS_HANDLER_RESULT_HANDLED;
+	}
+
+	dbus_error_init (&error);
+	if(!dbus_message_get_args (msg,&error,DBUS_TYPE_STRING,&dbus_data,DBUS_TYPE_INVALID)) 	{
+		fprintf (stderr,"error: %s\n",error.message);
+		return -1;
+	} else {
+		if(dbus_data[5] != 'v') {
+		  fprintf (stderr,"error: string content not right! \n");
+		  return -1;
+		}
+
+		gettimeofday (&tv_end, NULL);
+		delta = (1000000*tv_end.tv_sec + tv_end.tv_usec) - (1000000*tv_start.tv_sec + tv_start.tv_usec);
+		//printf ("delta: %ld us\n", delta);
+		sum += delta;
+		iterations++;
+		//if(iterations == 10) {
+			avg = sum / iterations;
+			printf ("avg RTT: %ld us\n", avg);
+			shutdown_dbus ();
+		//}
+		gettimeofday (&tv_start, NULL);
+		message = dbus_message_new_method_call (DBUS_NAME, DBUS_PATH, DBUS_IFACE, "PING");
+		dbus_message_append_args (message, DBUS_TYPE_STRING, &ping, DBUS_TYPE_INVALID);
+		dbus_connection_send (dbus_conn, message, &message_serial);
+		dbus_message_unref (message);
+	}
+	return DBUS_HANDLER_RESULT_HANDLED;
+}
+
+int
+init_dbus ()
+{
+	DBusError error;
+	dbus_error_init (&error);
+
+	dbus_conn = dbus_bus_get_private(DBUS_BUS_SESSION, &error);
+
+	if (dbus_error_is_set (&error)) {
+		fprintf (stderr, "Couldn't initialize DBus: %s\n", error.message);
+
+		return -1;
+	}
+
+	return 0;
+}
+
+int
+main (int argc, char **argv)
+{
+
+	DBusMessage *message;
+	int i;
+
+	if (argc > 1)
+		MSG_SIZE = atoi(argv[1]);
+
+	if (init_dbus () < 0) {
+		fprintf (stderr, "Cannot initialize DBus\n");
+		return 1;
+	}
+
+	dbus_connection_add_filter (dbus_conn, handler, NULL, NULL);
+
+	ping = malloc(MSG_SIZE);
+	for(i = 0; i < MSG_SIZE; i++) ping[i] = 'v';
+	ping[MSG_SIZE-1] = '\0';
+	//printf("MSG_SIZE: %i\n", MSG_SIZE);
+
+	message = dbus_message_new_method_call (DBUS_NAME, DBUS_PATH, DBUS_IFACE, "PING");
+	dbus_message_append_args (message, DBUS_TYPE_STRING, &ping, DBUS_TYPE_INVALID);
+	dbus_connection_send (dbus_conn, message, &message_serial);
+
+	gettimeofday (&tv_start, NULL);
+
+	dbus_message_unref (message);
+	while (dbus_connection_read_write (dbus_conn, -1)) {
+		while (dbus_connection_dispatch (dbus_conn) != DBUS_DISPATCH_COMPLETE) {
+		}
+	}
+	free(ping);
+
+	return 0;
+}
diff --git a/samsung_tools/test_foxp_latency/ping-server.c b/samsung_tools/test_foxp_latency/ping-server.c
new file mode 100644
index 0000000..16726d9
--- /dev/null
+++ b/samsung_tools/test_foxp_latency/ping-server.c
@@ -0,0 +1,118 @@
+//gcc -o server serwer.c -Wall -g -O0 `pkg-config --cflags --libs dbus-1`
+
+#include <dbus/dbus.h>
+#include <stdio.h>
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#define DBUS_NAME "com.samsung.pingpong"
+#define DBUS_PATH "/com/samsung/pingpong"
+#define DBUS_IFACE "com.samsung.pingpong"
+
+DBusConnection *dbus_conn;
+DBusObjectPathVTable *dbus_vtable;
+
+static DBusHandlerResult
+handler_function(DBusConnection *conn, DBusMessage *msg, void *user_data)
+{
+	DBusMessage *reply;
+
+	DBusError error;
+	dbus_error_init(&error);
+
+	char * ping;
+
+	if (!dbus_message_get_args ( msg,
+					&error,
+					DBUS_TYPE_STRING,
+					&ping,
+					DBUS_TYPE_INVALID))
+	{
+		fprintf(stderr, "Error - Invalid ping message!");
+		reply = dbus_message_new_error(msg, "com.misiek.pingpong.PingError","ping message corrupted");
+	} else {
+		//printf ("Received from client%s\n", ping);
+		reply = dbus_message_new_method_return(msg);
+		dbus_message_append_args (reply, DBUS_TYPE_STRING, &ping, DBUS_TYPE_INVALID);
+	}
+	dbus_connection_send(dbus_conn, reply, NULL);
+	dbus_message_unref(reply);
+
+	return DBUS_HANDLER_RESULT_HANDLED;
+}
+
+int
+init_dbus()
+{
+	DBusError error;
+	int flag;
+	dbus_error_init(&error);
+
+	dbus_conn = dbus_bus_get_private(DBUS_BUS_SESSION,&error);
+
+	if(dbus_error_is_set(&error))
+	{
+		fprintf(stderr,"Error- could not initizalize dbus session: %s \n", error.message);
+		return -1;
+	}
+
+	switch(flag = dbus_bus_request_name(dbus_conn, DBUS_NAME, DBUS_NAME_FLAG_DO_NOT_QUEUE, &error))
+	{
+		case DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER:
+		case DBUS_REQUEST_NAME_REPLY_IN_QUEUE:
+			//printf("serwer.c request_name flags %d\n",flag);
+			//printf("serwer.c Name registered as %s\n",DBUS_NAME);
+			break;
+		default:
+			printf("serwer.c Error - could not request name, %d\n", flag);
+			return -1;
+	}
+
+	dbus_vtable = malloc(sizeof(DBusObjectPathVTable));
+	dbus_vtable->unregister_function = NULL;
+
+	dbus_vtable->message_function = handler_function;
+
+	if(!dbus_connection_register_object_path(dbus_conn,
+						DBUS_PATH,
+						dbus_vtable,
+						NULL))
+	{
+		printf("Error - could not register object path");
+		return -1;
+	}
+
+	return 0;
+
+}
+
+void
+shutdown_dbus ()
+{
+	if (dbus_conn) {
+		dbus_connection_close(dbus_conn);
+		free(dbus_vtable);
+	}
+}
+
+
+int
+main(int argc, char **argv)
+{
+
+	if (init_dbus() < 0) {
+		fprintf(stderr, "serwer.c Error initializing dbus\n");
+	}
+	fprintf(stderr,"Waiting for clients\n");
+
+	while (dbus_connection_read_write(dbus_conn, -1)) {
+		while (dbus_connection_dispatch( dbus_conn) != DBUS_DISPATCH_COMPLETE){
+		}
+	}
+
+	shutdown_dbus();
+	return 0;
+}
diff --git a/samsung_tools/test_foxp_latency/test-foxp-latency b/samsung_tools/test_foxp_latency/test-foxp-latency
new file mode 100755
index 0000000..21e042f
--- /dev/null
+++ b/samsung_tools/test_foxp_latency/test-foxp-latency
@@ -0,0 +1,143 @@
+#!/usr/bin/expect
+
+set TARGET_HOST "foxp2"
+set ROOT_DIR "/root"
+set NUM_PASSES 3
+#set DATA_SIZE_BYTES 1024
+set RESULT_FILE [clock format [clock seconds] -format "latency-results-%Y.%m.%d.%H.%M.%S.csv"]
+
+set INVOCATIONS [list \
+    { "TTV default" "DISPLAY=:0 " } \
+    [list "Custom lib, kdbus transport" "LD_LIBRARY_PATH=$ROOT_DIR/libs DBUS_SESSION_BUS_ADDRESS='kdbus:path=/dev/kdbus/0-kdbus/bus'"] \
+]
+
+#    [list "Custom lib, dbus transport" "DISPLAY=:0 LD_LIBRARY_PATH=$ROOT_DIR/libs"] \
+
+set DATA_SIZES_BYTES { 10 100 1024 10240 102400 1048576 10485760 }
+
+#set PROBES { \
+#    1000   { 1000 } \
+#    2000   { 1000 2000 } \
+#    5000   { 1000 2000 5000 } \
+#    10000  { 1000 2000 5000 10000 } \
+#    20000  { 1000 2000 5000 10000 20000 } \
+#    50000  { 1000 2000 5000 10000 20000 50000 } \
+#    75000  { 1000 2000 5000 10000 20000 50000 75000 } \
+#    100000 { 1000 2000 5000 10000 20000 50000 75000 } \
+#    200000 { 1000 2000 5000 10000 20000 50000 75000 } \
+#    300000 { 1000 2000 5000 10000 20000 50000 75000 } \
+#}
+
+
+# ***************************************************************************************************************************************************
+
+
+proc run_server { invocation } {
+    global TARGET_HOST ROOT_DIR
+    spawn ssh -t $TARGET_HOST "cd $ROOT_DIR/ipc-test; $invocation ./ping-server"
+    expect {
+        "Waiting for clients"    { return $spawn_id }
+        default                 {
+            puts ">>> ERROR <<<"
+            #puts $expect_out(buffer)
+            puts ">>> ----- <<<"
+            return 0
+        }
+    }
+}
+
+
+proc terminate_server { server_id } {
+    set spawn_id $server_id
+    send "\x03"
+    expect {
+        "closed."   { return 1 }
+        default     { return 0 }
+    }
+}
+
+
+proc run_client { invocation data_size_bytes} {
+    global TARGET_HOST ROOT_DIR
+    spawn ssh -t $TARGET_HOST "$invocation $ROOT_DIR/ipc-test/ping-client $data_size_bytes"
+    set round_trip_time 0
+    expect  {
+        -timeout 60
+        -re {avg RTT: (\d+) us} {
+            set round_trip_time $expect_out(1,string)
+        }
+        timeout { puts "ctrl-C"; send "\x03" }
+    }
+    return $round_trip_time
+}
+
+
+proc log_result { data { new_file 0 } } {
+    global RESULT_FILE
+    if { $new_file } {
+        puts "Storing results into file $RESULT_FILE"
+    }
+    set pl [open $RESULT_FILE [expr {$new_file ? "w" : "a"}]]
+    puts $pl [join $data ","]
+    close $pl
+}
+
+# ***************************************************************************************************************************************************
+
+
+log_user 0
+
+log_result { {"Test environment"} {Data size [Bytes]} {"Round Trip Time [ms]"} } 1
+
+# iterate over different invocations
+foreach invocation $INVOCATIONS {
+    set test_env [lindex $invocation 0]
+    puts "Test environment: $test_env"
+    puts ""
+    puts -nonewline "Bringing up server... "
+    set server [run_server [lindex $invocation 1]]
+    if { $server == 0 } {
+        puts "failed!"
+        continue
+    }
+    puts "OK!"
+    puts "Test start, passes: $NUM_PASSES"
+    flush stdout
+
+    for { set p 0 } { $p < [llength $DATA_SIZES_BYTES] } { incr p } {
+      set data_size_bytes [lindex $DATA_SIZES_BYTES $p]
+      # average several passes to get more stable figures
+      set total 0
+      set passes 0
+      for { set run 1 } { $run <= $NUM_PASSES } { incr run } {
+	  set result [run_client [lindex $invocation 1] $data_size_bytes]
+	  if { $result >= 0 } {
+	      puts -nonewline "."
+	      #puts "iteration $passes, data_size: $data_size_bytes : $result us"
+	      incr total $result
+	      incr passes
+	  } else {
+	      puts -nonewline "!"
+	  }
+	  flush stdout
+      }
+      if { $passes > 0 } {
+	  set avg [expr $total / $passes]
+	  puts " data_size $data_size_bytes B  $avg us"
+	  log_result [list "\"$test_env\"" $data_size_bytes $avg]
+      } else {
+	  puts " no results!"
+      }
+      #puts " data_size: $data_size_bytes"
+    }
+
+    flush stdout
+
+
+    puts -nonewline "Terminating server... "
+    terminate_server $server
+    puts "OK!"
+    puts ""
+}
+
+log_user 1
diff --git a/tools/dbus-launch.c b/tools/dbus-launch.c
index 7ecee63..394c36a 100644
--- a/tools/dbus-launch.c
+++ b/tools/dbus-launch.c
@@ -845,6 +845,7 @@ main (int argc, char **argv)
   int autolaunch = FALSE;
   int requires_arg = FALSE;
   int close_stderr = FALSE;
+  int kdbus = FALSE;
   int i;
   int ret;
   int bus_pid_to_launcher_pipe[2];
@@ -881,6 +882,8 @@ main (int argc, char **argv)
         exit_with_session = TRUE;
       else if (strcmp (arg, "--close-stderr") == 0)
         close_stderr = TRUE;
+      else if (strcmp (arg, "--kdbus") == 0)
+        kdbus = TRUE;
       else if (strstr (arg, "--autolaunch=") == arg)
         {
           const char *s;
@@ -1164,14 +1167,30 @@ main (int argc, char **argv)
       }
  #endif /* DBUS_ENABLE_EMBEDDED_TESTS */
 
-      execl (DBUS_DAEMONDIR"/dbus-daemon",
+      if (kdbus)
+        {
+          execl (DBUS_DAEMONDIR"/dbus-daemon",
              DBUS_DAEMONDIR"/dbus-daemon",
              "--fork",
              "--print-pid", write_pid_fd_as_string,
              "--print-address", write_address_fd_as_string,
+             "--address=kdbus:",
              config_file ? "--config-file" : "--session",
              config_file, /* has to be last in this varargs list */
              NULL);
+        }
+      else
+        {
+          execl (DBUS_DAEMONDIR"/dbus-daemon",
+             DBUS_DAEMONDIR"/dbus-daemon",
+             "--fork",
+             "--print-pid", write_pid_fd_as_string,
+             "--print-address", write_address_fd_as_string,
+             config_file ? "--config-file" : "--session",
+             config_file, /* has to be last in this varargs list */
+             NULL);
+        }
+
 
       fprintf (stderr,
                "Failed to execute message bus daemon %s: %s.  Will try again without full path.\n",
@@ -1183,7 +1202,21 @@ main (int argc, char **argv)
        * file and the dbus-daemon will not be in the install location during
        * build time.
        */
-      execlp ("dbus-daemon",
+      if (kdbus)
+        {
+          execlp ("dbus-daemon",
+              "dbus-daemon",
+              "--fork",
+              "--print-pid", write_pid_fd_as_string,
+              "--print-address", write_address_fd_as_string,
+              "--address=kdbus:",
+              config_file ? "--config-file" : "--session",
+              config_file, /* has to be last in this varargs list */
+              NULL);
+        }
+      else
+        {
+          execlp ("dbus-daemon",
               "dbus-daemon",
               "--fork",
               "--print-pid", write_pid_fd_as_string,
@@ -1191,6 +1224,7 @@ main (int argc, char **argv)
               config_file ? "--config-file" : "--session",
               config_file, /* has to be last in this varargs list */
               NULL);
+        }
 
       fprintf (stderr,
                "Failed to execute message bus daemon: %s\n",
