Index: acinclude.m4
===================================================================
--- acinclude.m4	(revision 3869)
+++ acinclude.m4	(working copy)
@@ -3,7 +3,7 @@
 dnl
 AC_DEFUN([AM_PATH_SDL],
 [dnl 
-dnl Get the cflags and libraries from the sdl-config script
+dnl Get the cflags and libraries from the sdl-config (or sdl2-config) script
 dnl
 AC_ARG_WITH(sdl-prefix,[  --with-sdl-prefix=PFX   Prefix where SDL is installed (optional)],
             sdl_prefix="$withval", sdl_prefix="")
@@ -12,21 +12,30 @@
 AC_ARG_ENABLE(sdltest, [  --disable-sdltest       Do not try to compile and run a test SDL program],
 		    , enable_sdltest=yes)
 
+  if test x$with_sdl2 = xyes ; then
+    SDL_CONFIG_EXE=sdl2-config
+  else
+    SDL_CONFIG_EXE=sdl-config
+  fi
   if test x$sdl_exec_prefix != x ; then
      sdl_args="$sdl_args --exec-prefix=$sdl_exec_prefix"
      if test x${SDL_CONFIG+set} != xset ; then
-        SDL_CONFIG=$sdl_exec_prefix/bin/sdl-config
+        SDL_CONFIG=$sdl_exec_prefix/bin/$SDL_CONFIG_EXE
      fi
   fi
   if test x$sdl_prefix != x ; then
      sdl_args="$sdl_args --prefix=$sdl_prefix"
      if test x${SDL_CONFIG+set} != xset ; then
-        SDL_CONFIG=$sdl_prefix/bin/sdl-config
+        SDL_CONFIG=$sdl_prefix/bin/$SDL_CONFIG_EXE
      fi
   fi
 
-  AC_PATH_PROG(SDL_CONFIG, sdl-config, no)
-  min_sdl_version=ifelse([$1], ,0.11.0,$1)
+  AC_PATH_PROG(SDL_CONFIG, $SDL_CONFIG_EXE, no)
+  if test x$with_sdl2 = xyes ; then
+    min_sdl_version=2.0.0
+  else
+    min_sdl_version=1.2.0
+  fi
   AC_MSG_CHECKING(for SDL - version >= $min_sdl_version)
   no_sdl=""
   if test "$SDL_CONFIG" = "no" ; then
@@ -48,7 +57,7 @@
       LIBS="$LIBS $SDL_LIBS"
 dnl
 dnl Now check if the installed SDL is sufficiently new. (Also sanity
-dnl checks the results of sdl-config to some extent
+dnl checks the results of sdl-config, or sdl2-config, to some extent
 dnl
       rm -f conf.sdltest
       AC_TRY_RUN([
@@ -98,11 +107,11 @@
     }
   else
     {
-      printf("\n*** 'sdl-config --version' returned %d.%d.%d, but the minimum version\n", $sdl_major_version, $sdl_minor_version, $sdl_micro_version);
-      printf("*** of SDL required is %d.%d.%d. If sdl-config is correct, then it is\n", major, minor, micro);
+      printf("\n*** '$SDL_CONFIG_EXE --version' returned %d.%d.%d, but the minimum version\n", $sdl_major_version, $sdl_minor_version, $sdl_micro_version);
+      printf("*** of SDL required is %d.%d.%d. If $SDL_CONFIG_EXE is correct, then it is\n", major, minor, micro);
       printf("*** best to upgrade to the required version.\n");
-      printf("*** If sdl-config was wrong, set the environment variable SDL_CONFIG\n");
-      printf("*** to point to the correct copy of sdl-config, and remove the file\n");
+      printf("*** If $SDL_CONFIG_EXE was wrong, set the environment variable SDL_CONFIG\n");
+      printf("*** to point to the correct copy of $SDL_CONFIG_EXE, and remove the file\n");
       printf("*** config.cache before re-running configure\n");
       return 1;
     }
@@ -119,10 +128,10 @@
   else
      AC_MSG_RESULT(no)
      if test "$SDL_CONFIG" = "no" ; then
-       echo "*** The sdl-config script installed by SDL could not be found"
+       echo "*** The $SDL_CONFIG_EXE script installed by SDL could not be found"
        echo "*** If SDL was installed in PREFIX, make sure PREFIX/bin is in"
        echo "*** your path, or set the SDL_CONFIG environment variable to the"
-       echo "*** full path to sdl-config."
+       echo "*** full path to $SDL_CONFIG_EXE."
      else
        if test -f conf.sdltest ; then
         :
@@ -146,7 +155,7 @@
         [ echo "*** The test program failed to compile or link. See the file config.log for the"
           echo "*** exact error that occured. This usually means SDL was incorrectly installed"
           echo "*** or that you have moved SDL since it was installed. In the latter case, you"
-          echo "*** may want to edit the sdl-config script: $SDL_CONFIG" ])
+          echo "*** may want to edit the $SDL_CONFIG_EXE script: $SDL_CONFIG" ])
           CFLAGS="$ac_save_CFLAGS"
           LIBS="$ac_save_LIBS"
        fi
@@ -153,7 +162,7 @@
      fi
      SDL_CFLAGS=""
      SDL_LIBS=""
-     ifelse([$3], , :, [$3])
+     AC_MSG_ERROR([*** SDL version $min_sdl_version not found!])
   fi
   AC_SUBST(SDL_CFLAGS)
   AC_SUBST(SDL_LIBS)
Index: android-project/AndroidManifest.xml
===================================================================
--- android-project/AndroidManifest.xml	(revision 0)
+++ android-project/AndroidManifest.xml	(working copy)
@@ -0,0 +1,29 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+      package="com.dosbox.emu"
+      android:versionCode="1"
+      android:versionName="1.0"
+      android:installLocation="auto">
+
+    <application android:label="@string/app_name"
+                 android:icon="@drawable/icon"
+	         android:theme="@android:style/Theme.NoTitleBar.Fullscreen">
+        <activity android:name="DOSBoxActivity"
+                  android:configChanges="orientation|screenSize"
+                  android:label="@string/app_name">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+    </application>
+
+    <!-- Android 2.3.3 - minimum, 4.2 - target -->
+    <uses-sdk android:minSdkVersion="10" android:targetSdkVersion="17" /> 
+
+    <!-- OpenGL ES 2.0 -->
+    <uses-feature android:glEsVersion="0x00020000" /> 
+
+    <!-- Allow writing to external storage -->
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /> 
+</manifest> 

Property changes on: android-project/AndroidManifest.xml
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: android-project/ant.properties
===================================================================
--- android-project/ant.properties	(revision 0)
+++ android-project/ant.properties	(working copy)
@@ -0,0 +1,17 @@
+# This file is used to override default values used by the Ant build system.
+#
+# This file must be checked into Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+

Property changes on: android-project/ant.properties
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: android-project/build.properties
===================================================================
--- android-project/build.properties	(revision 0)
+++ android-project/build.properties	(working copy)
@@ -0,0 +1,17 @@
+# This file is used to override default values used by the Ant build system.
+# 
+# This file must be checked in Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+

Property changes on: android-project/build.properties
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: android-project/build.xml
===================================================================
--- android-project/build.xml	(revision 0)
+++ android-project/build.xml	(working copy)
@@ -0,0 +1,93 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- This should be changed to the name of your project -->
+<project name="DOSBox" default="help">
+
+    <!-- The local.properties file is created and updated by the 'android' tool.
+         It contains the path to the SDK. It should *NOT* be checked into
+         Version Control Systems. -->
+    <property file="local.properties" />
+
+    <!-- The ant.properties file can be created by you. It is only edited by the
+         'android' tool to add properties to it.
+         This is the place to change some Ant specific build properties.
+         Here are some properties you may want to change/update:
+
+         source.dir
+             The name of the source directory. Default is 'src'.
+         out.dir
+             The name of the output directory. Default is 'bin'.
+
+         For other overridable properties, look at the beginning of the rules
+         files in the SDK, at tools/ant/build.xml
+
+         Properties related to the SDK location or the project target should
+         be updated using the 'android' tool with the 'update' action.
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems.
+
+         -->
+    <property file="ant.properties" />
+
+    <!-- if sdk.dir was not set from one of the property file, then
+         get it from the ANDROID_HOME env var.
+         This must be done before we load project.properties since
+         the proguard config can use sdk.dir -->
+    <property environment="env" />
+    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
+        <isset property="env.ANDROID_HOME" />
+    </condition>
+
+    <!-- The project.properties file is created and updated by the 'android'
+         tool, as well as ADT.
+
+         This contains project specific properties such as project target, and library
+         dependencies. Lower level build properties are stored in ant.properties
+         (or in .classpath for Eclipse projects).
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems. -->
+    <loadproperties srcFile="project.properties" />
+
+    <!-- quick check on sdk.dir -->
+    <fail
+            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
+            unless="sdk.dir"
+    />
+
+    <!--
+        Import per project custom build rules if present at the root of the project.
+        This is the place to put custom intermediary targets such as:
+            -pre-build
+            -pre-compile
+            -post-compile (This is typically used for code obfuscation.
+                           Compiled code location: ${out.classes.absolute.dir}
+                           If this is not done in place, override ${out.dex.input.absolute.dir})
+            -post-package
+            -post-build
+            -pre-clean
+    -->
+    <import file="custom_rules.xml" optional="true" />
+
+    <!-- Import the actual build file.
+
+         To customize existing targets, there are two options:
+         - Customize only one target:
+             - copy/paste the target into this file, *before* the
+               <import> task.
+             - customize it to your needs.
+         - Customize the whole content of build.xml
+             - copy/paste the content of the rules files (minus the top node)
+               into this file, replacing the <import> task.
+             - customize to your needs.
+
+         ***********************
+         ****** IMPORTANT ******
+         ***********************
+         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
+         in order to avoid having your file be overridden by tools such as "android update project"
+    -->
+    <!-- version-tag: 1 -->
+    <import file="${sdk.dir}/tools/ant/build.xml" />
+
+</project>

Property changes on: android-project/build.xml
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: android-project/default.properties
===================================================================
--- android-project/default.properties	(revision 0)
+++ android-project/default.properties	(working copy)
@@ -0,0 +1,11 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+# 
+# This file must be checked in Version Control Systems.
+# 
+# To customize properties used by the Ant build system use,
+# "build.properties", and override values to adapt the script to your
+# project structure.
+
+# Project target.
+target=android-17

Property changes on: android-project/default.properties
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: android-project/instructions.txt
===================================================================
--- android-project/instructions.txt	(revision 0)
+++ android-project/instructions.txt	(working copy)
@@ -0,0 +1,90 @@
+NOTE: Chances are the (unofficially modified) DOSBox app *will* crash sooner or
+later, although one may still build a proper package.
+A default for DOSBox settings have been selected to make this (somewhat)
+more stable on Android and perform better: output=texture.
+Furthermore, cycles=max is the default on Android with this patch, so DOSBox
+is (again somewhat) faster out-of-the-box. Do *not* expect great performance,
+though.
+
+Instructions for building DOSBox (unofficial modification) for Android
+(originally done on a GNU/Linux desktop, may work on other platforms):
+
+1. Move/symlink SDL2 into the jni subdirectory. The directory name should be
+"SDL" (yeah, without the '2'). The SDL2 library itself can be obtained from
+the SDL website: http://www.libsdl.org/download-2.0.php
+
+2. Also move/symlink SDL2_net into the jni directory. The dir name should be
+"SDL_net" (again with no '2'). It can be obtained from the SDL_net webpage:
+http://www.libsdl.org/projects/SDL_net/
+
+In case of issues you can (probably) disable the usage of SDL_net in config.h,
+by disabling the various networking features.
+
+3. In general, you may want to play with the config.h file.
+Note that right now, SDL_sound is not used.
+
+4. Ensure that the "res" subdirectory has ready icons, as these are *not*
+bundled with the patch itself (which is textual). For instance, you should have
+a file given by the relative path android-project/res/drawable-ldpi/icon.png.
+
+5. With the exception of the first three steps (copying the android-project
+directory, moving/symlinking SDL and adding source files to Android.mk),
+follow all steps from the file README-android.txt bundled with SDL 2.0.
+
+6. Assuming it has actually been built successfully, there are great chances
+that the app is going to crash at some point. Maybe the splash screen can be
+seen for a little while before the crash. If the app has survived so far, you
+should find a dosbox-SVN.conf file on the (internal) SD card that you may like
+to edit. On many single-user devices it should be located at the relative path
+Android/data/com.dosbox.emu/files/ (relatively to the SD card's root).
+Playing with settings like "output", "machine" and "nosound" can help here. In
+fact, playing with any DOSBox setting you can think of can help. There are very
+great chances that a crash will occur at some later point, though.
+
+7. Considering this revision of the patch, an on-screen keyboard can be toggled
+using the Back button. Furthermore, physical keyboards can also be used
+(e.g. via Bluetooth or USB-OTG). For testing only the following "WiFi Keyboard"
+app can partially be used like a physical keyboard is connected directly:
+https://play.google.com/store/apps/details?id=com.volosyukivan
+
+Please note that in earlier revisions of this patch, the on-screen keyboard
+could be toggled using the Menu button, while the Back button simulated a
+client Escape key press by default. However, some newer Android-powered devices
+may come with built-in system buttons, but not such a Menu button, implying
+that a (relatively) large portion of the screen may be wasted simply for
+displaying an on-screen Menu button (and no more). So, the Back button is used
+for toggling the on-screen keyboard now. If you are interested in Escape key
+emulation, see the last point (and rough sketch) regarding mouse emulation.
+
+8. Assuming you do get a working command prompt within DOSBox, you may also
+type the following command in order to find the location of the dosbox-SVN.conf
+file (and save the currently set settings):
+
+config -writeconf
+
+9. Be warned that, at least on newer Android setups, the configuration file
+(along with the whole directory in which it resides) gets DELETED once you
+uninstall DOSBox. In fact, this is the behavior with Android apps in general
+(on such setups).
+
+10. A few very-basic changes have been applied to the mapper UI, but it is
+wrong to say it is fully ready. In particular, an accelerometer sensor
+(currently identified as an SDL joystick) may interfere with remaps. In such a
+case you may wish to manually edit your own customized mapper file or disable
+the (host) accelerometer/joystick subsystem.
+
+11. As for mouse emulation, mouse motion and button presses/releases are
+currently emulated by tapping on specific "invisible" portions of the screen.
+Yeah, it may not be the best way, but this is what you have for now.
+Note that mouse motion is emulated by using the touchscreen the way one uses a
+laptop's trackpad, i.e. in a "relative" fashion. For instance, to move a mouse
+cursor in some DOS game to the left, tap with a finger on an arbitrary location
+on the relevant part of the screen and then drag the finger to the left.
+
+Here are parts of the touch screen (the whole display) and what each of them
+emulates. These are all client mouse events, with the exception of the Escape
+key, which is a *host* key event and can be mapped to various things.
+
+/-----------------------------------------------------------------------\
+|    Left   | (H)Escape |   Motion  |  Motion   |   Middle  |   Right   |
+\-----------------------------------------------------------------------/

Property changes on: android-project/instructions.txt
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: android-project/jni/Android.mk
===================================================================
--- android-project/jni/Android.mk	(revision 0)
+++ android-project/jni/Android.mk	(working copy)
@@ -0,0 +1 @@
+include $(call all-subdir-makefiles)

Property changes on: android-project/jni/Android.mk
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: android-project/jni/Application.mk
===================================================================
--- android-project/jni/Application.mk	(revision 0)
+++ android-project/jni/Application.mk	(working copy)
@@ -0,0 +1,6 @@
+
+# Uncomment this if you're using STL in your project
+# See CPLUSPLUS-SUPPORT.html in the NDK documentation for more information
+# APP_STL := stlport_static 
+APP_STL := stlport_shared
+APP_ABI := armeabi armeabi-v7a x86

Property changes on: android-project/jni/Application.mk
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: android-project/jni/src/Android.mk
===================================================================
--- android-project/jni/src/Android.mk	(revision 0)
+++ android-project/jni/src/Android.mk	(working copy)
@@ -0,0 +1,82 @@
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE := main
+
+SDL_PATH := ../SDL
+SDL_NET_PATH := ../SDL_net
+
+LOCAL_C_INCLUDES := $(LOCAL_PATH)/$(SDL_PATH)/include \
+	$(LOCAL_PATH)/$(SDL_NET_PATH) \
+	../../../include
+
+ifeq ($(TARGET_ARCH_ABI),armeabi-v7a)
+	LOCAL_CPPFLAGS += -DC_TARGETCPU=ARMV7LE
+endif
+ifeq ($(TARGET_ARCH_ABI),armeabi)
+	LOCAL_CPPFLAGS += -DC_TARGETCPU=ARMV4LE
+endif
+ifeq ($(TARGET_ARCH_ABI),x86)
+	LOCAL_CPPFLAGS += -DC_TARGETCPU=X86 -DC_FPU_X86=1
+endif
+ifeq ($(TARGET_ARCH_ABI),mips)
+	LOCAL_CPPFLAGS += -DC_TARGETCPU=MIPSEL
+endif
+# Some sizes for a few types (for now architecture independent but possibly not)
+LOCAL_CPPFLAGS += -DSIZEOF_INT_P=4 \
+	-DSIZEOF_UNSIGNED_CHAR=1 \
+	-DSIZEOF_UNSIGNED_INT=4 \
+	-DSIZEOF_UNSIGNED_LONG=4 \
+	-DSIZEOF_UNSIGNED_LONG_LONG=8 \
+	-DSIZEOF_UNSIGNED_SHORT=2
+
+LOCAL_SRC_PATH := ../../../src
+
+LOCAL_CPP_FEATURES += exceptions
+
+# Note: We don't want any cdrom cpp file differing from cdrom_image.cpp.
+# Furthermore, we compile zmbv.cpp only... and even that can't be done
+# without zlib. So, let's give up for now.
+LOCAL_SRC_FILES := $(SDL_PATH)/src/main/android/SDL_android_main.c \
+	$(wildcard $(LOCAL_SRC_PATH)/dosbox.cpp) \
+	\
+	$(wildcard $(LOCAL_SRC_PATH)/cpu/*.c) \
+	$(wildcard $(LOCAL_SRC_PATH)/cpu/*.cpp) \
+	$(wildcard $(LOCAL_SRC_PATH)/core_dynrec/*.c) \
+	$(wildcard $(LOCAL_SRC_PATH)/core_dynrec/*.cpp) \
+	$(wildcard $(LOCAL_SRC_PATH)/core_dyn_x86/*.c) \
+	$(wildcard $(LOCAL_SRC_PATH)/core_dyn_x86/*.cpp) \
+	$(wildcard $(LOCAL_SRC_PATH)/core_full/*.c) \
+	$(wildcard $(LOCAL_SRC_PATH)/core_full/*.cpp) \
+	$(wildcard $(LOCAL_SRC_PATH)/core_normal/*.c) \
+	$(wildcard $(LOCAL_SRC_PATH)/core_normal/*.cpp) \
+	$(wildcard $(LOCAL_SRC_PATH)/debug/*.c) \
+	$(wildcard $(LOCAL_SRC_PATH)/debug/*.cpp) \
+	\
+	$(wildcard $(LOCAL_SRC_PATH)/dos/cdrom.cpp) \
+	$(wildcard $(LOCAL_SRC_PATH)/dos/cdrom_image.cpp) \
+	$(wildcard $(LOCAL_SRC_PATH)/dos/d*.cpp) \
+	\
+	$(wildcard $(LOCAL_SRC_PATH)/fpu/*.c) \
+	$(wildcard $(LOCAL_SRC_PATH)/fpu/*.cpp) \
+	$(wildcard $(LOCAL_SRC_PATH)/gui/*.c) \
+	$(wildcard $(LOCAL_SRC_PATH)/gui/*.cpp) \
+	$(wildcard $(LOCAL_SRC_PATH)/hardware/*.c) \
+	$(wildcard $(LOCAL_SRC_PATH)/hardware/*.cpp) \
+	$(wildcard $(LOCAL_SRC_PATH)/hardware/serialport/*.c) \
+	$(wildcard $(LOCAL_SRC_PATH)/hardware/serialport/*.cpp) \
+	$(wildcard $(LOCAL_SRC_PATH)/ints/*.c) \
+	$(wildcard $(LOCAL_SRC_PATH)/ints/*.cpp) \
+	$(wildcard $(LOCAL_SRC_PATH)/libs/*.c) \
+	$(wildcard $(LOCAL_SRC_PATH)/libs/*.cpp) \
+	$(wildcard $(LOCAL_SRC_PATH)/misc/*.c) \
+	$(wildcard $(LOCAL_SRC_PATH)/misc/*.cpp) \
+	$(wildcard $(LOCAL_SRC_PATH)/shell/*.c) \
+	$(wildcard $(LOCAL_SRC_PATH)/shell/*.cpp)
+
+LOCAL_SHARED_LIBRARIES := SDL2 SDL2_net
+
+LOCAL_LDLIBS := -lGLESv1_CM -llog
+
+include $(BUILD_SHARED_LIBRARY)

Property changes on: android-project/jni/src/Android.mk
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: android-project/jni/src/config.h
===================================================================
--- android-project/jni/src/config.h	(revision 0)
+++ android-project/jni/src/config.h	(working copy)
@@ -0,0 +1,314 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+
+/*
+ *  Copyright (C) 2002-2013  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+
+/* Define if building universal (internal helper macro) */
+/* #undef AC_APPLE_UNIVERSAL_BUILD */
+
+/* Compiling on BSD */
+/* #undef BSD */
+
+/* Determines if the compilers supports always_inline attribute. */
+#define C_ATTRIBUTE_ALWAYS_INLINE 1
+
+/* Determines if the compilers supports fastcall attribute. */
+/* #undef C_ATTRIBUTE_FASTCALL */
+
+/* Define to 1 to use inlined memory functions in cpu core */
+/* #undef C_CORE_INLINE */
+
+/* Define to 1 to enable internal debugger, requires libcurses */
+/* #undef C_DEBUG */
+
+/* Define to 1 to use x86 dynamic cpu core */
+/* NOTE: Right now it doesn't compile (possibly due to ASM code), so don't use.
+#ifdef __i386__
+#define C_DYNAMIC_X86 1
+#endif
+*/
+
+/* Define to 1 to use recompiling cpu core. Can not be used together with the
+   dynamic-x86 core */
+/* NOTE: For now we use this even on x86. */
+#define C_DYNREC 1
+
+/* Define to 1 to enable floating point emulation */
+#define C_FPU 1
+
+/* Define to 1 to use a x86 assembly fpu core */
+/* NOTE: Defined in Android.mk if desired. */
+/* #undef C_FPU_X86 */
+
+/* Determines if the compilers supports attributes for structures. */
+#define C_HAS_ATTRIBUTE 1
+
+/* Determines if the compilers supports __builtin_expect for branch
+   prediction. */
+#define C_HAS_BUILTIN_EXPECT 1
+
+/* Define to 1 if you have the mprotect function */
+#define C_HAVE_MPROTECT 1
+
+/* Define to 1 to enable heavy debugging, also have to enable C_DEBUG */
+/* #undef C_HEAVY_DEBUG */
+
+/* Define to 1 to enable IPX over Internet networking, requires SDL_net */
+#define C_IPX 1
+
+/* Define to 1 to enable internal modem support, requires SDL_net */
+#define C_MODEM 1
+
+/* Define to 1 to use opengl display output support */
+/* (actually OpenGL ES 1.1 on Android) */
+#define C_OPENGL 1
+
+/* Define to 1 to enable SDL_sound support */
+/* #undef C_SDL_SOUND */
+
+/* Define to 1 if you have setpriority support */
+/* #undef C_SET_PRIORITY 1 */
+
+/* Define to 1 to enable screenshots, requires libpng */
+/* #undef C_SSHOT */
+
+/* The type of cpu this target has */
+/* NOTE: Defined from Android.mk. */
+#ifndef C_TARGETCPU
+#error "Target (host) CPU is unknown! Please check the contents of Android.mk."
+#endif
+
+/* Define to 1 to use a unaligned memory access */
+#define C_UNALIGNED_MEMORY 1
+
+/* libm doesn't include powf */
+/* #undef DB_HAVE_NO_POWF */
+
+/* struct dirent has d_type */
+#define DIRENT_HAS_D_TYPE 1
+
+/* environ can be included */
+/* #undef ENVIRON_INCLUDED */
+
+/* environ can be linked */
+#define ENVIRON_LINKED 1
+
+/* Define to 1 if you have the <ddraw.h> header file. */
+/* #undef HAVE_DDRAW_H */
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the <netinet/in.h> header file. */
+#define HAVE_NETINET_IN_H 1
+
+/* Define to 1 if you have the <pwd.h> header file. */
+#define HAVE_PWD_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+#define HAVE_SYS_SOCKET_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Compiling on GNU/Linux */
+#define LINUX 1
+
+/* Compiling on Mac OS X */
+/* #undef MACOSX */
+
+/* Compiling on OS/2 EMX */
+/* #undef OS2 */
+
+/* Name of package */
+#define PACKAGE "dosbox"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "dosbox"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "dosbox SVN"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "dosbox"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "SVN"
+
+/* The size of `int *', as computed by sizeof. */
+/* NOTE: Defined in Android.mk. */
+/* #undef SIZEOF_INT_P */
+
+/* The size of `unsigned char', as computed by sizeof. */
+/* NOTE: Defined in Android.mk. */
+/* #undef SIZEOF_UNSIGNED_CHAR */
+
+/* The size of `unsigned int', as computed by sizeof. */
+/* NOTE: Defined in Android.mk. */
+/* #undef SIZEOF_UNSIGNED_INT */
+
+/* The size of `unsigned long', as computed by sizeof. */
+/* NOTE: Defined in Android.mk. */
+/* #undef SIZEOF_UNSIGNED_LONG */
+
+/* The size of `unsigned long long', as computed by sizeof. */
+/* NOTE: Defined in Android.mk. */
+/* #undef SIZEOF_UNSIGNED_LONG_LONG */ 
+
+/* The size of `unsigned short', as computed by sizeof. */
+/* NOTE: Defined in Android.mk. */
+/* #undef SIZEOF_UNSIGNED_SHORT */
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define to 1 if your <sys/time.h> declares `struct tm'. */
+/* #undef TM_IN_SYS_TIME */
+
+/* Version number of package */
+#define VERSION "SVN"
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if defined AC_APPLE_UNIVERSAL_BUILD
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#else
+# ifndef WORDS_BIGENDIAN
+/* #  undef WORDS_BIGENDIAN */
+# endif
+#endif
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef const */
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+/* #undef inline */
+#endif
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+/* #undef size_t */
+
+/* Define to `int` if you don't have socklen_t */
+/* #undef socklen_t */
+
+#if C_ATTRIBUTE_ALWAYS_INLINE
+#define INLINE inline __attribute__((always_inline))
+#else
+#define INLINE inline
+#endif
+
+#if C_ATTRIBUTE_FASTCALL
+#define DB_FASTCALL __attribute__((fastcall))
+#else
+#define DB_FASTCALL
+#endif
+
+#if C_HAS_ATTRIBUTE
+#define GCC_ATTRIBUTE(x) __attribute__ ((x))
+#else
+#define GCC_ATTRIBUTE(x) /* attribute not supported */
+#endif
+
+#if C_HAS_BUILTIN_EXPECT
+#define GCC_UNLIKELY(x) __builtin_expect((x),0)
+#define GCC_LIKELY(x) __builtin_expect((x),1)
+#else
+#define GCC_UNLIKELY(x) (x)
+#define GCC_LIKELY(x) (x)
+#endif
+
+
+typedef         double     Real64;
+
+#if SIZEOF_UNSIGNED_CHAR != 1
+#  error "sizeof (unsigned char) != 1"
+#else
+  typedef unsigned char Bit8u;
+  typedef   signed char Bit8s;
+#endif
+
+#if SIZEOF_UNSIGNED_SHORT != 2
+#  error "sizeof (unsigned short) != 2"
+#else
+  typedef unsigned short Bit16u;
+  typedef   signed short Bit16s;
+#endif
+
+#if SIZEOF_UNSIGNED_INT == 4
+  typedef unsigned int Bit32u;
+  typedef   signed int Bit32s;
+#elif SIZEOF_UNSIGNED_LONG == 4
+  typedef unsigned long Bit32u;
+  typedef   signed long Bit32s;
+#else
+#  error "can't find sizeof(type) of 4 bytes!"
+#endif
+
+#if SIZEOF_UNSIGNED_LONG == 8
+  typedef unsigned long Bit64u;
+  typedef   signed long Bit64s;
+#elif SIZEOF_UNSIGNED_LONG_LONG == 8
+  typedef unsigned long long Bit64u;
+  typedef   signed long long Bit64s;
+#else
+#  error "can't find data type of 8 bytes"
+#endif
+
+#if SIZEOF_INT_P == 4
+  typedef Bit32u Bitu;
+  typedef Bit32s Bits;
+#else
+  typedef Bit64u Bitu;
+  typedef Bit64s Bits;
+#endif
+
+

Property changes on: android-project/jni/src/config.h
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: android-project/proguard-project.txt
===================================================================
--- android-project/proguard-project.txt	(revision 0)
+++ android-project/proguard-project.txt	(working copy)
@@ -0,0 +1,20 @@
+# To enable ProGuard in your project, edit project.properties
+# to define the proguard.config property as described in that file.
+#
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in ${sdk.dir}/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the ProGuard
+# include property in project.properties.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}

Property changes on: android-project/proguard-project.txt
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: android-project/project.properties
===================================================================
--- android-project/project.properties	(revision 0)
+++ android-project/project.properties	(working copy)
@@ -0,0 +1,14 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-17

Property changes on: android-project/project.properties
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: android-project/res/layout/main.xml
===================================================================
--- android-project/res/layout/main.xml	(revision 0)
+++ android-project/res/layout/main.xml	(working copy)
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:orientation="vertical"
+    android:layout_width="fill_parent"
+    android:layout_height="fill_parent"
+    >
+<TextView  
+    android:layout_width="fill_parent" 
+    android:layout_height="wrap_content" 
+    android:text="Hello World, SDLActivity"
+    />
+</LinearLayout>
+

Property changes on: android-project/res/layout/main.xml
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: android-project/res/values/strings.xml
===================================================================
--- android-project/res/values/strings.xml	(revision 0)
+++ android-project/res/values/strings.xml	(working copy)
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="app_name">DOSBox</string>
+</resources>

Property changes on: android-project/res/values/strings.xml
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: android-project/src/com/dosbox/emu/DOSBoxActivity.java
===================================================================
--- android-project/src/com/dosbox/emu/DOSBoxActivity.java	(revision 0)
+++ android-project/src/com/dosbox/emu/DOSBoxActivity.java	(working copy)
@@ -0,0 +1,59 @@
+package com.dosbox.emu;
+
+import org.libsdl.app.SDLActivity;
+import android.content.Context;
+import android.content.pm.ActivityInfo;
+import android.content.res.Configuration;
+import android.os.Bundle;
+import android.view.Surface;
+import android.view.KeyEvent;
+import android.view.inputmethod.InputMethodManager;
+
+/* 
+ * A sample wrapper class that just calls SDLActivity 
+ */ 
+
+public class DOSBoxActivity extends SDLActivity {
+    /* Based on volume keys related patch from bug report:
+    http://bugzilla.libsdl.org/show_bug.cgi?id=1569     */
+
+    // enable to intercept keys before SDL gets them
+    @Override
+    public boolean dispatchKeyEvent(KeyEvent event) {
+        switch (event.getKeyCode()) {
+        // Show/Hide on-screen keyboard (but don't toggle text input mode)
+        case KeyEvent.KEYCODE_BACK:
+            if (event.getAction() == KeyEvent.ACTION_UP) {
+                toggleOnScreenKeyboard();
+            }
+            return true;
+        }
+        return super.dispatchKeyEvent(event);
+    }
+
+    // Fix the initial orientation
+    protected void onCreate(Bundle savedInstanceState) {
+        /* Use deprecated getOrientation() rather
+        than getRotation() to support API<8    */
+/*
+        int rotation = getWindowManager().getDefaultDisplay().getOrientation();
+        if (getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT) {
+            if ((rotation == Surface.ROTATION_0) || (rotation == Surface.ROTATION_90))
+                setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+            else
+                setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT);
+        } else { // Landscape
+            if ((rotation == Surface.ROTATION_0) || (rotation == Surface.ROTATION_90))
+                setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
+            else
+                setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE);
+        }
+*/
+        super.onCreate(savedInstanceState); // Initialize the rest (e.g. SDL)
+    }
+
+    public void toggleOnScreenKeyboard() {
+        InputMethodManager imm = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
+        imm.toggleSoftInput(0, 0);
+    }
+}

Property changes on: android-project/src/com/dosbox/emu/DOSBoxActivity.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: android-project/src/org/libsdl/app/SDLActivity.java
===================================================================
--- android-project/src/org/libsdl/app/SDLActivity.java	(revision 0)
+++ android-project/src/org/libsdl/app/SDLActivity.java	(working copy)
@@ -0,0 +1,1077 @@
+package org.libsdl.app;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+
+import android.app.*;
+import android.content.*;
+import android.view.*;
+import android.view.inputmethod.BaseInputConnection;
+import android.view.inputmethod.EditorInfo;
+import android.view.inputmethod.InputConnection;
+import android.view.inputmethod.InputMethodManager;
+import android.widget.AbsoluteLayout;
+import android.os.*;
+import android.util.Log;
+import android.graphics.*;
+import android.media.*;
+import android.hardware.*;
+
+
+/**
+    SDL Activity
+*/
+public class SDLActivity extends Activity {
+    private static final String TAG = "SDL";
+
+    // Keep track of the paused state
+    public static boolean mIsPaused, mIsSurfaceReady, mHasFocus;
+    public static boolean mExitCalledFromJava;
+
+    // Main components
+    protected static SDLActivity mSingleton;
+    protected static SDLSurface mSurface;
+    protected static View mTextEdit;
+    protected static ViewGroup mLayout;
+    protected static SDLJoystickHandler mJoystickHandler;
+
+    // This is what SDL runs in. It invokes SDL_main(), eventually
+    protected static Thread mSDLThread;
+    
+    // Audio
+    protected static AudioTrack mAudioTrack;
+
+    // Load the .so
+    static {
+        System.loadLibrary("stlport_shared");
+        System.loadLibrary("SDL2");
+        //System.loadLibrary("SDL2_image");
+        //System.loadLibrary("SDL2_mixer");
+        System.loadLibrary("SDL2_net");
+        //System.loadLibrary("SDL2_ttf");
+        System.loadLibrary("main");
+    }
+    
+    
+    public static void initialize() {
+        // The static nature of the singleton and Android quirkyness force us to initialize everything here
+        // Otherwise, when exiting the app and returning to it, these variables *keep* their pre exit values
+        mSingleton = null;
+        mSurface = null;
+        mTextEdit = null;
+        mLayout = null;
+        mJoystickHandler = null;
+        mSDLThread = null;
+        mAudioTrack = null;
+        mExitCalledFromJava = false;
+        mIsPaused = false;
+        mIsSurfaceReady = false;
+        mHasFocus = true;
+    }
+
+    // Setup
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        Log.v("SDL", "onCreate():" + mSingleton);
+        super.onCreate(savedInstanceState);
+        
+        SDLActivity.initialize();
+        // So we can call stuff from static callbacks
+        mSingleton = this;
+
+        // Set up the surface
+        mSurface = new SDLSurface(getApplication());
+        
+        if(Build.VERSION.SDK_INT >= 12) {
+            mJoystickHandler = new SDLJoystickHandler_API12();
+        }
+        else {
+            mJoystickHandler = new SDLJoystickHandler();
+        }
+
+        mLayout = new AbsoluteLayout(this);
+        mLayout.addView(mSurface);
+
+        setContentView(mLayout);
+    }
+
+    // Events
+    @Override
+    protected void onPause() {
+        Log.v("SDL", "onPause()");
+        super.onPause();
+        SDLActivity.handlePause();
+    }
+
+    @Override
+    protected void onResume() {
+        Log.v("SDL", "onResume()");
+        super.onResume();
+        SDLActivity.handleResume();
+    }
+
+
+    @Override
+    public void onWindowFocusChanged(boolean hasFocus) {
+        super.onWindowFocusChanged(hasFocus);
+        Log.v("SDL", "onWindowFocusChanged(): " + hasFocus);
+
+        SDLActivity.mHasFocus = hasFocus;
+        if (hasFocus) {
+            SDLActivity.handleResume();
+        }
+    }
+
+    @Override
+    public void onLowMemory() {
+        Log.v("SDL", "onLowMemory()");
+        super.onLowMemory();
+        SDLActivity.nativeLowMemory();
+    }
+
+    @Override
+    protected void onDestroy() {
+        Log.v("SDL", "onDestroy()");
+        // Send a quit message to the application
+        SDLActivity.mExitCalledFromJava = true;
+        SDLActivity.nativeQuit();
+
+        // Now wait for the SDL thread to quit
+        if (SDLActivity.mSDLThread != null) {
+            try {
+                SDLActivity.mSDLThread.join();
+            } catch(Exception e) {
+                Log.v("SDL", "Problem stopping thread: " + e);
+            }
+            SDLActivity.mSDLThread = null;
+
+            //Log.v("SDL", "Finished waiting for SDL thread");
+        }
+            
+        super.onDestroy();
+        // Reset everything in case the user re opens the app
+        SDLActivity.initialize();
+    }
+
+    @Override
+    public boolean dispatchKeyEvent(KeyEvent event) {
+        int keyCode = event.getKeyCode();
+        // Ignore certain special keys so they're handled by Android
+        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN ||
+            keyCode == KeyEvent.KEYCODE_VOLUME_UP ||
+            keyCode == KeyEvent.KEYCODE_CAMERA ||
+            keyCode == 168 || /* API 11: KeyEvent.KEYCODE_ZOOM_IN */
+            keyCode == 169 /* API 11: KeyEvent.KEYCODE_ZOOM_OUT */
+            ) {
+            return false;
+        }
+        return super.dispatchKeyEvent(event);
+    }
+
+    /** Called by onPause or surfaceDestroyed. Even if surfaceDestroyed
+     *  is the first to be called, mIsSurfaceReady should still be set
+     *  to 'true' during the call to onPause (in a usual scenario).
+     */
+    public static void handlePause() {
+        if (!SDLActivity.mIsPaused && SDLActivity.mIsSurfaceReady) {
+            SDLActivity.mIsPaused = true;
+            SDLActivity.nativePause();
+            mSurface.enableSensor(Sensor.TYPE_ACCELEROMETER, false);
+        }
+    }
+
+    /** Called by onResume or surfaceCreated. An actual resume should be done only when the surface is ready.
+     * Note: Some Android variants may send multiple surfaceChanged events, so we don't need to resume
+     * every time we get one of those events, only if it comes after surfaceDestroyed
+     */
+    public static void handleResume() {
+        if (SDLActivity.mIsPaused && SDLActivity.mIsSurfaceReady && SDLActivity.mHasFocus) {
+            SDLActivity.mIsPaused = false;
+            SDLActivity.nativeResume();
+            mSurface.enableSensor(Sensor.TYPE_ACCELEROMETER, true);
+        }
+    }
+        
+    /* The native thread has finished */
+    public static void handleNativeExit() {
+        SDLActivity.mSDLThread = null;
+        mSingleton.finish();
+    }
+
+
+    // Messages from the SDLMain thread
+    static final int COMMAND_CHANGE_TITLE = 1;
+    static final int COMMAND_UNUSED = 2;
+    static final int COMMAND_TEXTEDIT_HIDE = 3;
+
+    protected static final int COMMAND_USER = 0x8000;
+
+    /**
+     * This method is called by SDL if SDL did not handle a message itself.
+     * This happens if a received message contains an unsupported command.
+     * Method can be overwritten to handle Messages in a different class.
+     * @param command the command of the message.
+     * @param param the parameter of the message. May be null.
+     * @return if the message was handled in overridden method.
+     */
+    protected boolean onUnhandledMessage(int command, Object param) {
+        return false;
+    }
+
+    /**
+     * A Handler class for Messages from native SDL applications.
+     * It uses current Activities as target (e.g. for the title).
+     * static to prevent implicit references to enclosing object.
+     */
+    protected static class SDLCommandHandler extends Handler {
+        @Override
+        public void handleMessage(Message msg) {
+            Context context = getContext();
+            if (context == null) {
+                Log.e(TAG, "error handling message, getContext() returned null");
+                return;
+            }
+            switch (msg.arg1) {
+            case COMMAND_CHANGE_TITLE:
+                if (context instanceof Activity) {
+                    ((Activity) context).setTitle((String)msg.obj);
+                } else {
+                    Log.e(TAG, "error handling message, getContext() returned no Activity");
+                }
+                break;
+            case COMMAND_TEXTEDIT_HIDE:
+                if (mTextEdit != null) {
+                    mTextEdit.setVisibility(View.GONE);
+
+                    InputMethodManager imm = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
+                    imm.hideSoftInputFromWindow(mTextEdit.getWindowToken(), 0);
+                }
+                break;
+
+            default:
+                if ((context instanceof SDLActivity) && !((SDLActivity) context).onUnhandledMessage(msg.arg1, msg.obj)) {
+                    Log.e(TAG, "error handling message, command is " + msg.arg1);
+                }
+            }
+        }
+    }
+
+    // Handler for the messages
+    Handler commandHandler = new SDLCommandHandler();
+
+    // Send a message from the SDLMain thread
+    boolean sendCommand(int command, Object data) {
+        Message msg = commandHandler.obtainMessage();
+        msg.arg1 = command;
+        msg.obj = data;
+        return commandHandler.sendMessage(msg);
+    }
+
+    // C functions we call
+    public static native void nativeInit();
+    public static native void nativeLowMemory();
+    public static native void nativeQuit();
+    public static native void nativePause();
+    public static native void nativeResume();
+    public static native void onNativeResize(int x, int y, int format);
+    public static native int onNativePadDown(int device_id, int keycode);
+    public static native int onNativePadUp(int device_id, int keycode);
+    public static native void onNativeJoy(int device_id, int axis,
+                                          float value);
+    public static native void onNativeHat(int device_id, int hat_id,
+                                          int x, int y);
+    public static native void onNativeKeyDown(int keycode);
+    public static native void onNativeKeyUp(int keycode);
+    public static native void onNativeKeyboardFocusLost();
+    public static native void onNativeTouch(int touchDevId, int pointerFingerId,
+                                            int action, float x, 
+                                            float y, float p);
+    public static native void onNativeAccel(float x, float y, float z);
+    public static native void onNativeSurfaceChanged();
+    public static native void onNativeSurfaceDestroyed();
+    public static native void nativeFlipBuffers();
+    public static native int nativeAddJoystick(int device_id, String name, 
+                                               int is_accelerometer, int nbuttons, 
+                                               int naxes, int nhats, int nballs);
+    public static native int nativeRemoveJoystick(int device_id);
+
+    public static void flipBuffers() {
+        SDLActivity.nativeFlipBuffers();
+    }
+
+    public static boolean setActivityTitle(String title) {
+        // Called from SDLMain() thread and can't directly affect the view
+        return mSingleton.sendCommand(COMMAND_CHANGE_TITLE, title);
+    }
+
+    public static boolean sendMessage(int command, int param) {
+        return mSingleton.sendCommand(command, Integer.valueOf(param));
+    }
+
+    public static Context getContext() {
+        return mSingleton;
+    }
+
+    /**
+     * @return result of getSystemService(name) but executed on UI thread.
+     */
+    public Object getSystemServiceFromUiThread(final String name) {
+        final Object lock = new Object();
+        final Object[] results = new Object[2]; // array for writable variables
+        synchronized (lock) {
+            runOnUiThread(new Runnable() {
+                @Override
+                public void run() {
+                    synchronized (lock) {
+                        results[0] = getSystemService(name);
+                        results[1] = Boolean.TRUE;
+                        lock.notify();
+                    }
+                }
+            });
+            if (results[1] == null) {
+                try {
+                    lock.wait();
+                } catch (InterruptedException ex) {
+                    ex.printStackTrace();
+                }
+            }
+        }
+        return results[0];
+    }
+
+    static class ShowTextInputTask implements Runnable {
+        /*
+         * This is used to regulate the pan&scan method to have some offset from
+         * the bottom edge of the input region and the top edge of an input
+         * method (soft keyboard)
+         */
+        static final int HEIGHT_PADDING = 15;
+
+        public int x, y, w, h;
+
+        public ShowTextInputTask(int x, int y, int w, int h) {
+            this.x = x;
+            this.y = y;
+            this.w = w;
+            this.h = h;
+        }
+
+        @Override
+        public void run() {
+            AbsoluteLayout.LayoutParams params = new AbsoluteLayout.LayoutParams(
+                    w, h + HEIGHT_PADDING, x, y);
+
+            if (mTextEdit == null) {
+                mTextEdit = new DummyEdit(getContext());
+
+                mLayout.addView(mTextEdit, params);
+            } else {
+                mTextEdit.setLayoutParams(params);
+            }
+
+            mTextEdit.setVisibility(View.VISIBLE);
+            mTextEdit.requestFocus();
+
+            InputMethodManager imm = (InputMethodManager) getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
+            imm.showSoftInput(mTextEdit, 0);
+        }
+    }
+
+    public static boolean showTextInput(int x, int y, int w, int h) {
+        // Transfer the task to the main thread as a Runnable
+        return mSingleton.commandHandler.post(new ShowTextInputTask(x, y, w, h));
+    }
+            
+    public static Surface getNativeSurface() {
+        return SDLActivity.mSurface.getNativeSurface();
+    }
+
+    // Audio
+    public static int audioInit(int sampleRate, boolean is16Bit, boolean isStereo, int desiredFrames) {
+        int channelConfig = isStereo ? AudioFormat.CHANNEL_CONFIGURATION_STEREO : AudioFormat.CHANNEL_CONFIGURATION_MONO;
+        int audioFormat = is16Bit ? AudioFormat.ENCODING_PCM_16BIT : AudioFormat.ENCODING_PCM_8BIT;
+        int frameSize = (isStereo ? 2 : 1) * (is16Bit ? 2 : 1);
+        
+        Log.v("SDL", "SDL audio: wanted " + (isStereo ? "stereo" : "mono") + " " + (is16Bit ? "16-bit" : "8-bit") + " " + (sampleRate / 1000f) + "kHz, " + desiredFrames + " frames buffer");
+        
+        // Let the user pick a larger buffer if they really want -- but ye
+        // gods they probably shouldn't, the minimums are horrifyingly high
+        // latency already
+        desiredFrames = Math.max(desiredFrames, (AudioTrack.getMinBufferSize(sampleRate, channelConfig, audioFormat) + frameSize - 1) / frameSize);
+        
+        if (mAudioTrack == null) {
+            mAudioTrack = new AudioTrack(AudioManager.STREAM_MUSIC, sampleRate,
+                    channelConfig, audioFormat, desiredFrames * frameSize, AudioTrack.MODE_STREAM);
+            
+            // Instantiating AudioTrack can "succeed" without an exception and the track may still be invalid
+            // Ref: https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/media/java/android/media/AudioTrack.java
+            // Ref: http://developer.android.com/reference/android/media/AudioTrack.html#getState()
+            
+            if (mAudioTrack.getState() != AudioTrack.STATE_INITIALIZED) {
+                Log.e("SDL", "Failed during initialization of Audio Track");
+                mAudioTrack = null;
+                return -1;
+            }
+            
+            mAudioTrack.play();
+        }
+       
+        Log.v("SDL", "SDL audio: got " + ((mAudioTrack.getChannelCount() >= 2) ? "stereo" : "mono") + " " + ((mAudioTrack.getAudioFormat() == AudioFormat.ENCODING_PCM_16BIT) ? "16-bit" : "8-bit") + " " + (mAudioTrack.getSampleRate() / 1000f) + "kHz, " + desiredFrames + " frames buffer");
+        
+        return 0;
+    }
+    
+    public static void audioWriteShortBuffer(short[] buffer) {
+        for (int i = 0; i < buffer.length; ) {
+            int result = mAudioTrack.write(buffer, i, buffer.length - i);
+            if (result > 0) {
+                i += result;
+            } else if (result == 0) {
+                try {
+                    Thread.sleep(1);
+                } catch(InterruptedException e) {
+                    // Nom nom
+                }
+            } else {
+                Log.w("SDL", "SDL audio: error return from write(short)");
+                return;
+            }
+        }
+    }
+    
+    public static void audioWriteByteBuffer(byte[] buffer) {
+        for (int i = 0; i < buffer.length; ) {
+            int result = mAudioTrack.write(buffer, i, buffer.length - i);
+            if (result > 0) {
+                i += result;
+            } else if (result == 0) {
+                try {
+                    Thread.sleep(1);
+                } catch(InterruptedException e) {
+                    // Nom nom
+                }
+            } else {
+                Log.w("SDL", "SDL audio: error return from write(byte)");
+                return;
+            }
+        }
+    }
+
+    public static void audioQuit() {
+        if (mAudioTrack != null) {
+            mAudioTrack.stop();
+            mAudioTrack = null;
+        }
+    }
+
+    // Input
+
+    /**
+     * @return an array which may be empty but is never null.
+     */
+    public static int[] inputGetInputDeviceIds(int sources) {
+        int[] ids = InputDevice.getDeviceIds();
+        int[] filtered = new int[ids.length];
+        int used = 0;
+        for (int i = 0; i < ids.length; ++i) {
+            InputDevice device = InputDevice.getDevice(ids[i]);
+            if ((device != null) && ((device.getSources() & sources) != 0)) {
+                filtered[used++] = device.getId();
+            }
+        }
+        return Arrays.copyOf(filtered, used);
+    }
+            
+    // Joystick glue code, just a series of stubs that redirect to the SDLJoystickHandler instance
+    public static boolean handleJoystickMotionEvent(MotionEvent event) {
+        return mJoystickHandler.handleMotionEvent(event);
+    }
+    
+    public static void pollInputDevices() {
+        if (SDLActivity.mSDLThread != null) {
+            mJoystickHandler.pollInputDevices();
+        }
+    }
+    
+}
+
+/**
+    Simple nativeInit() runnable
+*/
+class SDLMain implements Runnable {
+    @Override
+    public void run() {
+        // Runs SDL_main()
+        SDLActivity.nativeInit();
+
+        //Log.v("SDL", "SDL thread terminated");
+    }
+}
+
+
+/**
+    SDLSurface. This is what we draw on, so we need to know when it's created
+    in order to do anything useful. 
+
+    Because of this, that's where we set up the SDL thread
+*/
+class SDLSurface extends SurfaceView implements SurfaceHolder.Callback, 
+    View.OnKeyListener, View.OnTouchListener, SensorEventListener  {
+
+    // Sensors
+    protected static SensorManager mSensorManager;
+    protected static Display mDisplay;
+
+    // Keep track of the surface size to normalize touch events
+    protected static float mWidth, mHeight;
+
+    // Startup    
+    public SDLSurface(Context context) {
+        super(context);
+        getHolder().addCallback(this); 
+    
+        setFocusable(true);
+        setFocusableInTouchMode(true);
+        requestFocus();
+        setOnKeyListener(this); 
+        setOnTouchListener(this);   
+
+        mDisplay = ((WindowManager)context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
+        mSensorManager = (SensorManager)context.getSystemService(Context.SENSOR_SERVICE);
+        
+        if(Build.VERSION.SDK_INT >= 12) {
+            setOnGenericMotionListener(new SDLGenericMotionListener_API12());
+        }
+
+        // Some arbitrary defaults to avoid a potential division by zero
+        mWidth = 1.0f;
+        mHeight = 1.0f;
+    }
+    
+    public Surface getNativeSurface() {
+        return getHolder().getSurface();
+    }
+
+    // Called when we have a valid drawing surface
+    @Override
+    public void surfaceCreated(SurfaceHolder holder) {
+        Log.v("SDL", "surfaceCreated()");
+        holder.setType(SurfaceHolder.SURFACE_TYPE_GPU);
+    }
+
+    // Called when we lose the surface
+    @Override
+    public void surfaceDestroyed(SurfaceHolder holder) {
+        Log.v("SDL", "surfaceDestroyed()");
+        // Call this *before* setting mIsSurfaceReady to 'false'
+        SDLActivity.handlePause();
+        SDLActivity.mIsSurfaceReady = false;
+        SDLActivity.onNativeSurfaceDestroyed();
+    }
+
+    // Called when the surface is resized
+    @Override
+    public void surfaceChanged(SurfaceHolder holder,
+                               int format, int width, int height) {
+        Log.v("SDL", "surfaceChanged()");
+
+        int sdlFormat = 0x15151002; // SDL_PIXELFORMAT_RGB565 by default
+        switch (format) {
+        case PixelFormat.A_8:
+            Log.v("SDL", "pixel format A_8");
+            break;
+        case PixelFormat.LA_88:
+            Log.v("SDL", "pixel format LA_88");
+            break;
+        case PixelFormat.L_8:
+            Log.v("SDL", "pixel format L_8");
+            break;
+        case PixelFormat.RGBA_4444:
+            Log.v("SDL", "pixel format RGBA_4444");
+            sdlFormat = 0x15421002; // SDL_PIXELFORMAT_RGBA4444
+            break;
+        case PixelFormat.RGBA_5551:
+            Log.v("SDL", "pixel format RGBA_5551");
+            sdlFormat = 0x15441002; // SDL_PIXELFORMAT_RGBA5551
+            break;
+        case PixelFormat.RGBA_8888:
+            Log.v("SDL", "pixel format RGBA_8888");
+            sdlFormat = 0x16462004; // SDL_PIXELFORMAT_RGBA8888
+            break;
+        case PixelFormat.RGBX_8888:
+            Log.v("SDL", "pixel format RGBX_8888");
+            sdlFormat = 0x16261804; // SDL_PIXELFORMAT_RGBX8888
+            break;
+        case PixelFormat.RGB_332:
+            Log.v("SDL", "pixel format RGB_332");
+            sdlFormat = 0x14110801; // SDL_PIXELFORMAT_RGB332
+            break;
+        case PixelFormat.RGB_565:
+            Log.v("SDL", "pixel format RGB_565");
+            sdlFormat = 0x15151002; // SDL_PIXELFORMAT_RGB565
+            break;
+        case PixelFormat.RGB_888:
+            Log.v("SDL", "pixel format RGB_888");
+            // Not sure this is right, maybe SDL_PIXELFORMAT_RGB24 instead?
+            sdlFormat = 0x16161804; // SDL_PIXELFORMAT_RGB888
+            break;
+        default:
+            Log.v("SDL", "pixel format unknown " + format);
+            break;
+        }
+
+        mWidth = width;
+        mHeight = height;
+        SDLActivity.onNativeResize(width, height, sdlFormat);
+        Log.v("SDL", "Window size:" + width + "x"+height);
+
+        // Set mIsSurfaceReady to 'true' *before* making a call to handleResume
+        SDLActivity.mIsSurfaceReady = true;
+        SDLActivity.onNativeSurfaceChanged();
+
+
+        if (SDLActivity.mSDLThread == null) {
+            // This is the entry point to the C app.
+            // Start up the C app thread and enable sensor input for the first time
+
+            SDLActivity.mSDLThread = new Thread(new SDLMain(), "SDLThread");
+            enableSensor(Sensor.TYPE_ACCELEROMETER, true);
+            SDLActivity.mSDLThread.start();
+            
+            // Set up a listener thread to catch when the native thread ends
+            new Thread(new Runnable(){
+                @Override
+                public void run(){
+                    try {
+                        SDLActivity.mSDLThread.join();
+                    }
+                    catch(Exception e){}
+                    finally{ 
+                        // Native thread has finished
+                        if (! SDLActivity.mExitCalledFromJava) {
+                            SDLActivity.handleNativeExit();
+                        }
+                    }
+                }
+            }).start();
+        }
+    }
+
+    // unused
+    @Override
+    public void onDraw(Canvas canvas) {}
+
+
+    // Key events
+    @Override
+    public boolean onKey(View  v, int keyCode, KeyEvent event) {
+        // Dispatch the different events depending on where they come from
+        // Some SOURCE_DPAD or SOURCE_GAMEPAD are also SOURCE_KEYBOARD
+        // So, we try to process them as DPAD or GAMEPAD events first, if that fails we try them as KEYBOARD
+        
+        if ( (event.getSource() & 0x00000401) != 0 || /* API 12: SOURCE_GAMEPAD */
+                   (event.getSource() & InputDevice.SOURCE_DPAD) != 0 ) {
+            if (event.getAction() == KeyEvent.ACTION_DOWN) {
+                if (SDLActivity.onNativePadDown(event.getDeviceId(), keyCode) == 0) {
+                    return true;
+                }
+            } else if (event.getAction() == KeyEvent.ACTION_UP) {
+                if (SDLActivity.onNativePadUp(event.getDeviceId(), keyCode) == 0) {
+                    return true;
+                }
+            }
+        }
+        
+        // HACK: Get input from all keys of a soft-keyboard,
+        // even if InputDevice.SOURCE_KEYBOARD is not the source.
+//      if( (event.getSource() & InputDevice.SOURCE_KEYBOARD) != 0) {
+            if (event.getAction() == KeyEvent.ACTION_DOWN) {
+                //Log.v("SDL", "key down: " + keyCode);
+                SDLActivity.onNativeKeyDown(keyCode);
+                return true;
+            }
+            else if (event.getAction() == KeyEvent.ACTION_UP) {
+                //Log.v("SDL", "key up: " + keyCode);
+                SDLActivity.onNativeKeyUp(keyCode);
+                return true;
+            }
+//      }
+        
+        return false;
+    }
+
+    // Touch events
+    @Override
+    public boolean onTouch(View v, MotionEvent event) {
+        /* Ref: http://developer.android.com/training/gestures/multi.html */
+        final int touchDevId = event.getDeviceId();
+        final int pointerCount = event.getPointerCount();
+        int action = event.getActionMasked();
+        int pointerFingerId;
+        int i = -1;
+        float x,y,p;
+        
+        switch(action) {
+            case MotionEvent.ACTION_MOVE:
+                for (i = 0; i < pointerCount; i++) {
+                    pointerFingerId = event.getPointerId(i);
+                    x = event.getX(i) / mWidth;
+                    y = event.getY(i) / mHeight;
+                    p = event.getPressure(i);
+                    SDLActivity.onNativeTouch(touchDevId, pointerFingerId, action, x, y, p);
+                }
+                break;
+            
+            case MotionEvent.ACTION_UP:
+            case MotionEvent.ACTION_DOWN:
+                // Primary pointer up/down, the index is always zero
+                i = 0;
+            case MotionEvent.ACTION_POINTER_UP:
+            case MotionEvent.ACTION_POINTER_DOWN:
+                // Non primary pointer up/down
+                if (i == -1) {
+                    i = event.getActionIndex();
+                }
+                
+                pointerFingerId = event.getPointerId(i);
+                x = event.getX(i) / mWidth;
+                y = event.getY(i) / mHeight;
+                p = event.getPressure(i);
+                SDLActivity.onNativeTouch(touchDevId, pointerFingerId, action, x, y, p);
+                break;
+            
+            default:
+                break;
+        }
+
+        return true;
+   } 
+
+    // Sensor events
+    public void enableSensor(int sensortype, boolean enabled) {
+        // TODO: This uses getDefaultSensor - what if we have >1 accels?
+        if (enabled) {
+            mSensorManager.registerListener(this, 
+                            mSensorManager.getDefaultSensor(sensortype), 
+                            SensorManager.SENSOR_DELAY_GAME, null);
+        } else {
+            mSensorManager.unregisterListener(this, 
+                            mSensorManager.getDefaultSensor(sensortype));
+        }
+    }
+    
+    @Override
+    public void onAccuracyChanged(Sensor sensor, int accuracy) {
+        // TODO
+    }
+
+    @Override
+    public void onSensorChanged(SensorEvent event) {
+        if (event.sensor.getType() == Sensor.TYPE_ACCELEROMETER) {
+            float x, y;
+            switch (mDisplay.getRotation()) {
+                case Surface.ROTATION_90:
+                    x = -event.values[1];
+                    y = event.values[0];
+                    break;
+                case Surface.ROTATION_270:
+                    x = event.values[1];
+                    y = -event.values[0];
+                    break;
+                case Surface.ROTATION_180:
+                    x = -event.values[1];
+                    y = -event.values[0];
+                    break;
+                default:
+                    x = event.values[0];
+                    y = event.values[1];
+                    break;
+            }
+            SDLActivity.onNativeAccel(-x / SensorManager.GRAVITY_EARTH,
+                                      y / SensorManager.GRAVITY_EARTH,
+                                      event.values[2] / SensorManager.GRAVITY_EARTH - 1);
+        }
+    }    
+}
+
+/* This is a fake invisible editor view that receives the input and defines the
+ * pan&scan region
+ */
+class DummyEdit extends View implements View.OnKeyListener {
+    InputConnection ic;
+
+    public DummyEdit(Context context) {
+        super(context);
+        setFocusableInTouchMode(true);
+        setFocusable(true);
+        setOnKeyListener(this);
+    }
+
+    @Override
+    public boolean onCheckIsTextEditor() {
+        return true;
+    }
+
+    @Override
+    public boolean onKey(View v, int keyCode, KeyEvent event) {
+
+        // This handles the hardware keyboard input
+        if (event.isPrintingKey()) {
+            if (event.getAction() == KeyEvent.ACTION_DOWN) {
+                ic.commitText(String.valueOf((char) event.getUnicodeChar()), 1);
+            }
+            return true;
+        }
+
+        if (event.getAction() == KeyEvent.ACTION_DOWN) {
+            SDLActivity.onNativeKeyDown(keyCode);
+            return true;
+        } else if (event.getAction() == KeyEvent.ACTION_UP) {
+            SDLActivity.onNativeKeyUp(keyCode);
+            return true;
+        }
+
+        return false;
+    }
+        
+    //
+    @Override
+    public boolean onKeyPreIme (int keyCode, KeyEvent event) {
+        // As seen on StackOverflow: http://stackoverflow.com/questions/7634346/keyboard-hide-event
+        // FIXME: Discussion at http://bugzilla.libsdl.org/show_bug.cgi?id=1639
+        // FIXME: This is not a 100% effective solution to the problem of detecting if the keyboard is showing or not
+        // FIXME: A more effective solution would be to change our Layout from AbsoluteLayout to Relative or Linear
+        // FIXME: And determine the keyboard presence doing this: http://stackoverflow.com/questions/2150078/how-to-check-visibility-of-software-keyboard-in-android
+        // FIXME: An even more effective way would be if Android provided this out of the box, but where would the fun be in that :)
+        if (event.getAction()==KeyEvent.ACTION_UP && keyCode == KeyEvent.KEYCODE_BACK) {
+            if (SDLActivity.mTextEdit != null && SDLActivity.mTextEdit.getVisibility() == View.VISIBLE) {
+                SDLActivity.onNativeKeyboardFocusLost();
+            }
+        }
+        return super.onKeyPreIme(keyCode, event);
+    }
+
+    @Override
+    public InputConnection onCreateInputConnection(EditorInfo outAttrs) {
+        ic = new SDLInputConnection(this, true);
+
+        outAttrs.imeOptions = EditorInfo.IME_FLAG_NO_EXTRACT_UI
+                | 33554432 /* API 11: EditorInfo.IME_FLAG_NO_FULLSCREEN */;
+
+        return ic;
+    }
+}
+
+class SDLInputConnection extends BaseInputConnection {
+
+    public SDLInputConnection(View targetView, boolean fullEditor) {
+        super(targetView, fullEditor);
+
+    }
+
+    @Override
+    public boolean sendKeyEvent(KeyEvent event) {
+
+        /*
+         * This handles the keycodes from soft keyboard (and IME-translated
+         * input from hardkeyboard)
+         */
+        int keyCode = event.getKeyCode();
+        if (event.getAction() == KeyEvent.ACTION_DOWN) {
+            if (event.isPrintingKey()) {
+                commitText(String.valueOf((char) event.getUnicodeChar()), 1);
+            }
+            SDLActivity.onNativeKeyDown(keyCode);
+            return true;
+        } else if (event.getAction() == KeyEvent.ACTION_UP) {
+
+            SDLActivity.onNativeKeyUp(keyCode);
+            return true;
+        }
+        return super.sendKeyEvent(event);
+    }
+
+    @Override
+    public boolean commitText(CharSequence text, int newCursorPosition) {
+
+        nativeCommitText(text.toString(), newCursorPosition);
+
+        return super.commitText(text, newCursorPosition);
+    }
+
+    @Override
+    public boolean setComposingText(CharSequence text, int newCursorPosition) {
+
+        nativeSetComposingText(text.toString(), newCursorPosition);
+
+        return super.setComposingText(text, newCursorPosition);
+    }
+
+    public native void nativeCommitText(String text, int newCursorPosition);
+
+    public native void nativeSetComposingText(String text, int newCursorPosition);
+
+    @Override
+    public boolean deleteSurroundingText(int beforeLength, int afterLength) {       
+        // Workaround to capture backspace key. Ref: http://stackoverflow.com/questions/14560344/android-backspace-in-webview-baseinputconnection
+        if (beforeLength == 1 && afterLength == 0) {
+            // backspace
+            return super.sendKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DEL))
+                && super.sendKeyEvent(new KeyEvent(KeyEvent.ACTION_UP, KeyEvent.KEYCODE_DEL));
+        }
+
+        return super.deleteSurroundingText(beforeLength, afterLength);
+    }
+}
+
+/* A null joystick handler for API level < 12 devices (the accelerometer is handled separately) */
+class SDLJoystickHandler {
+    
+    public boolean handleMotionEvent(MotionEvent event) {
+        return false;
+    }
+    
+    public void pollInputDevices() {
+    }
+}
+
+/* Actual joystick functionality available for API >= 12 devices */
+class SDLJoystickHandler_API12 extends SDLJoystickHandler {
+  
+    class SDLJoystick {
+        public int device_id;
+        public String name;
+        public ArrayList<InputDevice.MotionRange> axes;
+        public ArrayList<InputDevice.MotionRange> hats;
+    }
+    class RangeComparator implements Comparator<InputDevice.MotionRange>
+    {
+        @Override
+        public int compare(InputDevice.MotionRange arg0, InputDevice.MotionRange arg1) {
+            return arg0.getAxis() - arg1.getAxis();
+        }
+    }
+    
+    private ArrayList<SDLJoystick> mJoysticks;
+    
+    public SDLJoystickHandler_API12() {
+       
+        mJoysticks = new ArrayList<SDLJoystick>();
+    }
+
+    @Override
+    public void pollInputDevices() {
+        int[] deviceIds = InputDevice.getDeviceIds();
+        // It helps processing the device ids in reverse order
+        // For example, in the case of the XBox 360 wireless dongle,
+        // so the first controller seen by SDL matches what the receiver
+        // considers to be the first controller
+        
+        for(int i=deviceIds.length-1; i>-1; i--) {
+            SDLJoystick joystick = getJoystick(deviceIds[i]);
+            if (joystick == null) {
+                joystick = new SDLJoystick();
+                InputDevice joystickDevice = InputDevice.getDevice(deviceIds[i]);
+                if( (joystickDevice.getSources() & InputDevice.SOURCE_CLASS_JOYSTICK) != 0) {
+                    joystick.device_id = deviceIds[i];
+                    joystick.name = joystickDevice.getName();
+                    joystick.axes = new ArrayList<InputDevice.MotionRange>();
+                    joystick.hats = new ArrayList<InputDevice.MotionRange>();
+                    
+                    List<InputDevice.MotionRange> ranges = joystickDevice.getMotionRanges();
+                    Collections.sort(ranges, new RangeComparator());
+                    for (InputDevice.MotionRange range : ranges ) {
+                        if ((range.getSource() & InputDevice.SOURCE_CLASS_JOYSTICK) != 0 ) {
+                            if (range.getAxis() == MotionEvent.AXIS_HAT_X ||
+                                range.getAxis() == MotionEvent.AXIS_HAT_Y) {
+                                joystick.hats.add(range);
+                            }
+                            else {
+                                joystick.axes.add(range);
+                            }
+                        }
+                    }
+                    
+                    mJoysticks.add(joystick);
+                    SDLActivity.nativeAddJoystick(joystick.device_id, joystick.name, 0, -1, 
+                                                  joystick.axes.size(), joystick.hats.size()/2, 0);
+                }
+            }
+        }
+        
+        /* Check removed devices */
+        ArrayList<Integer> removedDevices = new ArrayList<Integer>();
+        for(int i=0; i < mJoysticks.size(); i++) {
+            int device_id = mJoysticks.get(i).device_id;
+            int j;
+            for (j=0; j < deviceIds.length; j++) {
+                if (device_id == deviceIds[j]) break;
+            }
+            if (j == deviceIds.length) {
+                removedDevices.add(device_id);
+            }
+        }
+            
+        for(int i=0; i < removedDevices.size(); i++) {
+            int device_id = removedDevices.get(i);
+            SDLActivity.nativeRemoveJoystick(device_id);
+            for (int j=0; j < mJoysticks.size(); j++) {
+                if (mJoysticks.get(j).device_id == device_id) {
+                    mJoysticks.remove(j);
+                    break;
+                }
+            }
+        }        
+    }
+    
+    protected SDLJoystick getJoystick(int device_id) {
+        for(int i=0; i < mJoysticks.size(); i++) {
+            if (mJoysticks.get(i).device_id == device_id) {
+                return mJoysticks.get(i);
+            }
+        }
+        return null;
+    }   
+    
+    @Override        
+    public boolean handleMotionEvent(MotionEvent event) {
+        if ( (event.getSource() & InputDevice.SOURCE_JOYSTICK) != 0) {
+            int actionPointerIndex = event.getActionIndex();
+            int action = event.getActionMasked();
+            switch(action) {
+                case MotionEvent.ACTION_MOVE:
+                    SDLJoystick joystick = getJoystick(event.getDeviceId());
+                    if ( joystick != null ) {
+                        for (int i = 0; i < joystick.axes.size(); i++) {
+                            InputDevice.MotionRange range = joystick.axes.get(i);
+                            /* Normalize the value to -1...1 */
+                            float value = ( event.getAxisValue( range.getAxis(), actionPointerIndex) - range.getMin() ) / range.getRange() * 2.0f - 1.0f;
+                            SDLActivity.onNativeJoy(joystick.device_id, i, value );
+                        }          
+                        for (int i = 0; i < joystick.hats.size(); i+=2) {
+                            int hatX = Math.round(event.getAxisValue( joystick.hats.get(i).getAxis(), actionPointerIndex ) );
+                            int hatY = Math.round(event.getAxisValue( joystick.hats.get(i+1).getAxis(), actionPointerIndex ) );
+                            SDLActivity.onNativeHat(joystick.device_id, i/2, hatX, hatY );
+                        }
+                    }
+                    break;
+                default:
+                    break;
+            }
+        }
+        return true;
+    }            
+}
+
+class SDLGenericMotionListener_API12 implements View.OnGenericMotionListener {
+    // Generic Motion (mouse hover, joystick...) events go here
+    // We only have joysticks yet
+    @Override
+    public boolean onGenericMotion(View v, MotionEvent event) {
+        return SDLActivity.handleJoystickMotionEvent(event);
+    }
+}

Property changes on: android-project/src/org/libsdl/app/SDLActivity.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: android-project/src/org/libsdl/app/note.txt
===================================================================
--- android-project/src/org/libsdl/app/note.txt	(revision 0)
+++ android-project/src/org/libsdl/app/note.txt	(working copy)
@@ -0,0 +1,4 @@
+Modifications to SDLActivity.java:
+1. stlport_shared and SDL2_net are loaded.
+2. Non-gamepad/dpad keycodes that don't have any source are still assumed to
+come from a keyboard (a workaround for full input from soft keyboard).

Property changes on: android-project/src/org/libsdl/app/note.txt
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: configure.ac
===================================================================
--- configure.ac	(revision 3869)
+++ configure.ac	(working copy)
@@ -28,27 +28,28 @@
 fi
 
 dnl Check for SDL
-SDL_VERSION=1.2.0
-AM_PATH_SDL($SDL_VERSION,
+AC_ARG_WITH(sdl2, [  --with-sdl2             Build using SDL 2.0 instead of SDL 1.2],
+		    with_sdl2=yes, )
+AM_PATH_SDL(:,
             :,
-	    AC_MSG_ERROR([*** SDL version $SDL_VERSION not found!])
+	    :
 )
 LIBS="$LIBS $SDL_LIBS"
 CPPFLAGS="$CPPFLAGS $SDL_CFLAGS"
 
-dnl Check if SDL is 1.2.x (1.3 not supported)
-AC_MSG_CHECKING([SDL version only being 1.2.X])
+dnl Check if SDL is 1.2.x, 2.0.y
+AC_MSG_CHECKING([SDL version only being 1.2.x or 2.0.x])
 AC_COMPILE_IFELSE([AC_LANG_SOURCE([
 #include "SDL.h"
 void blah(){
-#if SDL_MINOR_VERSION != 2
-#error "Only SDL 1.2 supported"
+#if !((SDL_MAJOR_VERSION == 1) && (SDL_MINOR_VERSION == 2)) && !((SDL_MAJOR_VERSION == 2) && (SDL_MINOR_VERSION == 0))
+#error "Only SDL 1.2 and 2.0 supported"
 #endif
 ;
 }
 ])],AC_MSG_RESULT([yes]),[
  AC_MSG_RESULT([no]) 
- AC_MSG_ERROR([Only libSDL 1.2.X supported])])
+ AC_MSG_ERROR([Only libSDL 1.2.x or 2.0.x supported])])
 
 dnl Checks for header files.
 
@@ -370,23 +371,29 @@
 AH_TEMPLATE(C_IPX,[Define to 1 to enable IPX over Internet networking, requires SDL_net])
 AC_CHECK_HEADER(SDL_net.h,have_sdl_net_h=yes,)
 
+if test x$with_sdl2 = "xyes" ; then 
+  LIBSDL_HEADER="SDL2"
+else
+  LIBSDL_HEADER="SDL"
+fi
+
 if test x$host = xi386-pc-os2-emx ; then
-  AC_MSG_CHECKING(for SDLNet_Init in SDL_net);
+  AC_MSG_CHECKING(for SDLNet_Init in ${LIBSDL_HEADER}_net);
   LIBS_BACKUP=$LIBS;
-  LIBS="$LIBS -lSDL_Net";
+  LIBS="$LIBS -l${LIBSDL_HEADER}_Net";
   AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <SDL_Net.h>]],[[
 	SDLNet_Init ();
   ]])], [AC_MSG_RESULT(yes); have_sdl_net_lib=yes], AC_MSG_RESULT(no))
   LIBS=$LIBS_BACKUP
 else
-AC_CHECK_LIB(SDL_net, SDLNet_Init, have_sdl_net_lib=yes, , )
+AC_CHECK_LIB(${LIBSDL_HEADER}_net, SDLNet_Init, have_sdl_net_lib=yes, , )
 fi
 if test x$have_sdl_net_lib = xyes -a x$have_sdl_net_h = xyes ; then
-   LIBS="$LIBS -lSDL_net"
+   LIBS="$LIBS -l${LIBSDL_HEADER}_net"
    AC_DEFINE(C_MODEM,1)
    AC_DEFINE(C_IPX,1)
 else 
-   AC_MSG_WARN([Can't find SDL_net, internal modem and ipx disabled])
+   AC_MSG_WARN([Can't find ${LIBSDL_HEADER}_net, internal modem and ipx disabled])
 fi
 
 AH_TEMPLATE(C_X11_XKB,[define to 1 if you have XKBlib.h and X11 lib])
Index: src/dos/cdrom.cpp
===================================================================
--- src/dos/cdrom.cpp	(revision 3869)
+++ src/dos/cdrom.cpp	(working copy)
@@ -21,6 +21,8 @@
 // SDL CDROM 
 // ******************************************************
 
+#include "SDL_version.h"
+
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <unistd.h>
@@ -30,6 +32,9 @@
 #include "support.h"
 #include "cdrom.h"
 
+// On all platforms, if SDL 2.0 is used then we don't support physical CD-ROMs.
+#if !SDL_VERSION_ATLEAST(2,0,0)
+
 CDROM_Interface_SDL::CDROM_Interface_SDL(void) {
 	driveID		= 0;
 	oldLeadOut	= 0;
@@ -143,6 +148,8 @@
 	return success;
 }
 
+#endif /* !SDL_VERSION_ATLEAST(2,0,0) */
+
 int CDROM_GetMountType(char* path, int forceCD) {
 // 0 - physical CDROM
 // 1 - Iso file
@@ -157,6 +164,7 @@
 	upcase(buffer);
 #endif
 
+#if !SDL_VERSION_ATLEAST(2,0,0)
 	int num = SDL_CDNumDrives();
 	// If cd drive is forced then check if its in range and return 0
 	if ((forceCD>=0) && (forceCD<num)) {
@@ -169,6 +177,7 @@
 		cdName = SDL_CDName(i);
 		if (strcmp(buffer,cdName)==0) return 0;
 	};
+#endif
 	
 	// Detect ISO
 	struct stat file_stat;
@@ -214,5 +223,3 @@
 	trayOpen     = false;
 	return true;
 }
-
-
Index: src/dos/cdrom.h
===================================================================
--- src/dos/cdrom.h	(revision 3869)
+++ src/dos/cdrom.h	(working copy)
@@ -41,7 +41,9 @@
 #define RAW_SECTOR_SIZE		2352
 #define COOKED_SECTOR_SIZE	2048
 
+#if !SDL_VERSION_ATLEAST(2,0,0)
 enum { CDROM_USE_SDL, CDROM_USE_ASPI, CDROM_USE_IOCTL_DIO, CDROM_USE_IOCTL_DX, CDROM_USE_IOCTL_MCI };
+#endif
 
 typedef struct SMSF {
 	unsigned char min;
@@ -84,6 +86,7 @@
 	virtual void	InitNewMedia		(void) {};
 };	
 
+#if !SDL_VERSION_ATLEAST(2,0,0)
 class CDROM_Interface_SDL : public CDROM_Interface
 {
 public:
@@ -112,6 +115,7 @@
 	int		driveID;
 	Uint32	oldLeadOut;
 };
+#endif	// !SDL_VERSION_ATLEAST(2,0,0)
 
 class CDROM_Interface_Fake : public CDROM_Interface
 {
@@ -237,6 +241,8 @@
 	Bit8u	subUnit;
 };
 
+#if !SDL_VERSION_ATLEAST(2,0,0)
+
 #if defined (WIN32)	/* Win 32 */
 
 #define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
@@ -394,4 +400,6 @@
 
 #endif /* LINUX */
 
+#endif /* !SDL_VERSION_ATLEAST(2,0,0) */
+
 #endif /* __CDROM_INTERFACE__ */
Index: src/dos/cdrom_aspi_win32.cpp
===================================================================
--- src/dos/cdrom_aspi_win32.cpp	(revision 3869)
+++ src/dos/cdrom_aspi_win32.cpp	(working copy)
@@ -17,6 +17,10 @@
  */
 
 
+#include "SDL_version.h"
+// On all platforms, if SDL 2.0 is used then we don't support physical CD-ROMs.
+#if !SDL_VERSION_ATLEAST(2,0,0)
+
 #if defined (WIN32)
 
 #include <ctype.h>
@@ -762,3 +766,4 @@
 };
 
 #endif
+#endif	// SDL_VERSION_ATLEAST(2,0,0)
Index: src/dos/cdrom_image.cpp
===================================================================
--- src/dos/cdrom_image.cpp	(revision 3869)
+++ src/dos/cdrom_image.cpp	(working copy)
@@ -43,6 +43,24 @@
 #define MAX_LINE_LENGTH 512
 #define MAX_FILENAME_LENGTH 256
 
+// With no CD-ROM support on SDL 2.0, we need these. ***Taken off SDL_cdrom.h***
+#ifndef CD_FPS
+#define CD_FPS	75
+#endif
+#ifndef MSF_TO_FRAMES
+#define MSF_TO_FRAMES(M, S, F)	((M)*60*CD_FPS+(S)*CD_FPS+(F))
+#endif
+#ifndef FRAMES_TO_MSF
+#define FRAMES_TO_MSF(f, M,S,F)	{					\
+	int value = f;							\
+	*(F) = value%CD_FPS;						\
+	value /= CD_FPS;						\
+	*(S) = value%60;						\
+	value /= 60;							\
+	*(M) = value;							\
+}
+#endif
+
 CDROM_Interface_Image::BinaryFile::BinaryFile(const char *filename, bool &error)
 {
 	file = new ifstream(filename, ios::in | ios::binary);
Index: src/dos/cdrom_ioctl_linux.cpp
===================================================================
--- src/dos/cdrom_ioctl_linux.cpp	(revision 3869)
+++ src/dos/cdrom_ioctl_linux.cpp	(working copy)
@@ -17,6 +17,10 @@
  */
  
 
+#include "SDL_version.h"
+// On all platforms, if SDL 2.0 is used then we don't support physical CD-ROMs.
+#if !SDL_VERSION_ATLEAST(2,0,0)
+
 #include <string.h>
 #include "cdrom.h"
 #include "support.h"
@@ -95,3 +99,4 @@
 }
 
 #endif
+#endif	// SDL_VERSION_ATLEAST(2,0,0)
Index: src/dos/cdrom_ioctl_os2.cpp
===================================================================
--- src/dos/cdrom_ioctl_os2.cpp	(revision 3869)
+++ src/dos/cdrom_ioctl_os2.cpp	(working copy)
@@ -17,6 +17,10 @@
  */
 
 
+#include "SDL_version.h"
+// On all platforms, if SDL 2.0 is used then we don't support physical CD-ROMs.
+#if !SDL_VERSION_ATLEAST(2,0,0)
+
 #include <string.h>
 #include "dosbox.h"
 #include "cdrom.h"
@@ -150,3 +154,4 @@
 }
 
 #endif
+#endif	// SDL_VERSION_ATLEAST(2,0,0)
Index: src/dos/cdrom_ioctl_win32.cpp
===================================================================
--- src/dos/cdrom_ioctl_win32.cpp	(revision 3869)
+++ src/dos/cdrom_ioctl_win32.cpp	(working copy)
@@ -17,6 +17,10 @@
  */
 
 
+#include "SDL_version.h"
+// On all platforms, if SDL 2.0 is used then we don't support physical CD-ROMs.
+#if !SDL_VERSION_ATLEAST(2,0,0)
+
 #if defined (WIN32)
 
 // *****************************************************************
@@ -621,3 +625,4 @@
 }
 
 #endif
+#endif	// SDL_VERSION_ATLEAST(2,0,0)
Index: src/dos/dos_mscdex.cpp
===================================================================
--- src/dos/dos_mscdex.cpp	(revision 3869)
+++ src/dos/dos_mscdex.cpp	(working copy)
@@ -47,8 +47,18 @@
 #define	REQUEST_STATUS_DONE		0x0100
 #define	REQUEST_STATUS_ERROR	0x8000
 
+// With no CD-ROM support on SDL 2.0, we need this. ***Taken off SDL_cdrom.h***
+#ifndef CD_FPS
+#define CD_FPS	75
+#endif
+#ifndef MSF_TO_FRAMES
+#define MSF_TO_FRAMES(M, S, F)	((M)*60*CD_FPS+(S)*CD_FPS+(F))
+#endif
+
 // Use cdrom Interface
+#if !SDL_VERSION_ATLEAST(2,0,0)
 int useCdromInterface	= CDROM_USE_SDL;
+#endif
 int forceCD				= -1;
 
 static Bitu MSCDEX_Strategy_Handler(void); 
@@ -254,7 +264,9 @@
 	// Set return type to ok
 	int result = 0;
 	// Get Mounttype and init needed cdrom interface
+	// (physical is unsupported in SDL 2.0)
 	switch (CDROM_GetMountType(physicalPath,forceCD)) {
+#if !SDL_VERSION_ATLEAST(2,0,0)
 	case 0x00: {	
 		LOG(LOG_MISC,LOG_NORMAL)("MSCDEX: Mounting physical cdrom: %s"	,physicalPath);
 #if defined (WIN32)
@@ -297,6 +309,7 @@
 		LOG(LOG_MISC,LOG_NORMAL)("MSCDEX: SDL Interface.");
 #endif
 		} break;
+#endif	// !SDL_VERSION_ATLEAST(2,0,0)
 	case 0x01:	// iso cdrom interface	
 		LOG(LOG_MISC,LOG_NORMAL)("MSCDEX: Mounting iso file as cdrom: %s", physicalPath);
 		cdrom[numDrives] = new CDROM_Interface_Image((Bit8u)numDrives);
@@ -1366,10 +1379,12 @@
 	return true;
 }
 
+#if !SDL_VERSION_ATLEAST(2,0,0)
 void MSCDEX_SetCDInterface(int intNr, int numCD) {
 	useCdromInterface = intNr;
 	forceCD	= numCD;
 }
+#endif
 
 void MSCDEX_ShutDown(Section* /*sec*/) {
 	delete mscdex;
Index: src/dos/dos_programs.cpp
===================================================================
--- src/dos/dos_programs.cpp	(revision 3869)
+++ src/dos/dos_programs.cpp	(working copy)
@@ -48,7 +48,9 @@
 Bitu DEBUG_EnableDebugger(void);
 #endif
 
+#if !SDL_VERSION_ATLEAST(2,0,0)
 void MSCDEX_SetCDInterface(int intNr, int forceCD);
+#endif
 static Bitu ZDRIVE_NUM = 25;
 
 class MOUNT : public Program {
@@ -173,11 +175,15 @@
 		}
 		/* Show list of cdroms */
 		if (cmd->FindExist("-cd",false)) {
+#if SDL_VERSION_ATLEAST(2,0,0)
+			WriteOut(MSG_Get("PROGRAM_MOUNT_PHYS_CDROMS_NOT_SUPPORTED"));
+#else
 			int num = SDL_CDNumDrives();
    			WriteOut(MSG_Get("PROGRAM_MOUNT_CDROMS_FOUND"),num);
 			for (int i=0; i<num; i++) {
 				WriteOut("%2d. %s\n",i,SDL_CDName(i));
 			};
+#endif
 			return;
 		}
 
@@ -308,9 +314,22 @@
 			if (temp_line[temp_line.size()-1]!=CROSS_FILESPLIT) temp_line+=CROSS_FILESPLIT;
 			Bit8u bit8size=(Bit8u) sizes[1];
 			if (type=="cdrom") {
+#if SDL_VERSION_ATLEAST(2,0,0)
+				if (cmd->FindExist("-usecd",false)
+				    || cmd->FindExist("-aspi",false)
+				    || cmd->FindExist("-ioctl_dio",false)
+				    || cmd->FindExist("-ioctl_dx",false)
+#if defined (WIN32)
+				    || cmd->FindExist("-ioctl_mci",false)
+#endif
+				    || cmd->FindExist("-noioctl",false)
+				) {
+					WriteOut(MSG_Get("PROGRAM_MOUNT_PHYS_CDROMS_NOT_SUPPORTED"));
+					/* Just ignore, mount anyway */
+				}
+#else	// SDL_VERSION_ATLEAST(2,0,0)
 				int num = -1;
 				cmd->FindInt("-usecd",num,true);
-				int error = 0;
 				if (cmd->FindExist("-aspi",false)) {
 					MSCDEX_SetCDInterface(CDROM_USE_ASPI, num);
 				} else if (cmd->FindExist("-ioctl_dio",false)) {
@@ -339,6 +358,8 @@
 					MSCDEX_SetCDInterface(CDROM_USE_IOCTL_DIO, num);
 #endif
 				}
+#endif	// SDL_VERSION_ATLEAST(2,0,0)
+				int error = 0;
 				newdrive  = new cdromDrive(drive,temp_line.c_str(),sizes[0],bit8size,sizes[2],0,mediaid,error);
 				// Check Mscdex, if it worked out...
 				switch (error) {
@@ -1317,7 +1338,9 @@
 					WriteOut(MSG_Get("PROGRAM_IMGMOUNT_ALREADY_MOUNTED"));
 					return;
 				}
+#if !SDL_VERSION_ATLEAST(2,0,0)
 				MSCDEX_SetCDInterface(CDROM_USE_SDL, -1);
+#endif
 				// create new drives for all images
 				std::vector<DOS_Drive*> isoDisks;
 				std::vector<std::string>::size_type i;
@@ -1468,7 +1491,11 @@
 void DOS_SetupPrograms(void) {
 	/*Add Messages */
 
+#if SDL_VERSION_ATLEAST(2,0,0)
+	MSG_Add("PROGRAM_MOUNT_PHYS_CDROMS_NOT_SUPPORTED","Physical CDROMs aren't fully supported. IMGMOUNT may be more useful.\n");
+#else
 	MSG_Add("PROGRAM_MOUNT_CDROMS_FOUND","CDROMs found: %d\n");
+#endif
 	MSG_Add("PROGRAM_MOUNT_STATUS_FORMAT","%-5s  %-58s %-12s\n");
 	MSG_Add("PROGRAM_MOUNT_STATUS_2","Drive %c is mounted as %s\n");
 	MSG_Add("PROGRAM_MOUNT_STATUS_1","The currently mounted drives are:\n");
@@ -1558,7 +1585,11 @@
 		);
 	MSG_Add("PROGRAM_INTRO_CDROM",
 		"\033[2J\033[32;1mHow to mount a Real/Virtual CD-ROM Drive in DOSBox:\033[0m\n"
+#if SDL_VERSION_ATLEAST(2,0,0)
+		"DOSBox provides CD-ROM emulation on a few levels.\n"
+#else
 		"DOSBox provides CD-ROM emulation on several levels.\n"
+#endif
 		"\n"
 		"The \033[33mbasic\033[0m level works on all CD-ROM drives and normal directories.\n"
 		"It installs MSCDEX and marks the files read-only.\n"
@@ -1567,6 +1598,14 @@
 		"If it doesn't work you might have to tell DOSBox the label of the CD-ROM:\n"
 		"\033[34;1mmount d C:\\example -t cdrom -label CDLABEL\033[0m\n"
 		"\n"
+#if SDL_VERSION_ATLEAST(2,0,0)
+		"The \033[33mhigher\033[0m level adds CD-ROM image mounting support.\n"
+		"Therefore only works on supported CD-ROM images:\n"
+		"\033[34;1mimgmount d \033[0;31mD:\\example.img\033[34;1m -t cdrom\033[0m\n"
+		"\n"
+		"Replace \033[0;31mD:\\\033[0m with the location of your CD-ROM.\n"
+		"Replace \033[0;31mD:\\example.img\033[0m with the location of your CD-ROM image.\n"
+#else
 		"The \033[33mnext\033[0m level adds some low-level support.\n"
 		"Therefore only works on CD-ROM drives:\n"
 		"\033[34;1mmount d \033[0;31mD:\\\033[34;1m -t cdrom -usecd \033[33m0\033[0m\n"
@@ -1580,6 +1619,7 @@
 		"Replace \033[0;31mD:\\\033[0m with the location of your CD-ROM.\n"
 		"Replace the \033[33;1m0\033[0m in \033[34;1m-usecd \033[33m0\033[0m with the number reported for your CD-ROM if you type:\n"
 		"\033[34;1mmount -cd\033[0m\n"
+#endif
 		);
 	MSG_Add("PROGRAM_INTRO_SPECIAL",
 		"\033[2J\033[32;1mSpecial keys:\033[0m\n"
Index: src/dos/drive_local.cpp
===================================================================
--- src/dos/drive_local.cpp	(revision 3869)
+++ src/dos/drive_local.cpp	(working copy)
@@ -290,7 +290,14 @@
 
 	find_size=(Bit32u) stat_block.st_size;
 	struct tm *time;
+#ifdef __ANDROID__ // temp_stat.st_mtime is of type unsigned long, not time_t
+	time_t rawtime;
+	time=localtime(&rawtime);
+	stat_block.st_mtime = rawtime;
+	if(time!=0){
+#else
 	if((time=localtime(&stat_block.st_mtime))!=0){
+#endif
 		find_date=DOS_PackDate((Bit16u)(time->tm_year+1900),(Bit16u)(time->tm_mon+1),(Bit16u)time->tm_mday);
 		find_time=DOS_PackTime((Bit16u)time->tm_hour,(Bit16u)time->tm_min,(Bit16u)time->tm_sec);
 	} else {
@@ -408,7 +415,14 @@
 	if(stat(newname,&temp_stat)!=0) return false;
 	/* Convert the stat to a FileStat */
 	struct tm *time;
+#ifdef __ANDROID__ // temp_stat.st_mtime is of type unsigned long, not time_t
+	time_t rawtime;
+	time=localtime(&rawtime);
+	temp_stat.st_mtime = rawtime;
+	if(time!=0){
+#else
 	if((time=localtime(&temp_stat.st_mtime))!=0) {
+#endif
 		stat_block->time=DOS_PackTime((Bit16u)time->tm_hour,(Bit16u)time->tm_min,(Bit16u)time->tm_sec);
 		stat_block->date=DOS_PackDate((Bit16u)(time->tm_year+1900),(Bit16u)(time->tm_mon+1),(Bit16u)time->tm_mday);
 	} else {
@@ -547,7 +561,14 @@
 	struct stat temp_stat;
 	fstat(fileno(fhandle),&temp_stat);
 	struct tm * ltime;
+#ifdef __ANDROID__ // temp_stat.st_mtime is of type unsigned long, not time_t
+	time_t rawtime;
+	ltime=localtime(&rawtime);
+	temp_stat.st_mtime = rawtime;
+	if(ltime!=0){
+#else
 	if((ltime=localtime(&temp_stat.st_mtime))!=0) {
+#endif
 		time=DOS_PackTime((Bit16u)ltime->tm_hour,(Bit16u)ltime->tm_min,(Bit16u)ltime->tm_sec);
 		date=DOS_PackDate((Bit16u)(ltime->tm_year+1900),(Bit16u)(ltime->tm_mon+1),(Bit16u)ltime->tm_mday);
 	} else {
Index: src/dosbox.cpp
===================================================================
--- src/dosbox.cpp	(revision 3869)
+++ src/dosbox.cpp	(working copy)
@@ -433,8 +433,13 @@
 		"                  handle.");
 
 	const char* cyclest[] = { "auto","fixed","max","%u",0 };
+#ifdef __ANDROID__
+	Pstring = Pmulti_remain->GetSection()->Add_string("type",Property::Changeable::Always,"max");
+	Pmulti_remain->SetValue("max");
+#else
 	Pstring = Pmulti_remain->GetSection()->Add_string("type",Property::Changeable::Always,"auto");
 	Pmulti_remain->SetValue("auto");
+#endif
 	Pstring->Set_values(cyclest);
 
 	Pstring = Pmulti_remain->GetSection()->Add_string("parameters",Property::Changeable::Always,"");
Index: src/gui/sdl_mapper.cpp
===================================================================
--- src/gui/sdl_mapper.cpp.orig	2015-06-03 18:22:38.519638490 +0100
+++ src/gui/sdl_mapper.cpp	2015-06-03 18:39:02.515800964 +0100
@@ -67,7 +67,9 @@
 
 #define MAXSTICKS 8
 #define MAXACTIVE 16
-#define MAXBUTTON 32
+// Use 36 for Android (KEYCODE_BUTTON_1..16 are mapped to SDL buttons 20..35)
+#define MAXBUTTON 36
+//#define MAXBUTTON 32
 #define MAXBUTTON_CAP 16
 
 class CEvent;
@@ -299,6 +301,9 @@
 };
 
 
+/*** NOTE: This is going to be a pretty large SDL 1.2 exclusive block... ***/
+#if !SDL_VERSION_ATLEAST(2,0,0)
+
 #define MAX_SDLKEYS 323
 
 static bool usescancodes;
@@ -469,23 +474,42 @@
 	}
 }
 
+#endif
+/*** End of (large) SDL 1.2 exclusive block ***/
+
 
 class CKeyBind;
 class CKeyBindGroup;
 
 class CKeyBind : public CBind {
 public:
+#if SDL_VERSION_ATLEAST(2,0,0)
+	CKeyBind(CBindList * _list,SDL_Scancode _key) : CBind(_list) {
+#else
 	CKeyBind(CBindList * _list,SDLKey _key) : CBind(_list) {
+#endif
 		key = _key;
 	}
 	void BindName(char * buf) {
+#if SDL_VERSION_ATLEAST(2,0,0)
+		sprintf(buf,"Key %s",SDL_GetScancodeName(key));
+#else
 		sprintf(buf,"Key %s",SDL_GetKeyName(MapSDLCode((Bitu)key)));
+#endif
 	}
 	void ConfigName(char * buf) {
+#if SDL_VERSION_ATLEAST(2,0,0)
+		sprintf(buf,"key %d",key);
+#else
 		sprintf(buf,"key %d",MapSDLCode((Bitu)key));
+#endif
 	}
 public:
+#if SDL_VERSION_ATLEAST(2,0,0)
+	SDL_Scancode key;
+#else
 	SDLKey key;
+#endif
 };
 
 class CKeyBindGroup : public  CBindGroup {
@@ -501,28 +525,44 @@
 		if (strncasecmp(buf,configname,strlen(configname))) return 0;
 		StripWord(buf);char * num=StripWord(buf);
 		Bitu code=ConvDecWord(num);
+#if SDL_VERSION_ATLEAST(2,0,0)
+		CBind * bind=CreateKeyBind((SDL_Scancode)code);
+#else
 		if (usescancodes) {
 			if (code<MAX_SDLKEYS) code=scancode_map[code];
 			else code=0;
 		}
 		CBind * bind=CreateKeyBind((SDLKey)code);
+#endif
 		return bind;
 	}
 	CBind * CreateEventBind(SDL_Event * event) {
 		if (event->type!=SDL_KEYDOWN) return 0;
+#if SDL_VERSION_ATLEAST(2,0,0)
+		return CreateKeyBind(event->key.keysym.scancode);
+#else
 		return CreateKeyBind((SDLKey)GetKeyCode(event->key.keysym));
+#endif
 	};
 	bool CheckEvent(SDL_Event * event) {
 		if (event->type!=SDL_KEYDOWN && event->type!=SDL_KEYUP) return false;
+#if SDL_VERSION_ATLEAST(2,0,0)
+		Bitu key = event->key.keysym.scancode;
+#else	// SDL 1.2
 		Bitu key=GetKeyCode(event->key.keysym);
 //		LOG_MSG("key type %i is %x [%x %x]",event->type,key,event->key.keysym.sym,event->key.keysym.scancode);
 		assert(Bitu(event->key.keysym.sym)<keys);
+#endif	// SDL 2.0/1.2
 		if (event->type==SDL_KEYDOWN) ActivateBindList(&lists[key],0x7fff,true);
 		else DeactivateBindList(&lists[key],true);
 		return 0;
 	}
+#if SDL_VERSION_ATLEAST(2,0,0)
+	CBind * CreateKeyBind(SDL_Scancode _key) {
+#else
 	CBind * CreateKeyBind(SDLKey _key) {
 		if (!usescancodes) assert((Bitu)_key<keys);
+#endif
 		return new CKeyBind(&lists[(Bitu)_key],_key);
 	}
 private:
@@ -675,7 +715,11 @@
 		if (axes_cap>axes) axes_cap=axes;
 		hats_cap=emulated_hats;
 		if (hats_cap>hats) hats_cap=hats;
+#if SDL_VERSION_ATLEAST(2,0,0)
+		LOG_MSG("Using joystick %s with %d axes, %d buttons and %d hat(s)",SDL_JoystickNameForIndex(stick),axes,buttons,hats);
+#else
 		LOG_MSG("Using joystick %s with %d axes, %d buttons and %d hat(s)",SDL_JoystickName(stick),axes,buttons,hats);
+#endif
 	}
 	~CStickBindGroup() {
 		SDL_JoystickClose(sdl_joystick);
@@ -712,7 +756,12 @@
 			if (abs(event->jaxis.value)<25000) return 0;
 			return CreateAxisBind(event->jaxis.axis,event->jaxis.value>0);
 		} else if (event->type==SDL_JOYBUTTONDOWN) {
+#if SDL_VERSION_ATLEAST(2,0,0)
+			if (event->jbutton.which!=stick) return 0;
+#else
+			/* NOTE: Is that a bug? */
 			if (event->button.which!=stick) return 0;
+#endif
 #if defined (REDUCE_JOYSTICK_POLLING)
 			return CreateButtonBind(event->jbutton.button%button_wrap);
 #else
@@ -881,7 +930,11 @@
 		return configname;
 	}
 	const char * BindStart(void) {
+#if SDL_VERSION_ATLEAST(2,0,0)
+		if (sdl_joystick!=NULL) return SDL_JoystickNameForIndex(stick);
+#else
 		if (sdl_joystick!=NULL) return SDL_JoystickName(stick);
+#endif
 		else return "[missing joystick]";
 	}
 
@@ -1240,6 +1293,11 @@
 };
 
 static struct CMapper {
+#if SDL_VERSION_ATLEAST(2,0,0)
+	SDL_Window * window;
+	SDL_Rect draw_rect;
+	SDL_Surface * draw_surface_nonpaletted; // Needed for SDL_BlitScaled
+#endif
 	SDL_Surface * surface;
 	SDL_Surface * draw_surface;
 	bool exit;
@@ -1277,7 +1335,7 @@
 }
 
 static void DrawText(Bitu x,Bitu y,const char * text,Bit8u color) {
-	Bit8u * draw=((Bit8u *)mapper.surface->pixels)+(y*mapper.surface->pitch)+x;
+	Bit8u * draw=((Bit8u *)mapper.draw_surface->pixels)+(y*mapper.draw_surface->w)+x;
 	while (*text) {
 		Bit8u * font=&int10_font_14[(*text)*14];
 		Bitu i,j;Bit8u * draw_line=draw;
@@ -1288,7 +1346,7 @@
 				else *(draw_line+j)=CLR_BLACK;
 				map<<=1;
 			}
-			draw_line+=mapper.surface->pitch;
+			draw_line+=mapper.draw_surface->w;
 		}
 		text++;draw+=8;
 	}
@@ -1305,14 +1363,14 @@
 	}
 	virtual void Draw(void) {
 		if (!enabled) return;
-		Bit8u * point=((Bit8u *)mapper.surface->pixels)+(y*mapper.surface->pitch)+x;
+		Bit8u * point=((Bit8u *)mapper.draw_surface->pixels)+(y*mapper.draw_surface->w)+x;
 		for (Bitu lines=0;lines<dy;lines++)  {
 			if (lines==0 || lines==(dy-1)) {
 				for (Bitu cols=0;cols<dx;cols++) *(point+cols)=color;
 			} else {
 				*point=color;*(point+dx-1)=color;
 			}
-			point+=mapper.surface->pitch;
+			point+=mapper.draw_surface->w;
 		}
 	}
 	virtual bool OnTop(Bitu _x,Bitu _y) {
@@ -1457,10 +1515,10 @@
 			break;
 		}
 		if (checked) {
-			Bit8u * point=((Bit8u *)mapper.surface->pixels)+((y+2)*mapper.surface->pitch)+x+dx-dy+2;
+			Bit8u * point=((Bit8u *)mapper.draw_surface->pixels)+((y+2)*mapper.draw_surface->w)+x+dx-dy+2;
 			for (Bitu lines=0;lines<(dy-4);lines++)  {
 				memset(point,color,dy-4);
-				point+=mapper.surface->pitch;
+				point+=mapper.draw_surface->w;
 			}
 		}
 		CTextButton::Draw();
@@ -1589,25 +1647,53 @@
 		case MK_f1:case MK_f2:case MK_f3:case MK_f4:
 		case MK_f5:case MK_f6:case MK_f7:case MK_f8:
 		case MK_f9:case MK_f10:case MK_f11:case MK_f12:	
+#if SDL_VERSION_ATLEAST(2,0,0)
+			key=SDL_SCANCODE_F1+(defkey-MK_f1);
+#else
 			key=SDLK_F1+(defkey-MK_f1);
+#endif
 			break;
 		case MK_return:
+#if SDL_VERSION_ATLEAST(2,0,0)
+			key=SDL_SCANCODE_RETURN;
+#else
 			key=SDLK_RETURN;
+#endif
 			break;
 		case MK_kpminus:
+#if SDL_VERSION_ATLEAST(2,0,0)
+			key=SDL_SCANCODE_KP_MINUS;
+#else
 			key=SDLK_KP_MINUS;
+#endif
 			break;
 		case MK_scrolllock:
+#if SDL_VERSION_ATLEAST(2,0,0)
+			key=SDL_SCANCODE_SCROLLLOCK;
+#else
 			key=SDLK_SCROLLOCK;
+#endif
 			break;
 		case MK_pause:
+#if SDL_VERSION_ATLEAST(2,0,0)
+			key=SDL_SCANCODE_PAUSE;
+#else
 			key=SDLK_PAUSE;
+#endif
 			break;
 		case MK_printscreen:
+#if SDL_VERSION_ATLEAST(2,0,0)
+			key=SDL_SCANCODE_PRINTSCREEN;
+#else
 			key=SDLK_PRINT;
+#endif
 			break;
 		case MK_home: 
+#if SDL_VERSION_ATLEAST(2,0,0)
+			key=SDL_SCANCODE_HOME; 
+#else
 			key=SDLK_HOME; 
+#endif
 			break;
 		}
 		sprintf(buf,"%s \"key %d%s%s%s\"",
@@ -1689,14 +1775,27 @@
 	}
 }
 
+#if SDL_VERSION_ATLEAST(2,0,0)
+extern SDL_Window * GFX_SetSDLSurfaceWindow(Bit16u width, Bit16u height);
+extern SDL_Rect GFX_GetSDLSurfaceSubwindowDims(Bit16u width, Bit16u height);
+extern void GFX_UpdateDisplayDimensions(int width, int height);
+#endif
+
 static void DrawButtons(void) {
-	SDL_FillRect(mapper.surface,0,0);
-	SDL_LockSurface(mapper.surface);
+	SDL_FillRect(mapper.draw_surface,0,CLR_BLACK);
 	for (CButton_it but_it = buttons.begin();but_it!=buttons.end();but_it++) {
 		(*but_it)->Draw();
 	}
-	SDL_UnlockSurface(mapper.surface);
+#if SDL_VERSION_ATLEAST(2,0,0)
+	// We can't just use SDL_BlitScaled (say for Android) in one step
+	SDL_BlitSurface(mapper.draw_surface, NULL, mapper.draw_surface_nonpaletted, NULL);
+	SDL_BlitScaled(mapper.draw_surface_nonpaletted, NULL, mapper.surface, &mapper.draw_rect);
+	//SDL_BlitSurface(mapper.draw_surface, NULL, mapper.surface, NULL);
+	SDL_UpdateWindowSurface(mapper.window);
+#else
+	SDL_BlitSurface(mapper.draw_surface, NULL, mapper.surface, NULL);
 	SDL_Flip(mapper.surface);
+#endif
 }
 
 static CKeyEvent * AddKeyButtonEvent(Bitu x,Bitu y,Bitu dx,Bitu dy,char const * const title,char const * const entry,KBD_KEYS key) {
@@ -2042,6 +2141,49 @@
 	const char * eventend;
 	Bitu key;
 } DefaultKeys[]={
+
+#if SDL_VERSION_ATLEAST(2,0,0)
+
+	{"f1",SDL_SCANCODE_F1},		{"f2",SDL_SCANCODE_F2},		{"f3",SDL_SCANCODE_F3},		{"f4",SDL_SCANCODE_F4},
+	{"f5",SDL_SCANCODE_F5},		{"f6",SDL_SCANCODE_F6},		{"f7",SDL_SCANCODE_F7},		{"f8",SDL_SCANCODE_F8},
+	{"f9",SDL_SCANCODE_F9},		{"f10",SDL_SCANCODE_F10},	{"f11",SDL_SCANCODE_F11},	{"f12",SDL_SCANCODE_F12},
+
+	{"1",SDL_SCANCODE_1},		{"2",SDL_SCANCODE_2},		{"3",SDL_SCANCODE_3},		{"4",SDL_SCANCODE_4},
+	{"5",SDL_SCANCODE_5},		{"6",SDL_SCANCODE_6},		{"7",SDL_SCANCODE_7},		{"8",SDL_SCANCODE_8},
+	{"9",SDL_SCANCODE_9},		{"0",SDL_SCANCODE_0},
+
+	{"a",SDL_SCANCODE_A},		{"b",SDL_SCANCODE_B},		{"c",SDL_SCANCODE_C},		{"d",SDL_SCANCODE_D},
+	{"e",SDL_SCANCODE_E},		{"f",SDL_SCANCODE_F},		{"g",SDL_SCANCODE_G},		{"h",SDL_SCANCODE_H},
+	{"i",SDL_SCANCODE_I},		{"j",SDL_SCANCODE_J},		{"k",SDL_SCANCODE_K},		{"l",SDL_SCANCODE_L},
+	{"m",SDL_SCANCODE_M},		{"n",SDL_SCANCODE_N},		{"o",SDL_SCANCODE_O},		{"p",SDL_SCANCODE_P},
+	{"q",SDL_SCANCODE_Q},		{"r",SDL_SCANCODE_R},		{"s",SDL_SCANCODE_S},		{"t",SDL_SCANCODE_T},
+	{"u",SDL_SCANCODE_U},		{"v",SDL_SCANCODE_V},		{"w",SDL_SCANCODE_W},		{"x",SDL_SCANCODE_X},
+	{"y",SDL_SCANCODE_Y},		{"z",SDL_SCANCODE_Z},		{"space",SDL_SCANCODE_SPACE},
+	{"esc",SDL_SCANCODE_ESCAPE},	{"equals",SDL_SCANCODE_EQUALS},		{"grave",SDL_SCANCODE_GRAVE},
+	{"tab",SDL_SCANCODE_TAB},		{"enter",SDL_SCANCODE_RETURN},		{"bspace",SDL_SCANCODE_BACKSPACE},
+	{"lbracket",SDL_SCANCODE_LEFTBRACKET},						{"rbracket",SDL_SCANCODE_RIGHTBRACKET},
+	{"minus",SDL_SCANCODE_MINUS},	{"capslock",SDL_SCANCODE_CAPSLOCK},	{"semicolon",SDL_SCANCODE_SEMICOLON},
+	{"quote", SDL_SCANCODE_APOSTROPHE},	{"backslash",SDL_SCANCODE_BACKSLASH},	{"lshift",SDL_SCANCODE_LSHIFT},
+	{"rshift",SDL_SCANCODE_RSHIFT},	{"lalt",SDL_SCANCODE_LALT},			{"ralt",SDL_SCANCODE_RALT},
+	{"lctrl",SDL_SCANCODE_LCTRL},	{"rctrl",SDL_SCANCODE_RCTRL},		{"comma",SDL_SCANCODE_COMMA},
+	{"period",SDL_SCANCODE_PERIOD},	{"slash",SDL_SCANCODE_SLASH},		{"printscreen",SDL_SCANCODE_PRINTSCREEN},
+	{"scrolllock",SDL_SCANCODE_SCROLLLOCK},	{"pause",SDL_SCANCODE_PAUSE},		{"pagedown",SDL_SCANCODE_PAGEDOWN},
+	{"pageup",SDL_SCANCODE_PAGEUP},	{"insert",SDL_SCANCODE_INSERT},		{"home",SDL_SCANCODE_HOME},
+	{"delete",SDL_SCANCODE_DELETE},	{"end",SDL_SCANCODE_END},			{"up",SDL_SCANCODE_UP},
+	{"left",SDL_SCANCODE_LEFT},		{"down",SDL_SCANCODE_DOWN},			{"right",SDL_SCANCODE_RIGHT},
+	{"kp_0",SDL_SCANCODE_KP_0},	{"kp_1",SDL_SCANCODE_KP_1},	{"kp_2",SDL_SCANCODE_KP_2},	{"kp_3",SDL_SCANCODE_KP_3},
+	{"kp_4",SDL_SCANCODE_KP_4},	{"kp_5",SDL_SCANCODE_KP_5},	{"kp_6",SDL_SCANCODE_KP_6},	{"kp_7",SDL_SCANCODE_KP_7},
+	{"kp_8",SDL_SCANCODE_KP_8},	{"kp_9",SDL_SCANCODE_KP_9},	{"numlock",SDL_SCANCODE_NUMLOCKCLEAR},
+	{"kp_divide",SDL_SCANCODE_KP_DIVIDE},	{"kp_multiply",SDL_SCANCODE_KP_MULTIPLY},
+	{"kp_minus",SDL_SCANCODE_KP_MINUS},		{"kp_plus",SDL_SCANCODE_KP_PLUS},
+	{"kp_period",SDL_SCANCODE_KP_PERIOD},	{"kp_enter",SDL_SCANCODE_KP_ENTER},
+
+	/* Is that the extra backslash key ("less than" key) */
+	/* on some keyboards with the 102-keys layout??      */
+	{"lessthan",SDL_SCANCODE_NONUSBACKSLASH},
+
+#else	// !SDL_VERSION_ATLEAST(2,0,0)
+
 	{"f1",SDLK_F1},		{"f2",SDLK_F2},		{"f3",SDLK_F3},		{"f4",SDLK_F4},
 	{"f5",SDLK_F5},		{"f6",SDLK_F6},		{"f7",SDLK_F7},		{"f8",SDLK_F8},
 	{"f9",SDLK_F9},		{"f10",SDLK_F10},	{"f11",SDLK_F11},	{"f12",SDLK_F12},
@@ -2083,6 +2225,8 @@
 	{"lessthan",SDLK_LESS},
 #endif
 
+#endif	// !SDL_VERSION_ATLEAST(2,0,0)
+
 	{0,0}
 };
 
@@ -2094,10 +2238,17 @@
 		CreateStringBind(buffer);
 		i++;
 	}
+#if SDL_VERSION_ATLEAST(2,0,0)
+	sprintf(buffer,"mod_1 \"key %d\"",SDL_SCANCODE_RCTRL);CreateStringBind(buffer);
+	sprintf(buffer,"mod_1 \"key %d\"",SDL_SCANCODE_LCTRL);CreateStringBind(buffer);
+	sprintf(buffer,"mod_2 \"key %d\"",SDL_SCANCODE_RALT);CreateStringBind(buffer);
+	sprintf(buffer,"mod_2 \"key %d\"",SDL_SCANCODE_LALT);CreateStringBind(buffer);
+#else
 	sprintf(buffer,"mod_1 \"key %d\"",SDLK_RCTRL);CreateStringBind(buffer);
 	sprintf(buffer,"mod_1 \"key %d\"",SDLK_LCTRL);CreateStringBind(buffer);
 	sprintf(buffer,"mod_2 \"key %d\"",SDLK_RALT);CreateStringBind(buffer);
 	sprintf(buffer,"mod_2 \"key %d\"",SDLK_LALT);CreateStringBind(buffer);
+#endif
 	for (CHandlerEventVector_it hit=handlergroup.begin();hit!=handlergroup.end();hit++) {
 		(*hit)->MakeDefaultBind(buffer);
 		CreateStringBind(buffer);
@@ -2190,17 +2341,91 @@
 
 void BIND_MappingEvents(void) {
 	SDL_Event event;
+	static bool isButtonPressed = false;
+	static CButton *lastHoveredButton = NULL;
 	while (SDL_PollEvent(&event)) {
 		switch (event.type) {
+		case SDL_MOUSEBUTTONDOWN:
+			isButtonPressed = true;
+			/* Further check where are we pointing at right now */
+		case SDL_MOUSEMOTION:
+			if (!isButtonPressed)
+				break;
+#if SDL_VERSION_ATLEAST(2,0,0)
+			/* Normalize position in case a scaled sub-window is used (say on Android) */
+			event.button.x=(event.button.x-mapper.draw_rect.x)*mapper.draw_surface->w/mapper.draw_rect.w;
+			if ((event.button.x<0) || (event.button.x>=mapper.draw_surface->w))
+				break;
+			event.button.y=(event.button.y-mapper.draw_rect.y)*mapper.draw_surface->h/mapper.draw_rect.h;
+			if ((event.button.y<0) || (event.button.y>=mapper.draw_surface->h))
+				break;
+#endif
+			/* Maybe we have been pointing at
+			a specific for a little while  */
+			if (lastHoveredButton) {
+				if (lastHoveredButton->OnTop(event.button.x,event.button.y))
+					break; /* No change for now */
+				if (lastHoveredButton == last_clicked)
+					lastHoveredButton->SetColor(CLR_GREEN);
+				else
+					lastHoveredButton->SetColor(CLR_WHITE);
+				mapper.redraw=true;
+				lastHoveredButton=NULL;
+			}
+			/* Check which button are we currently pointing at */
+			for (CButton_it but_it = buttons.begin();but_it!=buttons.end();but_it++) {
+				if ((*but_it)->OnTop(event.button.x,event.button.y)) {
+					(*but_it)->SetColor(CLR_RED);
+					mapper.redraw=true;
+					lastHoveredButton=*but_it;
+					break;
+				}
+			}
+			break;
 		case SDL_MOUSEBUTTONUP:
+			isButtonPressed = false;
+			if (lastHoveredButton) {
+				/* For most buttons the actual new color is
+				going to be green; But not for a few others. */
+				lastHoveredButton->SetColor(CLR_WHITE);
+				mapper.redraw=true;
+				lastHoveredButton = NULL;
+			}
+#if SDL_VERSION_ATLEAST(2,0,0)
+			/* Normalize position in case a scaled sub-window is used (say on Android) */
+			event.button.x=(event.button.x-mapper.draw_rect.x)*mapper.draw_surface->w/mapper.draw_rect.w;
+			if ((event.button.x<0) || (event.button.x>=mapper.draw_surface->w))
+				break;
+			event.button.y=(event.button.y-mapper.draw_rect.y)*mapper.draw_surface->h/mapper.draw_rect.h;
+			if ((event.button.y<0) || (event.button.y>=mapper.draw_surface->h))
+				break;
+#endif
 			/* Check the press */
 			for (CButton_it but_it = buttons.begin();but_it!=buttons.end();but_it++) {
 				if ((*but_it)->OnTop(event.button.x,event.button.y)) {
 					(*but_it)->Click();
+					break;
 				}
-			}	
+			}
 			break;
+#if SDL_VERSION_ATLEAST(2,0,0)
+		case SDL_WINDOWEVENT:
+			/* The resize event MAY arrive e.g. when the mapper is
+			 * toggled, at least on X11. Furthermore, the restore
+			 * event should be handled on Android.
+			 */
+			if ((event.window.event == SDL_WINDOWEVENT_RESIZED)
+			    || (event.window.event == SDL_WINDOWEVENT_RESTORED)) {
+				mapper.surface = SDL_GetWindowSurface(mapper.window);
+				GFX_UpdateDisplayDimensions(event.window.data1, event.window.data2);
+				mapper.draw_rect=GFX_GetSDLSurfaceSubwindowDims(640,480);
+				DrawButtons();
+			}
+			break;
+#endif
 		case SDL_QUIT:
+			isButtonPressed = false;
+			lastHoveredButton = NULL;
 			mapper.exit=true;
 			break;
 		default:
@@ -2275,7 +2500,11 @@
 
 static void CreateBindGroups(void) {
 	bindgroups.clear();
+#if SDL_VERSION_ATLEAST(2,0,0)
+	new CKeyBindGroup(SDL_NUM_SCANCODES);
+#else
 	new CKeyBindGroup(SDLK_LAST);
+#endif
 	if (joytype != JOY_NONE) {
 #if defined (REDUCE_JOYSTICK_POLLING)
 		// direct access to the SDL joystick, thus removed from the event handling
@@ -2358,11 +2587,27 @@
 
 	/* Be sure that there is no update in progress */
 	GFX_EndUpdate( 0 );
-	mapper.surface=SDL_SetVideoMode_Wrap(640,480,8,0);
+#if SDL_VERSION_ATLEAST(2,0,0)
+	mapper.window=GFX_SetSDLSurfaceWindow(640,480);
+	if (mapper.window == NULL) E_Exit("Could not initialize video mode for mapper: %s",SDL_GetError());
+	mapper.surface=SDL_GetWindowSurface(mapper.window);
+#else
+	mapper.surface=SDL_SetVideoMode_Wrap(640,480,0,0);
+#endif
 	if (mapper.surface == NULL) E_Exit("Could not initialize video mode for mapper: %s",SDL_GetError());
 
-	/* Set some palette entries */
-	SDL_SetPalette(mapper.surface, SDL_LOGPAL|SDL_PHYSPAL, map_pal, 0, 6);
+	mapper.draw_surface=SDL_CreateRGBSurface(0,640,480,8,0,0,0,0);
+#if SDL_VERSION_ATLEAST(2,0,0)
+	// Needed for SDL_BlitScaled
+	mapper.draw_surface_nonpaletted=SDL_CreateRGBSurface(0,640,480,32,0x0000ff00,0x00ff0000,0xff000000,0);
+	mapper.draw_rect=GFX_GetSDLSurfaceSubwindowDims(640,480);
+	// Sorry, but SDL_SetSurfacePalette requires a full palette.
+	SDL_Palette *sdl2_map_pal_ptr = SDL_AllocPalette(256);
+	SDL_SetPaletteColors(sdl2_map_pal_ptr, map_pal, 0, 5);
+	SDL_SetSurfacePalette(mapper.draw_surface, sdl2_map_pal_ptr);
+#else	// !SDL_VERSION_ATLEAST(2,0,0)
+	SDL_SetPalette(mapper.draw_surface, SDL_LOGPAL|SDL_PHYSPAL, map_pal, 0, 5);
+#endif
 	if (last_clicked) {
 		last_clicked->BindColor();
 		last_clicked=NULL;
@@ -2378,10 +2623,23 @@
 		if (mapper.redraw) {
 			mapper.redraw=false;		
 			DrawButtons();
+		} else {
+#if SDL_VERSION_ATLEAST(2,0,0)
+			SDL_UpdateWindowSurface(mapper.window);
+#else
+			SDL_Flip(mapper.surface);
+#endif
 		}
 		BIND_MappingEvents();
 		SDL_Delay(1);
 	}
+	/* ONE SHOULD NOT FORGET TO DO THIS!
+	Unless a memory leak is desired... */
+	SDL_FreeSurface(mapper.draw_surface);
+#if SDL_VERSION_ATLEAST(2,0,0)
+	SDL_FreeSurface(mapper.draw_surface_nonpaletted);
+	SDL_FreePalette(sdl2_map_pal_ptr);
+#endif
 #if defined (REDUCE_JOYSTICK_POLLING)
 	SDL_JoystickEventState(SDL_DISABLE);
 #endif
@@ -2430,6 +2688,8 @@
 	mapper.sticks.num_groups=0;
 	memset(&virtual_joysticks,0,sizeof(virtual_joysticks));
 
+#if !SDL_VERSION_ATLEAST(2,0,0)
+
 	usescancodes = false;
 
 	if (section->Get_bool("usescancodes")) {
@@ -2551,6 +2811,8 @@
 		}
 	}
 
+#endif	// !SDL_VERSION_ATLEAST(2,0,0)
+
 	Prop_path* pp = section->Get_path("mapperfile");
 	mapper.filename = pp->realpath;
 	MAPPER_AddHandler(&MAPPER_Run,MK_f1,MMOD1,"mapper","Mapper");
Index: src/gui/sdlmain.cpp
===================================================================
--- src/gui/sdlmain.cpp.orig	2015-06-03 18:22:38.520638602 +0100
+++ src/gui/sdlmain.cpp	2015-06-03 18:44:53.337076869 +0100
@@ -31,6 +31,9 @@
 #include <signal.h>
 #include <process.h>
 #endif
+#ifdef __ANDROID__
+#include <android/log.h>
+#endif
 
 #include "cross.h"
 #include "SDL.h"
@@ -54,7 +57,11 @@
 //#define DISABLE_JOYSTICK
 
 #if C_OPENGL
+#ifdef __ANDROID__
+#include "SDL_opengles.h"
+#else
 #include "SDL_opengl.h"
+#endif
 
 #ifndef APIENTRY
 #define APIENTRY
@@ -81,12 +88,14 @@
 typedef GLboolean (APIENTRYP PFNGLUNMAPBUFFERARBPROC) (GLenum target);
 #endif
 
+#ifndef __ANDROID__
 PFNGLGENBUFFERSARBPROC glGenBuffersARB = NULL;
 PFNGLBINDBUFFERARBPROC glBindBufferARB = NULL;
 PFNGLDELETEBUFFERSARBPROC glDeleteBuffersARB = NULL;
 PFNGLBUFFERDATAARBPROC glBufferDataARB = NULL;
 PFNGLMAPBUFFERARBPROC glMapBufferARB = NULL;
 PFNGLUNMAPBUFFERARBPROC glUnmapBufferARB = NULL;
+#endif
 
 #endif //C_OPENGL
 
@@ -129,8 +138,12 @@
 
 enum SCREEN_TYPES	{
 	SCREEN_SURFACE,
+#if SDL_VERSION_ATLEAST(2,0,0)
+	SCREEN_TEXTURE,
+#else
 	SCREEN_SURFACE_DDRAW,
 	SCREEN_OVERLAY,
+#endif
 	SCREEN_OPENGL
 };
 
@@ -148,10 +161,17 @@
 	bool inited;
 	bool active;							//If this isn't set don't draw
 	bool updating;
+#if SDL_VERSION_ATLEAST(2,0,0)
+	bool update_display_contents;
+	bool update_window;
+	int window_desired_width, window_desired_height;
+#endif
 	struct {
 		Bit32u width;
 		Bit32u height;
-		Bit32u bpp;
+#if 0
+		Bit32u bpp; // Is that ever used?
+#endif
 		Bitu flags;
 		double scalex,scaley;
 		GFX_CallBack_t callback;
@@ -161,45 +181,72 @@
 		struct {
 			Bit16u width, height;
 			bool fixed;
+#if SDL_VERSION_ATLEAST(2,0,0)
+			bool display_res;
+#endif
 		} full;
 		struct {
 			Bit16u width, height;
 		} window;
 		Bit8u bpp;
+#if SDL_VERSION_ATLEAST(2,0,0)
+		Bit32u sdl2pixelFormat;
+#endif
 		bool fullscreen;
 		bool lazy_fullscreen;
 		bool lazy_fullscreen_req;
-		bool doublebuf;
+		bool vsync;
 		SCREEN_TYPES type;
 		SCREEN_TYPES want_type;
 	} desktop;
 #if C_OPENGL
 	struct {
+#if SDL_VERSION_ATLEAST(2,0,0)
+		SDL_GLContext context;
+#endif
 		Bitu pitch;
 		void * framebuf;
 		GLuint buffer;
 		GLuint texture;
+#ifdef __ANDROID__ // OpenGL ES
+		GLfloat vertCoords[8];
+		GLfloat texCoords[8];
+#else // OpenGL (not ES)
 		GLuint displaylist;
+#endif
 		GLint max_texsize;
 		bool bilinear;
 		bool packed_pixel;
 		bool paletted_texture;
 		bool pixel_buffer_object;
 	} opengl;
-#endif
+#endif	// C_OPENGL
+#if !SDL_VERSION_ATLEAST(2,0,0)
 	struct {
 		SDL_Surface * surface;
 #if (HAVE_DDRAW_H) && defined(WIN32)
 		RECT rect;
-#endif
+#endif // Windows
 	} blit;
+#endif // Not SDL v2.0
 	struct {
 		PRIORITY_LEVELS focus;
 		PRIORITY_LEVELS nofocus;
 	} priority;
 	SDL_Rect clip;
 	SDL_Surface * surface;
+#if SDL_VERSION_ATLEAST(2,0,0)
+	SDL_Window * window;
+	SDL_Renderer * renderer;
+	const char * rendererDriver;
+	int displayNumber;
+	struct {
+		SDL_Texture * texture;
+		SDL_PixelFormat * pixelFormat;
+	} texture;
+#else
 	SDL_Overlay * overlay;
+#endif
 	SDL_cond *cond;
 	struct {
 		bool autolock;
@@ -207,6 +254,13 @@
 		bool requestlock;
 		bool locked;
 		Bitu sensitivity;
+#ifdef __ANDROID__
+		SDL_FingerID leftMouseFingerID, rightMouseFingerID,
+		             middleMouseFingerID, mouseMotionFingerID,
+		             escKeyFingerID;
+		bool isLeftMouseFingerUsed, isRightMouseFingerUsed,
+		     isMiddleMouseFingerUsed, isEscKeyFingerUsed;
+#endif
 	} mouse;
 	SDL_Rect updateRects[1024];
 	Bitu num_joysticks;
@@ -220,6 +274,8 @@
 
 static SDL_Block sdl;
 
+#if !SDL_VERSION_ATLEAST(2,0,0)
+
 #define SETMODE_SAVES 1  //Don't set Video Mode if nothing changes.
 #define SETMODE_SAVES_CLEAR 0 //Clear the screen, when the Video Mode is reused
 SDL_Surface* SDL_SetVideoMode_Wrap(int width,int height,int bpp,Bit32u flags){
@@ -272,6 +328,8 @@
 	return s;
 }
 
+#endif // !SDL_VERSION_ATLEAST(2,0,0)
+
 extern const char* RunningProgram;
 extern bool CPU_CycleAutoAdjust;
 //Globals for keyboard initialisation
@@ -291,7 +349,11 @@
 	}
 
 	if(paused) strcat(title," PAUSED");
+#if SDL_VERSION_ATLEAST(2,0,0)
+	SDL_SetWindowTitle(sdl.window,title); // VERSION is gone...
+#else
 	SDL_WM_SetCaption(title,VERSION);
+#endif
 }
 
 static unsigned char logo[32*32*4]= {
@@ -306,9 +368,14 @@
 	SDL_Surface* logos= SDL_CreateRGBSurfaceFrom((void*)logo,32,32,32,128,0xff000000,0x00ff0000,0x0000ff00,0);
 #else
 	SDL_Surface* logos= SDL_CreateRGBSurfaceFrom((void*)logo,32,32,32,128,0x000000ff,0x0000ff00,0x00ff0000,0);
-#endif
+#endif // WORDS_BIGENDIAN
+
+#if SDL_VERSION_ATLEAST(2,0,0)
+	SDL_SetWindowIcon(sdl.window, logos);
+#else
 	SDL_WM_SetIcon(logos,NULL);
-#endif
+#endif // SDL_VERSION_ATLEAST(2,0,0)
+#endif // !defined(MACOSX)
 }
 
 
@@ -329,12 +396,21 @@
 	while (SDL_PollEvent(&event)) {
 		// flush event queue.
 	}
-
+	/* NOTE: This is one of the few places where we use SDL key codes
+	with SDL 2.0, rather than scan codes. Is that the correct behavior? */
 	while (paused) {
 		SDL_WaitEvent(&event);    // since we're not polling, cpu usage drops to 0.
 		switch (event.type) {
 
 			case SDL_QUIT: KillSwitch(true); break;
+#if SDL_VERSION_ATLEAST(2,0,0)
+			case SDL_WINDOWEVENT:
+				if (event.window.event == SDL_WINDOWEVENT_RESTORED) {
+					// We may need to re-create a texture and more
+					GFX_ResetScreen();
+				}
+				break;
+#endif
 			case SDL_KEYDOWN:   // Must use Pause/Break Key to resume.
 			case SDL_KEYUP:
 			if(event.key.keysym.sym == SDLK_PAUSE) {
@@ -354,19 +430,29 @@
 	}
 }
 
+#if !SDL_VERSION_ATLEAST(2,0,0)
 #if defined (WIN32)
 bool GFX_SDLUsingWinDIB(void) {
 	return sdl.using_windib;
 }
 #endif
+#endif
 
 /* Reset the screen with current values in the sdl structure */
 Bitu GFX_GetBestMode(Bitu flags) {
-	Bitu testbpp,gotbpp;
+#if !SDL_VERSION_ATLEAST(2,0,0)
+ 	Bitu testbpp,gotbpp;
+#endif
+	/* For simplicity, with SDL 2.0 we accept
+	the desktop's color depth only for now */
 	switch (sdl.desktop.want_type) {
 	case SCREEN_SURFACE:
+#if SDL_VERSION_ATLEAST(2,0,0)
+	case SCREEN_TEXTURE:
+#endif
 check_surface:
 		flags &= ~GFX_LOVE_8;		//Disable love for 8bpp modes
+#if !SDL_VERSION_ATLEAST(2,0,0)
 		/* Check if we can satisfy the depth it loves */
 		if (flags & GFX_LOVE_8) testbpp=8;
 		else if (flags & GFX_LOVE_15) testbpp=15;
@@ -378,8 +464,14 @@
 #endif
 		if (sdl.desktop.fullscreen) gotbpp=SDL_VideoModeOK(640,480,testbpp,SDL_FULLSCREEN|SDL_HWSURFACE|SDL_HWPALETTE);
 		else gotbpp=sdl.desktop.bpp;
+#endif	// !SDL_VERSION_ATLEAST(2,0,0)
 		/* If we can't get our favorite mode check for another working one */
-		switch (gotbpp) {
+#if SDL_VERSION_ATLEAST(2,0,0)
+		switch (sdl.desktop.bpp)
+#else
+		switch (gotbpp)
+#endif
+		{
 		case 8:
 			if (flags & GFX_CAN_8) flags&=~(GFX_CAN_15|GFX_CAN_16|GFX_CAN_32);
 			break;
@@ -394,8 +486,14 @@
 			if (flags & GFX_CAN_32) flags&=~(GFX_CAN_8|GFX_CAN_15|GFX_CAN_16);
 			break;
 		}
-		flags |= GFX_CAN_RANDOM;
+#if SDL_VERSION_ATLEAST(2,0,0)
+		if (sdl.desktop.want_type == SCREEN_TEXTURE)
+			flags |= GFX_SCALING; // We want texture...
+		else	// Or we want/FORCE surface (e.g. for most scalers)
+#endif
+			flags |= GFX_CAN_RANDOM;
 		break;
+#if !SDL_VERSION_ATLEAST(2,0,0)
 #if (HAVE_DDRAW_H) && defined(WIN32)
 	case SCREEN_SURFACE_DDRAW:
 		if (!(flags&(GFX_CAN_15|GFX_CAN_16|GFX_CAN_32))) goto check_surface;
@@ -411,9 +509,14 @@
 		flags|=GFX_SCALING;
 		flags&=~(GFX_CAN_8|GFX_CAN_15|GFX_CAN_16);
 		break;
+#endif	// !SDL_VERSION_ATLEAST(2,0,0)
 #if C_OPENGL
 	case SCREEN_OPENGL:
-		if (flags & GFX_RGBONLY || !(flags&GFX_CAN_32)) goto check_surface;
+#ifdef __ANDROID__
+		if (!(flags&GFX_CAN_32)) goto check_surface; // RGBA is used on Android (OpenGL ES v1.1)
+#else
+		if (flags & GFX_RGBONLY || !(flags&GFX_CAN_32)) goto check_surface; // BGRA otherwise
+#endif
 		flags|=GFX_SCALING;
 		flags&=~(GFX_CAN_8|GFX_CAN_15|GFX_CAN_16);
 		break;
@@ -451,19 +554,162 @@
     return log;
 }
 
+#if SDL_VERSION_ATLEAST(2,0,0)
+
+static SDL_Window * GFX_SetSDLWindowMode(Bit16u width, Bit16u height, bool fullscreen, SCREEN_TYPES screenType) {
+	static SCREEN_TYPES lastType = SCREEN_SURFACE; 
+	if (sdl.renderer) {
+		SDL_DestroyRenderer(sdl.renderer);
+		sdl.renderer=0;
+	}
+	if (sdl.texture.pixelFormat) {
+		SDL_FreeFormat(sdl.texture.pixelFormat);
+		sdl.texture.pixelFormat = 0;
+	}
+	if (sdl.texture.texture) {
+		SDL_DestroyTexture(sdl.texture.texture);
+		sdl.texture.texture=0;
+	}
+#if C_OPENGL
+	if (sdl.opengl.context) {
+		SDL_GL_DeleteContext(sdl.opengl.context);
+		sdl.opengl.context=0;
+	}
+#endif
+	sdl.window_desired_width = width;
+	sdl.window_desired_height = height;
+	int currWidth, currHeight;
+	if (sdl.window) {
+		//SDL_GetWindowSize(sdl.window, &currWidth, &currHeight);
+		if (!sdl.update_window) {
+			SDL_GetWindowSize(sdl.window, &currWidth, &currHeight);
+			sdl.update_display_contents = ((width == currWidth) && (height == currHeight));
+			return sdl.window;
+		}
+	}
+	/* If we change screen type, recreate the window. Furthermore, if
+	 * it is our very first time then we simply create a new window.
+	 */
+	if (!sdl.window
+	    || (lastType != screenType)
+//	    || (currWidth != width) || (currHeight != height)
+//	    || (glwindow != (0 != (SDL_GetWindowFlags(sdl.window) & SDL_WINDOW_OPENGL)))
+//	    || (fullscreen && (0 == (SDL_GetWindowFlags(sdl.window) & SDL_WINDOW_FULLSCREEN)))
+//	    || (fullscreen != (SDL_WINDOW_FULLSCREEN == (SDL_GetWindowFlags(sdl.window) & SDL_WINDOW_FULLSCREEN)))
+//	    || (fullscreen && ((width != currWidth) || (height != currHeight)))
+	) {
+		lastType = screenType;
+		if (sdl.window) {
+			SDL_DestroyWindow(sdl.window);
+		}
+		sdl.window = SDL_CreateWindow("",
+		                 SDL_WINDOWPOS_UNDEFINED_DISPLAY(sdl.displayNumber),
+		                 SDL_WINDOWPOS_UNDEFINED_DISPLAY(sdl.displayNumber),
+		                 width, height,
+		                 (fullscreen ? (sdl.desktop.full.display_res ? SDL_WINDOW_FULLSCREEN_DESKTOP : SDL_WINDOW_FULLSCREEN) : 0)
+		                 | ((screenType == SCREEN_OPENGL) ? SDL_WINDOW_OPENGL : 0) | SDL_WINDOW_SHOWN);
+		if (sdl.window)
+			GFX_SetTitle(-1,-1,false); //refresh title.
+		SDL_GetWindowSize(sdl.window, &currWidth, &currHeight);
+		sdl.update_display_contents = ((width == currWidth) && (height == currHeight));
+		return sdl.window;
+	}
+	/* Fullscreen mode switching has its limits, and is also problematic on
+	 * some window managers. For now, the following may work up to some
+	 * level. On X11, SDL_VIDEO_X11_LEGACY_FULLSCREEN=1 can also help,
+	 * although it has its own issues.
+	 * Suggestion: Use the desktop res if possible, with output=surface
+	 * if one is not interested in scaling.
+	 * On Android, desktop res is the only way.
+	 */
+	if (fullscreen) {
+		SDL_DisplayMode displayMode;
+		SDL_GetWindowDisplayMode(sdl.window, &displayMode);
+		displayMode.w = width;
+		displayMode.h = height;
+		SDL_SetWindowDisplayMode(sdl.window, &displayMode);
+
+		SDL_SetWindowFullscreen(sdl.window, SDL_WINDOW_FULLSCREEN_DESKTOP);
+	} else {
+		SDL_SetWindowFullscreen(sdl.window, 0);
+
+		SDL_SetWindowSize(sdl.window, width, height);
+	}
+	// Maybe some requested fullscreen resolution is unsupported?
+	SDL_GetWindowSize(sdl.window, &currWidth, &currHeight);
+	sdl.update_display_contents = ((width == currWidth) && (height == currHeight));
+	return sdl.window;
+}
+
+// Used for the mapper UI and more: Creates a fullscreen window with desktop res
+// on Android, and a non-fullscreen window with the input dimensions otherwise.
+SDL_Window * GFX_SetSDLSurfaceWindow(Bit16u width, Bit16u height) {
+#ifdef __ANDROID__
+	return GFX_SetSDLWindowMode(sdl.desktop.full.width, sdl.desktop.full.height, true, SCREEN_SURFACE);
+#else
+	return GFX_SetSDLWindowMode(width, height, false, SCREEN_SURFACE);
+#endif
+}
+
+// Returns the rectangle in the current window to be used for scaling a
+// sub-window with the given dimensions, like the mapper UI.
+SDL_Rect GFX_GetSDLSurfaceSubwindowDims(Bit16u width, Bit16u height) {
+	SDL_Rect rect;
+#ifdef __ANDROID__
+	// Wider than width:height
+	if (height*sdl.desktop.full.width > sdl.desktop.full.height*width) {
+		rect.w=sdl.desktop.full.height*width/height;
+		rect.h=sdl.desktop.full.height;
+		rect.x=(sdl.desktop.full.width-rect.w)/2;
+		rect.y=0;
+	} else { // NOT wider than width:height
+		rect.w=sdl.desktop.full.width;
+		rect.h=sdl.desktop.full.width*height/width;
+		rect.x=0;
+		rect.y=(sdl.desktop.full.height-rect.h)/2;
+	}
+#else
+	rect.x=rect.y=0;
+	rect.w=width;
+	rect.h=height;
+#endif
+	return rect;
+}
 
-static SDL_Surface * GFX_SetupSurfaceScaled(Bit32u sdl_flags, Bit32u bpp) {
+// Currently used for an initial test here
+static SDL_Window * GFX_SetSDLOpenGLWindow(Bit16u width, Bit16u height) {
+#ifdef __ANDROID__
+	return GFX_SetSDLWindowMode(sdl.desktop.full.width, sdl.desktop.full.height, true, SCREEN_OPENGL);
+#else
+	return GFX_SetSDLWindowMode(width, height, false, SCREEN_OPENGL);
+#endif
+}
+
+#endif // SDL_VERSION_ATLEAST(2,0,0)
+
+// Different functions, similar function bodies (SDL 1.2 vs 2.0)
+
+#if SDL_VERSION_ATLEAST(2,0,0)
+static SDL_Window * GFX_SetupWindowScaled(SCREEN_TYPES screenType)
+#else
+static SDL_Surface * GFX_SetupSurfaceScaled(Bit32u sdl_flags, Bit32u bpp)
+#endif
+{
 	Bit16u fixedWidth;
 	Bit16u fixedHeight;
 
 	if (sdl.desktop.fullscreen) {
 		fixedWidth = sdl.desktop.full.fixed ? sdl.desktop.full.width : 0;
 		fixedHeight = sdl.desktop.full.fixed ? sdl.desktop.full.height : 0;
+#if !SDL_VERSION_ATLEAST(2,0,0)
 		sdl_flags |= SDL_FULLSCREEN|SDL_HWSURFACE;
+#endif
 	} else {
 		fixedWidth = sdl.desktop.window.width;
 		fixedHeight = sdl.desktop.window.height;
+#if !SDL_VERSION_ATLEAST(2,0,0)
 		sdl_flags |= SDL_HWSURFACE;
+#endif
 	}
 	if (fixedWidth && fixedHeight) {
 		double ratio_w=(double)fixedWidth/(sdl.draw.width*sdl.draw.scalex);
@@ -479,27 +725,59 @@
 			sdl.clip.w=(Bit16u)(sdl.draw.width*sdl.draw.scalex*ratio_h + 0.4);
 			sdl.clip.h=(Bit16u)fixedHeight;			
 		}
-		if (sdl.desktop.fullscreen)
+		if (sdl.desktop.fullscreen) {
+#if SDL_VERSION_ATLEAST(2,0,0)
+			sdl.window = GFX_SetSDLWindowMode(fixedWidth, fixedHeight, sdl.desktop.fullscreen, screenType);
+#else
 			sdl.surface = SDL_SetVideoMode_Wrap(fixedWidth,fixedHeight,bpp,sdl_flags);
-		else
+#endif
+		} else {
+#if SDL_VERSION_ATLEAST(2,0,0)
+			sdl.window = GFX_SetSDLWindowMode(sdl.clip.w, sdl.clip.h, sdl.desktop.fullscreen, screenType);
+#else
 			sdl.surface = SDL_SetVideoMode_Wrap(sdl.clip.w,sdl.clip.h,bpp,sdl_flags);
+#endif
+		}
+#if SDL_VERSION_ATLEAST(2,0,0)
+		if (sdl.window && SDL_GetWindowFlags(sdl.window) & SDL_WINDOW_FULLSCREEN) {
+			int windowWidth;
+			SDL_GetWindowSize(sdl.window, &windowWidth, NULL);
+			sdl.clip.x=(Sint16)((windowWidth-sdl.clip.w)/2);
+#else
 		if (sdl.surface && sdl.surface->flags & SDL_FULLSCREEN) {
 			sdl.clip.x=(Sint16)((sdl.surface->w-sdl.clip.w)/2);
-			sdl.clip.y=(Sint16)((sdl.surface->h-sdl.clip.h)/2);
+#endif
+#ifdef __ANDROID__
+			/* Portrait orientation and on-screen keyboards
+			are commonly found on that platform          */
+			sdl.clip.y=0;
+#else
+			sdl.clip.y=(Sint16)((fixedHeight-sdl.clip.h)/2);
+#endif
 		} else {
 			sdl.clip.x = 0;
 			sdl.clip.y = 0;
 		}
+#if SDL_VERSION_ATLEAST(2,0,0)
+		return sdl.window;
+#else
 		return sdl.surface;
+#endif
 	} else {
 		sdl.clip.x=0;sdl.clip.y=0;
 		sdl.clip.w=(Bit16u)(sdl.draw.width*sdl.draw.scalex);
 		sdl.clip.h=(Bit16u)(sdl.draw.height*sdl.draw.scaley);
+#if SDL_VERSION_ATLEAST(2,0,0)
+		sdl.window = GFX_SetSDLWindowMode(sdl.clip.w, sdl.clip.h, sdl.desktop.fullscreen, screenType);
+		return sdl.window;
+#else
 		sdl.surface=SDL_SetVideoMode_Wrap(sdl.clip.w,sdl.clip.h,bpp,sdl_flags);
 		return sdl.surface;
+#endif
 	}
 }
 
+#if 0 // NOTE: Do we need this? Never used and can't be used as-is with SDL 2.0
 void GFX_TearDown(void) {
 	if (sdl.updating)
 		GFX_EndUpdate( 0 );
@@ -509,6 +787,7 @@
 		sdl.blit.surface=0;
 	}
 }
+#endif
 
 Bitu GFX_SetSize(Bitu width,Bitu height,Bitu flags,double scalex,double scaley,GFX_CallBack_t callback) {
 	if (sdl.updating)
@@ -520,41 +799,72 @@
 	sdl.draw.scalex=scalex;
 	sdl.draw.scaley=scaley;
 
-	int bpp=0;
 	Bitu retFlags = 0;
+#if !SDL_VERSION_ATLEAST(2,0,0)
+	int bpp=0;
 
 	if (sdl.blit.surface) {
 		SDL_FreeSurface(sdl.blit.surface);
 		sdl.blit.surface=0;
 	}
+#endif
 	switch (sdl.desktop.want_type) {
 	case SCREEN_SURFACE:
 dosurface:
+#if !SDL_VERSION_ATLEAST(2,0,0)
 		if (flags & GFX_CAN_8) bpp=8;
 		if (flags & GFX_CAN_15) bpp=15;
 		if (flags & GFX_CAN_16) bpp=16;
 		if (flags & GFX_CAN_32) bpp=32;
+#endif
 		sdl.desktop.type=SCREEN_SURFACE;
 		sdl.clip.w=width;
 		sdl.clip.h=height;
 		if (sdl.desktop.fullscreen) {
 			if (sdl.desktop.full.fixed) {
 				sdl.clip.x=(Sint16)((sdl.desktop.full.width-width)/2);
+#ifdef __ANDROID__
+				/* Portrait orientation and on-screen keyboards
+				are commonly found on that platform          */
+				sdl.clip.y=0;
+#else
 				sdl.clip.y=(Sint16)((sdl.desktop.full.height-height)/2);
+#endif
+#if SDL_VERSION_ATLEAST(2,0,0)
+				sdl.window = GFX_SetSDLWindowMode(sdl.desktop.full.width,
+				                                  sdl.desktop.full.height,
+				                                  sdl.desktop.fullscreen, sdl.desktop.type);
+				if (sdl.window == NULL)
+					E_Exit("Could not set fullscreen video mode %ix%i-%i: %s",sdl.desktop.full.width,sdl.desktop.full.height,sdl.desktop.bpp,SDL_GetError());
+#else
 				sdl.surface=SDL_SetVideoMode_Wrap(sdl.desktop.full.width,sdl.desktop.full.height,bpp,
 					SDL_FULLSCREEN | ((flags & GFX_CAN_RANDOM) ? SDL_SWSURFACE : SDL_HWSURFACE) |
-					(sdl.desktop.doublebuf ? SDL_DOUBLEBUF|SDL_ASYNCBLIT : 0) | SDL_HWPALETTE);
+					(sdl.desktop.vsync ? SDL_DOUBLEBUF|SDL_ASYNCBLIT : 0) | SDL_HWPALETTE);
 				if (sdl.surface == NULL) E_Exit("Could not set fullscreen video mode %ix%i-%i: %s",sdl.desktop.full.width,sdl.desktop.full.height,bpp,SDL_GetError());
+#endif
 			} else {
 				sdl.clip.x=0;sdl.clip.y=0;
+#if SDL_VERSION_ATLEAST(2,0,0)
+				sdl.window = GFX_SetSDLWindowMode(width, height,
+				                                  sdl.desktop.fullscreen, sdl.desktop.type);
+				if (sdl.window == NULL)
+					E_Exit("Could not set fullscreen video mode %ix%i-%i: %s",(int)width,(int)height,sdl.desktop.bpp,SDL_GetError());
+#else
 				sdl.surface=SDL_SetVideoMode_Wrap(width,height,bpp,
 					SDL_FULLSCREEN | ((flags & GFX_CAN_RANDOM) ? SDL_SWSURFACE : SDL_HWSURFACE) |
-					(sdl.desktop.doublebuf ? SDL_DOUBLEBUF|SDL_ASYNCBLIT  : 0)|SDL_HWPALETTE);
+					(sdl.desktop.vsync ? SDL_DOUBLEBUF|SDL_ASYNCBLIT  : 0)|SDL_HWPALETTE);
 				if (sdl.surface == NULL)
 					E_Exit("Could not set fullscreen video mode %ix%i-%i: %s",(int)width,(int)height,bpp,SDL_GetError());
+#endif
 			}
 		} else {
 			sdl.clip.x=0;sdl.clip.y=0;
+#if SDL_VERSION_ATLEAST(2,0,0)
+			sdl.window = GFX_SetSDLWindowMode(width, height,
+			                                  sdl.desktop.fullscreen, sdl.desktop.type);
+			if (sdl.window == NULL)
+				E_Exit("Could not set windowed video mode %ix%i-%i: %s",(int)width,(int)height,sdl.desktop.bpp,SDL_GetError());
+#else
 			sdl.surface=SDL_SetVideoMode_Wrap(width,height,bpp,(flags & GFX_CAN_RANDOM) ? SDL_SWSURFACE : SDL_HWSURFACE);
 #ifdef WIN32
 			if (sdl.surface == NULL) {
@@ -576,42 +886,121 @@
 #endif
 			if (sdl.surface == NULL)
 				E_Exit("Could not set windowed video mode %ix%i-%i: %s",(int)width,(int)height,bpp,SDL_GetError());
+#endif	// !SDL_VERSION_ATLEAST(2,0,0)
 		}
-		if (sdl.surface) {
-			switch (sdl.surface->format->BitsPerPixel) {
+#if SDL_VERSION_ATLEAST(2,0,0)
+		sdl.surface = SDL_GetWindowSurface(sdl.window);
+		if (sdl.surface == NULL)
+				E_Exit("Could not retrieve window surface: %s",SDL_GetError());
+#endif
+		switch (sdl.surface->format->BitsPerPixel) {
 			case 8:
 				retFlags = GFX_CAN_8;
-                break;
+				break;
 			case 15:
 				retFlags = GFX_CAN_15;
 				break;
 			case 16:
 				retFlags = GFX_CAN_16;
-                break;
+				break;
 			case 32:
 				retFlags = GFX_CAN_32;
-                break;
-			}
-			if (retFlags && (sdl.surface->flags & SDL_HWSURFACE))
-				retFlags |= GFX_HARDWARE;
-			if (retFlags && (sdl.surface->flags & SDL_DOUBLEBUF)) {
-				sdl.blit.surface=SDL_CreateRGBSurface(SDL_HWSURFACE,
-					sdl.draw.width, sdl.draw.height,
-					sdl.surface->format->BitsPerPixel,
-					sdl.surface->format->Rmask,
-					sdl.surface->format->Gmask,
-					sdl.surface->format->Bmask,
-				0);
-				/* If this one fails be ready for some flickering... */
-			}
+				break;
 		}
+#if SDL_VERSION_ATLEAST(2,0,0)
+		/* Fix a glitch with aspect=true occuring when
+		changing between modes with different dimensions */
+		SDL_FillRect(sdl.surface, NULL, SDL_MapRGB(sdl.surface->format, 0, 0, 0));
+		SDL_UpdateWindowSurface(sdl.window);
+#else
+		if (retFlags && (sdl.surface->flags & SDL_HWSURFACE))
+			retFlags |= GFX_HARDWARE;
+		if (retFlags && (sdl.surface->flags & SDL_DOUBLEBUF)) {
+			sdl.blit.surface=SDL_CreateRGBSurface(SDL_HWSURFACE,
+				sdl.draw.width, sdl.draw.height,
+				sdl.surface->format->BitsPerPixel,
+				sdl.surface->format->Rmask,
+				sdl.surface->format->Gmask,
+				sdl.surface->format->Bmask,
+			0);
+			/* If this one fails be ready for some flickering... */
+		}
+#endif
 		break;
+#if SDL_VERSION_ATLEAST(2,0,0)
+	case SCREEN_TEXTURE:
+	{
+#if 0
+		if (!strcmp(sdl.rendererDriver, "opengles")) {
+			if (!(flags&GFX_CAN_32) || (flags & GFX_RGBONLY)) goto dosurface;
+		}
+#endif
+		if (!GFX_SetupWindowScaled(sdl.desktop.want_type)) {
+			LOG_MSG("SDL:Can't set video mode, falling back to surface");
+			goto dosurface;
+		}
+		if (strcmp(sdl.rendererDriver, "auto"))
+			SDL_SetHint(SDL_HINT_RENDER_DRIVER, sdl.rendererDriver); 
+		sdl.renderer = SDL_CreateRenderer(sdl.window, -1,
+		                                  SDL_RENDERER_ACCELERATED |
+		                                  (sdl.desktop.vsync ? SDL_RENDERER_PRESENTVSYNC : 0));
+		if (!sdl.renderer) {
+			LOG_MSG("%s\n", SDL_GetError());
+			LOG_MSG("SDL:Can't create renderer, falling back to surface");
+			goto dosurface;
+		}
+		/* SDL_PIXELFORMAT_ARGB8888 is possible with most
+		rendering drivers, "opengles" being a notable exception */
+		sdl.texture.texture = SDL_CreateTexture(sdl.renderer, SDL_PIXELFORMAT_ARGB8888,
+		                                        SDL_TEXTUREACCESS_STREAMING, width, height);
+		/* SDL_PIXELFORMAT_ABGR8888 (not RGB) is the
+		only supported format for the "opengles" driver */
+		if (!sdl.texture.texture) {
+			if (flags & GFX_RGBONLY) goto dosurface;
+			sdl.texture.texture = SDL_CreateTexture(sdl.renderer, SDL_PIXELFORMAT_ABGR8888,
+			                                        SDL_TEXTUREACCESS_STREAMING, width, height);
+		}
+		if (!sdl.texture.texture) {
+			SDL_DestroyRenderer(sdl.renderer);
+			sdl.renderer = NULL;
+			LOG_MSG("SDL:Can't create texture, falling back to surface");
+			goto dosurface;
+		}
+		SDL_SetRenderDrawColor(sdl.renderer, 0, 0, 0, SDL_ALPHA_OPAQUE);
+		sdl.desktop.type=SCREEN_TEXTURE;
+		Uint32 pixelFormat;
+		SDL_QueryTexture(sdl.texture.texture, &pixelFormat, NULL, NULL, NULL);
+		sdl.texture.pixelFormat = SDL_AllocFormat(pixelFormat);
+		switch (SDL_BITSPERPIXEL(pixelFormat)) {
+			case 8:
+				retFlags = GFX_CAN_8;
+				break;
+			case 15:
+				retFlags = GFX_CAN_15;
+				break;
+			case 16:
+				retFlags = GFX_CAN_16;
+				break;
+			case 24: /* SDL_BYTESPERPIXEL is probably 4, though. */
+			case 32:
+				retFlags = GFX_CAN_32;
+				break;
+		}
+		retFlags |= GFX_SCALING;
+		SDL_RendererInfo rendererInfo;
+		SDL_GetRendererInfo(sdl.renderer, &rendererInfo);
+		LOG_MSG("Using driver \"%s\" for renderer", rendererInfo.name);
+		if (rendererInfo.flags & SDL_RENDERER_ACCELERATED)
+			retFlags |= GFX_HARDWARE;
+		break;
+	}
+#else	// !SDL_VERSION_ATLEAST(2,0,0)
 #if (HAVE_DDRAW_H) && defined(WIN32)
 	case SCREEN_SURFACE_DDRAW:
 		if (flags & GFX_CAN_15) bpp=15;
 		if (flags & GFX_CAN_16) bpp=16;
 		if (flags & GFX_CAN_32) bpp=32;
-		if (!GFX_SetupSurfaceScaled((sdl.desktop.doublebuf && sdl.desktop.fullscreen) ? SDL_DOUBLEBUF : 0,bpp)) goto dosurface;
+		if (!GFX_SetupSurfaceScaled((sdl.desktop.vsync && sdl.desktop.fullscreen) ? SDL_DOUBLEBUF : 0,bpp)) goto dosurface;
 		sdl.blit.rect.top=sdl.clip.y;
 		sdl.blit.rect.left=sdl.clip.x;
 		sdl.blit.rect.right=sdl.clip.x+sdl.clip.w;
@@ -659,49 +1048,98 @@
 		sdl.desktop.type=SCREEN_OVERLAY;
 		retFlags = GFX_CAN_32 | GFX_SCALING | GFX_HARDWARE;
 		break;
+#endif	// !SDL_VERSION_ATLEAST(2,0,0)
 #if C_OPENGL
 	case SCREEN_OPENGL:
 	{
+#ifndef __ANDROID__
 		if (sdl.opengl.pixel_buffer_object) {
 			glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT, 0);
 			if (sdl.opengl.buffer) glDeleteBuffersARB(1, &sdl.opengl.buffer);
-		} else if (sdl.opengl.framebuf) {
+		} else
+#endif
+		if (sdl.opengl.framebuf) {
 			free(sdl.opengl.framebuf);
 		}
 		sdl.opengl.framebuf=0;
-		if (!(flags&GFX_CAN_32) || (flags & GFX_RGBONLY)) goto dosurface;
+#ifdef __ANDROID__
+		if (!(flags&GFX_CAN_32)) goto dosurface; // RGBA is used on Android (OpenGL ES v1.1)
+#else
+		if (!(flags&GFX_CAN_32) || (flags & GFX_RGBONLY)) goto dosurface; // BGRA otherwise
+#endif
 		int texsize=2 << int_log2(width > height ? width : height);
 		if (texsize>sdl.opengl.max_texsize) {
 			LOG_MSG("SDL:OPENGL:No support for texturesize of %d, falling back to surface",texsize);
 			goto dosurface;
 		}
 		SDL_GL_SetAttribute( SDL_GL_DOUBLEBUFFER, 1 );
-#if defined (WIN32) && SDL_VERSION_ATLEAST(1, 2, 11)
-		SDL_GL_SetAttribute( SDL_GL_SWAP_CONTROL, 0 );
+#ifdef __ANDROID__
+		/* WARNING: OpenGL ES v2.0 is NOT backwards compatible
+		 * with v1.1! For simplicity we force v1.1 for now,
+		 * although v2.0 is probably the better way.
+		 */
+		SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 1);
+		SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 1);
+#endif
+#if SDL_VERSION_ATLEAST(2,0,0)
+		GFX_SetupWindowScaled(sdl.desktop.want_type);
+		/* We may simply use SDL_BYTESPERPIXEL
+		here rather than SDL_BITSPERPIXEL   */
+		if (!sdl.window || SDL_BYTESPERPIXEL(SDL_GetWindowPixelFormat(sdl.window))<2) {
+			LOG_MSG("SDL:OPENGL:Can't open drawing window, are you running in 16bpp(or higher) mode?");
+			goto dosurface;
+		}
+		sdl.opengl.context = SDL_GL_CreateContext(sdl.window);
+		if (sdl.opengl.context == NULL) {
+			LOG_MSG("SDL:OPENGL:Can't create OpenGL context, falling back to surface");
+			goto dosurface;
+		}
+		/* Sync to VBlank if desired */
+		SDL_GL_SetSwapInterval(sdl.desktop.vsync ? 1 : 0);
+#else	// !SDL_VERSION_ATLEAST(2,0,0)
+#if SDL_VERSION_ATLEAST(1, 2, 11)
+		SDL_GL_SetAttribute( SDL_GL_SWAP_CONTROL, sdl.desktop.vsync ? 1 : 0 );
 #endif
 		GFX_SetupSurfaceScaled(SDL_OPENGL,0);
 		if (!sdl.surface || sdl.surface->format->BitsPerPixel<15) {
 			LOG_MSG("SDL:OPENGL:Can't open drawing surface, are you running in 16bpp(or higher) mode?");
 			goto dosurface;
 		}
+#endif	// !SDL_VERSION_ATLEAST(2,0,0)
 		/* Create the texture and display list */
+#ifndef __ANDROID__
 		if (sdl.opengl.pixel_buffer_object) {
 			glGenBuffersARB(1, &sdl.opengl.buffer);
 			glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT, sdl.opengl.buffer);
 			glBufferDataARB(GL_PIXEL_UNPACK_BUFFER_EXT, width*height*4, NULL, GL_STREAM_DRAW_ARB);
 			glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT, 0);
-		} else {
+		} else
+#endif
+		{
 			sdl.opengl.framebuf=malloc(width*height*4);		//32 bit color
 		}
 		sdl.opengl.pitch=width*4;
-		glViewport(sdl.clip.x,sdl.clip.y,sdl.clip.w,sdl.clip.h);
+#if SDL_VERSION_ATLEAST(2,0,0)
+		int windowHeight;
+		SDL_GetWindowSize(sdl.window, NULL, &windowHeight);
+		glViewport(sdl.clip.x,windowHeight-(sdl.clip.y+sdl.clip.h),sdl.clip.w,sdl.clip.h);
+#else
+		glViewport(sdl.clip.x,sdl.surface->h-(sdl.clip.y+sdl.clip.h),sdl.clip.w,sdl.clip.h);
+#endif
 		glMatrixMode (GL_PROJECTION);
 		glDeleteTextures(1,&sdl.opengl.texture);
  		glGenTextures(1,&sdl.opengl.texture);
 		glBindTexture(GL_TEXTURE_2D,sdl.opengl.texture);
 		// No borders
+#ifdef __ANDROID__
+		/* Plain OpenGL ES (v1.1) has no mention
+		of GL_CLAMP, so use GL_CLAMP_TO_EDGE  */
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+#else
 		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
 		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
+#endif
 		if (sdl.opengl.bilinear) {
 			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
 			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
@@ -710,12 +1148,13 @@
 			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
 		}
 
+#ifdef __ANDROID__	// OpenGL ES
+		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, texsize, texsize, 0, GL_RGBA, GL_UNSIGNED_BYTE, 0);
+#else
 		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, texsize, texsize, 0, GL_BGRA_EXT, GL_UNSIGNED_BYTE, 0);
+#endif
 
 		glClearColor (0.0, 0.0, 0.0, 1.0);
-		glClear(GL_COLOR_BUFFER_BIT);
-		SDL_GL_SwapBuffers();
-		glClear(GL_COLOR_BUFFER_BIT);
 		glShadeModel (GL_FLAT);
 		glDisable (GL_DEPTH_TEST);
 		glDisable (GL_LIGHTING);
@@ -727,9 +1166,18 @@
 		GLfloat tex_width=((GLfloat)(width)/(GLfloat)texsize);
 		GLfloat tex_height=((GLfloat)(height)/(GLfloat)texsize);
 
+#ifdef __ANDROID__
+		/* Display lists are not available with OpenGL ES (1.0, 2.0).
+		Furthermore, we can't use glBegin, glTexCoord2f and glEnd. */
+		sdl.opengl.texCoords[0] = 0; sdl.opengl.texCoords[1] = tex_height; // lower left
+		sdl.opengl.texCoords[2] = tex_width; sdl.opengl.texCoords[3] = tex_height; // lower right
+		sdl.opengl.texCoords[4] = tex_width; sdl.opengl.texCoords[5] = 0; // upper right
+		sdl.opengl.texCoords[6] = 0; sdl.opengl.texCoords[7] = 0; // upper left
+#else
 		if (glIsList(sdl.opengl.displaylist)) glDeleteLists(sdl.opengl.displaylist, 1);
 		sdl.opengl.displaylist = glGenLists(1);
 		glNewList(sdl.opengl.displaylist, GL_COMPILE);
+		glClear(GL_COLOR_BUFFER_BIT);
 		glBindTexture(GL_TEXTURE_2D, sdl.opengl.texture);
 		glBegin(GL_QUADS);
 		// lower left
@@ -742,10 +1190,13 @@
 		glTexCoord2f(0,0); glVertex2f(-1.0f, 1.0f);
 		glEnd();
 		glEndList();
+#endif
 		sdl.desktop.type=SCREEN_OPENGL;
 		retFlags = GFX_CAN_32 | GFX_SCALING;
+#ifndef __ANDROID__
 		if (sdl.opengl.pixel_buffer_object)
 			retFlags |= GFX_HARDWARE;
+#endif
 	break;
 		}//OPENGL
 #endif	//C_OPENGL
@@ -759,13 +1210,22 @@
 	return retFlags;
 }
 
+
 void GFX_CaptureMouse(void) {
 	sdl.mouse.locked=!sdl.mouse.locked;
 	if (sdl.mouse.locked) {
+#if SDL_VERSION_ATLEAST(2,0,0)
+		SDL_SetRelativeMouseMode(SDL_TRUE);
+#else
 		SDL_WM_GrabInput(SDL_GRAB_ON);
+#endif
 		SDL_ShowCursor(SDL_DISABLE);
 	} else {
+#if SDL_VERSION_ATLEAST(2,0,0)
+		SDL_SetRelativeMouseMode(SDL_FALSE);
+#else
 		SDL_WM_GrabInput(SDL_GRAB_OFF);
+#endif
 		if (sdl.mouse.autoenable || !sdl.mouse.autolock) SDL_ShowCursor(SDL_ENABLE);
 	}
         mouselocked=sdl.mouse.locked;
@@ -773,10 +1233,18 @@
 
 void GFX_UpdateSDLCaptureState(void) {
 	if (sdl.mouse.locked) {
+#if SDL_VERSION_ATLEAST(2,0,0)
+		SDL_SetRelativeMouseMode(SDL_TRUE);
+#else
 		SDL_WM_GrabInput(SDL_GRAB_ON);
+#endif
 		SDL_ShowCursor(SDL_DISABLE);
 	} else {
+#if SDL_VERSION_ATLEAST(2,0,0)
+		SDL_SetRelativeMouseMode(SDL_FALSE);
+#else
 		SDL_WM_GrabInput(SDL_GRAB_OFF);
+#endif
 		if (sdl.mouse.autoenable || !sdl.mouse.autolock) SDL_ShowCursor(SDL_ENABLE);
 	}
 	CPU_Reset_AutoAdjust();
@@ -861,18 +1329,27 @@
 
 
 bool GFX_StartUpdate(Bit8u * & pixels,Bitu & pitch) {
+#if SDL_VERSION_ATLEAST(2,0,0)
+	if (!sdl.update_display_contents)
+		return false;
+#endif
 	if (!sdl.active || sdl.updating)
 		return false;
 	switch (sdl.desktop.type) {
 	case SCREEN_SURFACE:
+#if !SDL_VERSION_ATLEAST(2,0,0)
 		if (sdl.blit.surface) {
 			if (SDL_MUSTLOCK(sdl.blit.surface) && SDL_LockSurface(sdl.blit.surface))
 				return false;
 			pixels=(Bit8u *)sdl.blit.surface->pixels;
 			pitch=sdl.blit.surface->pitch;
-		} else {
+		} else
+#endif
+		{
+#if !SDL_VERSION_ATLEAST(2,0,0)
 			if (SDL_MUSTLOCK(sdl.surface) && SDL_LockSurface(sdl.surface))
 				return false;
+#endif
 			pixels=(Bit8u *)sdl.surface->pixels;
 			pixels+=sdl.clip.y*sdl.surface->pitch;
 			pixels+=sdl.clip.x*sdl.surface->format->BytesPerPixel;
@@ -880,6 +1357,19 @@
 		}
 		sdl.updating=true;
 		return true;
+#if SDL_VERSION_ATLEAST(2,0,0)
+	case SCREEN_TEXTURE:
+	{
+		void * texPixels;
+		int texPitch;
+		if (SDL_LockTexture(sdl.texture.texture, NULL, &texPixels, &texPitch) < 0)
+			return false;
+		pixels = (Bit8u *)texPixels;
+		pitch = texPitch;
+		sdl.updating=true;
+		return true;
+	}
+#else	// !SDL_VERSION_ATLEAST(2,0,0)
 #if (HAVE_DDRAW_H) && defined(WIN32)
 	case SCREEN_SURFACE_DDRAW:
 		if (SDL_LockSurface(sdl.blit.surface)) {
@@ -890,20 +1380,25 @@
 		pitch=sdl.blit.surface->pitch;
 		sdl.updating=true;
 		return true;
-#endif
+#endif	// DirectDraw
 	case SCREEN_OVERLAY:
 		if (SDL_LockYUVOverlay(sdl.overlay)) return false;
 		pixels=(Bit8u *)*(sdl.overlay->pixels);
 		pitch=*(sdl.overlay->pitches);
 		sdl.updating=true;
 		return true;
+#endif	// !SDL_VERSION_ATLEAST(2,0,0)
 #if C_OPENGL
 	case SCREEN_OPENGL:
+#ifndef __ANDROID__
 		if(sdl.opengl.pixel_buffer_object) {
 		    glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT, sdl.opengl.buffer);
 		    pixels=(Bit8u *)glMapBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT, GL_WRITE_ONLY);
 		} else
+#endif
+		{
 		    pixels=(Bit8u *)sdl.opengl.framebuf;
+		}
 		pitch=sdl.opengl.pitch;
 		sdl.updating=true;
 		return true;
@@ -919,11 +1414,16 @@
 #if (HAVE_DDRAW_H) && defined(WIN32)
 	int ret;
 #endif
+#if SDL_VERSION_ATLEAST(2,0,0)
+	if (!sdl.update_display_contents)
+		return;
+#endif
 	if (!sdl.updating)
 		return;
 	sdl.updating=false;
 	switch (sdl.desktop.type) {
 	case SCREEN_SURFACE:
+#if !SDL_VERSION_ATLEAST(2,0,0)
 		if (SDL_MUSTLOCK(sdl.surface)) {
 			if (sdl.blit.surface) {
 				SDL_UnlockSurface(sdl.blit.surface);
@@ -933,7 +1433,9 @@
 				SDL_UnlockSurface(sdl.surface);
 			}
 			SDL_Flip(sdl.surface);
-		} else if (changedLines) {
+		} else
+#endif
+		if (changedLines) {
 			Bitu y = 0, index = 0, rectCount = 0;
 			while (y < sdl.draw.height) {
 				if (!(index & 1)) {
@@ -954,9 +1456,31 @@
 				index++;
 			}
 			if (rectCount)
+#if SDL_VERSION_ATLEAST(2,0,0)
+				SDL_UpdateWindowSurfaceRects( sdl.window, sdl.updateRects, rectCount );
+#if 0
+				if (SDL_UpdateWindowSurfaceRects( sdl.window, sdl.updateRects, rectCount ) < 0) {
+					/* Maybe window has been restored
+					 * in a way and this is needed
+					 * for some reason
+					 */
+					sdl.surface = SDL_GetWindowSurface(sdl.window);
+					SDL_UpdateWindowSurface( sdl.window );
+				}
+#endif
+#else
 				SDL_UpdateRects( sdl.surface, rectCount, sdl.updateRects );
+#endif
 		}
 		break;
+#if SDL_VERSION_ATLEAST(2,0,0)
+	case SCREEN_TEXTURE:
+		SDL_UnlockTexture(sdl.texture.texture);
+		SDL_RenderClear(sdl.renderer);
+		SDL_RenderCopy(sdl.renderer, sdl.texture.texture, NULL, &sdl.clip);
+		SDL_RenderPresent(sdl.renderer);
+		break;
+#else	// !SDL_VERSION_ATLEAST(2,0,0)
 #if (HAVE_DDRAW_H) && defined(WIN32)
 	case SCREEN_SURFACE_DDRAW:
 		SDL_UnlockSurface(sdl.blit.surface);
@@ -976,13 +1500,15 @@
 		}
 		SDL_Flip(sdl.surface);
 		break;
-#endif
+#endif	// DirectDraw
 	case SCREEN_OVERLAY:
 		SDL_UnlockYUVOverlay(sdl.overlay);
 		SDL_DisplayYUVOverlay(sdl.overlay,&sdl.clip);
 		break;
+#endif	// !SDL_VERSION_ATLEAST(2,0,0)
 #if C_OPENGL
 	case SCREEN_OPENGL:
+#ifndef __ANDROID__
 		if (sdl.opengl.pixel_buffer_object) {
 			glUnmapBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT);
 			glBindTexture(GL_TEXTURE_2D, sdl.opengl.texture);
@@ -991,8 +1517,14 @@
 					GL_UNSIGNED_INT_8_8_8_8_REV, 0);
 			glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT, 0);
 			glCallList(sdl.opengl.displaylist);
-			SDL_GL_SwapBuffers();
-		} else if (changedLines) {
+#if SDL_VERSION_ATLEAST(2,0,0)
+			SDL_GL_SwapWindow(sdl.window);
+#else
+ 			SDL_GL_SwapBuffers();
+#endif
+		} else
+#endif	// ifndef __ANDROID__
+		if (changedLines) {
 			Bitu y = 0, index = 0;
 			glBindTexture(GL_TEXTURE_2D, sdl.opengl.texture);
 			while (y < sdl.draw.height) {
@@ -1001,15 +1533,43 @@
 				} else {
 					Bit8u *pixels = (Bit8u *)sdl.opengl.framebuf + y * sdl.opengl.pitch;
 					Bitu height = changedLines[index];
+#ifdef __ANDROID__
+					/* Try GL_UNSIGNED_BYTE... */
+					glTexSubImage2D(GL_TEXTURE_2D, 0, 0, y,
+						sdl.draw.width, height, GL_RGBA,
+						GL_UNSIGNED_BYTE, pixels );
+#else
 					glTexSubImage2D(GL_TEXTURE_2D, 0, 0, y,
 						sdl.draw.width, height, GL_BGRA_EXT,
 						GL_UNSIGNED_INT_8_8_8_8_REV, pixels );
+#endif
 					y += height;
 				}
 				index++;
 			}
+#ifdef __ANDROID__
+			/* We can't use display lists with OpenGL ES
+			and we should use Vertex Buffer Arrays    */
+			glClear(GL_COLOR_BUFFER_BIT);
+			glBindTexture(GL_TEXTURE_2D, sdl.opengl.texture);
+
+			glEnableClientState(GL_VERTEX_ARRAY);
+			glEnableClientState(GL_TEXTURE_COORD_ARRAY);
+
+			glVertexPointer(2, GL_FLOAT, 0, sdl.opengl.vertCoords);
+			glTexCoordPointer(2, GL_FLOAT, 0, sdl.opengl.texCoords);
+			glDrawArrays(GL_TRIANGLE_FAN,0,4);
+
+			glDisableClientState(GL_VERTEX_ARRAY);
+			glDisableClientState(GL_TEXTURE_COORD_ARRAY);
+#else	// !__ANDROID__
 			glCallList(sdl.opengl.displaylist);
+#endif	// !__ANDROID__
+#if SDL_VERSION_ATLEAST(2,0,0)
+			SDL_GL_SwapWindow(sdl.window);
+#else
 			SDL_GL_SwapBuffers();
+#endif
 		}
 		break;
 #endif
@@ -1020,6 +1580,8 @@
 
 
 void GFX_SetPalette(Bitu start,Bitu count,GFX_PalEntry * entries) {
+	// Paletted window surfaces are unsupported with SDL 2.0
+#if !SDL_VERSION_ATLEAST(2,0,0)
 	/* I should probably not change the GFX_PalEntry :) */
 	if (sdl.surface->flags & SDL_HWPALETTE) {
 		if (!SDL_SetPalette(sdl.surface,SDL_PHYSPAL,(SDL_Color *)entries,start,count)) {
@@ -1030,13 +1592,20 @@
 			E_Exit("SDL:Can't set palette");
 		}
 	}
+#endif
 }
 
 Bitu GFX_GetRGB(Bit8u red,Bit8u green,Bit8u blue) {
 	switch (sdl.desktop.type) {
 	case SCREEN_SURFACE:
+#if !SDL_VERSION_ATLEAST(2,0,0)
 	case SCREEN_SURFACE_DDRAW:
+#endif
 		return SDL_MapRGB(sdl.surface->format,red,green,blue);
+#if SDL_VERSION_ATLEAST(2,0,0)
+	case SCREEN_TEXTURE:
+		return SDL_MapRGB(sdl.texture.pixelFormat,red,green,blue);
+#else
 	case SCREEN_OVERLAY:
 		{
 			Bit8u y =  ( 9797*(red) + 19237*(green) +  3734*(blue) ) >> 15;
@@ -1048,10 +1617,15 @@
 			return (u << 0) | (y << 8) | (v << 16) | (y << 24);
 #endif
 		}
+#endif	// !SDL_VERSION_ATLEAST(2,0,0)
 	case SCREEN_OPENGL:
-//		return ((red << 0) | (green << 8) | (blue << 16)) | (255 << 24);
-		//USE BGRA
+#ifdef __ANDROID__
+		//Use RGBA on Android with OpenGL ES v1.1
+		return ((red << 0) | (green << 8) | (blue << 16)) | (255 << 24);
+#else
+		//USE BGRA otherwise
 		return ((blue << 0) | (green << 8) | (red << 16)) | (255 << 24);
+#endif
 	}
 	return 0;
 }
@@ -1066,6 +1640,36 @@
 	sdl.active=true;
 }
 
+/* NOTE: The following appears to do its job on Android only *before*
+ * a screen rotation occurs. After that, the old dimensions are retrieved.
+ * For the updated dimensions we should listen to a window resize event.
+ */
+#if SDL_VERSION_ATLEAST(2,0,0)
+void GFX_ObtainDisplayDimensions() {
+	SDL_Rect displayDimensions;
+	SDL_GetDisplayBounds(sdl.displayNumber, &displayDimensions);
+	sdl.desktop.full.width = displayDimensions.w;
+	sdl.desktop.full.height = displayDimensions.h;
+
+}
+
+/* Manually update display dimensions in case of a window resize,
+ * IF there is the need for that ("yes" on Android, "no" otherwise).
+ * Used for the mapper UI on Android.
+ * Reason is the usage of GFX_GetSDLSurfaceSubwindowDims, as well as a
+ * mere notification of the fact that the window's dimensions are modified.
+ */
+void GFX_UpdateDisplayDimensions(int width, int height) {
+	if (sdl.desktop.full.display_res && sdl.desktop.fullscreen) {
+		/* Note: We should not use GFX_ObtainDisplayDimensions
+		(SDL_GetDisplayBounds) on Android after a screen rotation:
+		The older values from application startup are returned. */
+		sdl.desktop.full.width = width;
+		sdl.desktop.full.height = height;
+	}
+}
+#endif
+
 static void GUI_ShutDown(Section * /*sec*/) {
 	GFX_Stop();
 	if (sdl.draw.callback) (sdl.draw.callback)( GFX_CallBackStop );
@@ -1156,13 +1760,21 @@
 	Section_prop * section=static_cast<Section_prop *>(sec);
 	sdl.active=false;
 	sdl.updating=false;
+#if SDL_VERSION_ATLEAST(2,0,0)
+	sdl.update_window=true;
+	sdl.update_display_contents=true;
+#endif
 
 	GFX_SetIcon();
 
 	sdl.desktop.lazy_fullscreen=false;
 	sdl.desktop.lazy_fullscreen_req=false;
 
+#ifdef __ANDROID__
+	sdl.desktop.fullscreen=true;
+#else
 	sdl.desktop.fullscreen=section->Get_bool("fullscreen");
+#endif
 	sdl.wait_on_error=section->Get_bool("waitonerror");
 
 	Prop_multival* p=section->Get_multival("priority");
@@ -1191,10 +1803,18 @@
 	sdl.mouse.locked=false;
 	mouselocked=false; //Global for mapper
 	sdl.mouse.requestlock=false;
+#ifdef __ANDROID__
+	sdl.mouse.isLeftMouseFingerUsed=sdl.mouse.isRightMouseFingerUsed=false;
+	sdl.mouse.isMiddleMouseFingerUsed=sdl.mouse.isEscKeyFingerUsed=false;
+	/* We force fullscreen desktop resolution */
+	sdl.desktop.full.fixed=true;
+#else
 	sdl.desktop.full.fixed=false;
 	const char* fullresolution=section->Get_string("fullresolution");
+#endif
 	sdl.desktop.full.width  = 0;
 	sdl.desktop.full.height = 0;
+#ifndef __ANDROID__
 	if(fullresolution && *fullresolution) {
 		char res[100];
 		strncpy( res, fullresolution, sizeof( res ));
@@ -1211,9 +1831,10 @@
 			}
 		}
 	}
-
+#endif
 	sdl.desktop.window.width  = 0;
 	sdl.desktop.window.height = 0;
+#ifndef __ANDROID__
 	const char* windowresolution=section->Get_string("windowresolution");
 	if(windowresolution && *windowresolution) {
 		char res[100];
@@ -1228,7 +1849,24 @@
 			}
 		}
 	}
-	sdl.desktop.doublebuf=section->Get_bool("fulldouble");
+#endif
+
+	sdl.desktop.vsync=section->Get_bool("vsync");
+
+#if SDL_VERSION_ATLEAST(2,0,0)
+
+	sdl.displayNumber=section->Get_int("display");
+	if ((sdl.displayNumber < 0) || (sdl.displayNumber >= SDL_GetNumVideoDisplays())) {
+		sdl.displayNumber = 0;
+		LOG_MSG("SDL:Display number out of bounds, switching back to 0");
+	}
+	sdl.desktop.full.display_res = sdl.desktop.full.fixed && (!sdl.desktop.full.width || !sdl.desktop.full.height);
+	if (sdl.desktop.full.display_res) {
+		GFX_ObtainDisplayDimensions();
+	}
+
+#else	// !SDL_VERSION_ATLEAST(2,0,0)
+
 #if SDL_VERSION_ATLEAST(1, 2, 10)
 	if (!sdl.desktop.full.width || !sdl.desktop.full.height){
 		//Can only be done on the very first call! Not restartable.
@@ -1255,6 +1893,8 @@
 		sdl.desktop.full.height=768;
 #endif
 	}
+#endif	// !SDL_VERSION_ATLEAST(2,0,0)
+
 	sdl.mouse.autoenable=section->Get_bool("autolock");
 	if (!sdl.mouse.autoenable) SDL_ShowCursor(SDL_DISABLE);
 	sdl.mouse.autolock=false;
@@ -1266,12 +1906,22 @@
 
 	if (output == "surface") {
 		sdl.desktop.want_type=SCREEN_SURFACE;
+#if SDL_VERSION_ATLEAST(2,0,0)
+	} else if (output == "texture") {
+		sdl.desktop.want_type=SCREEN_TEXTURE;
+		SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");
+	} else if (output == "texturenb") {
+		sdl.desktop.want_type=SCREEN_TEXTURE;
+		// Currently the default, but... oh well
+		SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "nearest");
+#else	// !SDL_VERSION_ATLEAST(2,0,0)
 #if (HAVE_DDRAW_H) && defined(WIN32)
 	} else if (output == "ddraw") {
 		sdl.desktop.want_type=SCREEN_SURFACE_DDRAW;
 #endif
 	} else if (output == "overlay") {
 		sdl.desktop.want_type=SCREEN_OVERLAY;
+#endif	// !SDL_VERSION_ATLEAST(2,0,0)
 #if C_OPENGL
 	} else if (output == "opengl") {
 		sdl.desktop.want_type=SCREEN_OPENGL;
@@ -1285,19 +1935,56 @@
 		sdl.desktop.want_type=SCREEN_SURFACE;//SHOULDN'T BE POSSIBLE anymore
 	}
 
+#if SDL_VERSION_ATLEAST(2,0,0)
+	sdl.texture.texture=0;
+	sdl.texture.pixelFormat=0;
+	sdl.window=0;
+	sdl.renderer=0;
+	sdl.rendererDriver = section->Get_string("renderer");
+#else
 	sdl.overlay=0;
+#endif
+
+#if (defined C_OPENGL) && (defined __ANDROID__) // OpenGL ES
+	static const GLfloat vertCoords[] = {
+	-1, -1, //  lower left
+	1, -1, // lower right
+	1, 1, // upper right
+	-1, 1 // upper left
+	};
+	memcpy(sdl.opengl.vertCoords, vertCoords, sizeof(vertCoords));
+#endif
+
 #if C_OPENGL
    if(sdl.desktop.want_type==SCREEN_OPENGL){ /* OPENGL is requested */
+#if SDL_VERSION_ATLEAST(2,0,0)
+	if (!GFX_SetSDLOpenGLWindow(640,400)) {
+		LOG_MSG("Could not create OpenGL window, switching back to surface");
+		sdl.desktop.want_type=SCREEN_SURFACE;
+	} else {
+		sdl.opengl.context = SDL_GL_CreateContext(sdl.window);
+		if (sdl.opengl.context == 0) {
+			LOG_MSG("Could not create OpenGL context, switching back to surface");
+			sdl.desktop.want_type=SCREEN_SURFACE;
+		}
+	}
+	if (sdl.desktop.want_type=SCREEN_OPENGL) {
+#else	// Same story but for SDL 1.2
 	sdl.surface=SDL_SetVideoMode_Wrap(640,400,0,SDL_OPENGL);
 	if (sdl.surface == NULL) {
 		LOG_MSG("Could not initialize OpenGL, switching back to surface");
 		sdl.desktop.want_type=SCREEN_SURFACE;
 	} else {
+#endif	// End of SDL specific video mode check. Let's assume it has passed...
 	sdl.opengl.buffer=0;
 	sdl.opengl.framebuf=0;
 	sdl.opengl.texture=0;
+#ifndef __ANDROID__
 	sdl.opengl.displaylist=0;
+#endif
+
 	glGetIntegerv (GL_MAX_TEXTURE_SIZE, &sdl.opengl.max_texsize);
+#ifndef __ANDROID__
 	glGenBuffersARB = (PFNGLGENBUFFERSARBPROC)SDL_GL_GetProcAddress("glGenBuffersARB");
 	glBindBufferARB = (PFNGLBINDBUFFERARBPROC)SDL_GL_GetProcAddress("glBindBufferARB");
 	glDeleteBuffersARB = (PFNGLDELETEBUFFERSARBPROC)SDL_GL_GetProcAddress("glDeleteBuffersARB");
@@ -1314,19 +2001,37 @@
     	} else {
 		sdl.opengl.packed_pixel=sdl.opengl.paletted_texture=false;
 	}
+#endif	// ifndef __ANDROID__
 	}
 	} /* OPENGL is requested end */
 
 #endif	//OPENGL
 	/* Initialize screen for first time */
+#if SDL_VERSION_ATLEAST(2,0,0)
+	if (!GFX_SetSDLSurfaceWindow(640,400))
+		E_Exit("Could not initialize video: %s",SDL_GetError());
+	sdl.surface = SDL_GetWindowSurface(sdl.window);
+	SDL_Rect splash_rect=GFX_GetSDLSurfaceSubwindowDims(640,400);
+	sdl.desktop.sdl2pixelFormat = SDL_GetWindowPixelFormat(sdl.window);
+	LOG_MSG("SDL:Current window pixel format: %s", SDL_GetPixelFormatName(sdl.desktop.sdl2pixelFormat));
+	/* Do NOT use SDL_BITSPERPIXEL here - It returns 24 for
+	SDL_PIXELFORMAT_RGB888, while SDL_BYTESPERPIXEL returns 4.
+	To compare, with SDL 1.2 the detected desktop color depth is 32 bpp. */
+	sdl.desktop.bpp=8*SDL_BYTESPERPIXEL(sdl.desktop.sdl2pixelFormat);
+#else
 	sdl.surface=SDL_SetVideoMode_Wrap(640,400,0,0);
 	if (sdl.surface == NULL) E_Exit("Could not initialize video: %s",SDL_GetError());
 	sdl.desktop.bpp=sdl.surface->format->BitsPerPixel;
+#endif
 	if (sdl.desktop.bpp==24) {
 		LOG_MSG("SDL:You are running in 24 bpp mode, this will slow down things!");
 	}
 	GFX_Stop();
+#if SDL_VERSION_ATLEAST(2,0,0)
+	SDL_SetWindowTitle(sdl.window,"DOSBox"); // VERSION is gone...
+#else
 	SDL_WM_SetCaption("DOSBox",VERSION);
+#endif
 
 /* The endian part is intentionally disabled as somehow it produces correct results without according to rhoenie*/
 //#if SDL_BYTEORDER == SDL_BIG_ENDIAN
@@ -1342,6 +2047,9 @@
 /* Please leave the Splash screen stuff in working order in DOSBox. We spend a lot of time making DOSBox. */
 	SDL_Surface* splash_surf = SDL_CreateRGBSurface(SDL_SWSURFACE, 640, 400, 32, rmask, gmask, bmask, 0);
 	if (splash_surf) {
+#if SDL_VERSION_ATLEAST(2,0,0)
+		SDL_SetSurfaceBlendMode(splash_surf, SDL_BLENDMODE_BLEND);
+#endif
 		SDL_FillRect(splash_surf, NULL, SDL_MapRGB(splash_surf->format, 0, 0, 0));
 
 		Bit8u* tmpbufp = new Bit8u[640*400*3];
@@ -1377,23 +2085,51 @@
 
 			if (ct<1) {
 				SDL_FillRect(sdl.surface, NULL, SDL_MapRGB(sdl.surface->format, 0, 0, 0));
+#if SDL_VERSION_ATLEAST(2,0,0)
+				SDL_SetSurfaceAlphaMod(splash_surf, 255);
+				SDL_BlitScaled(splash_surf, NULL, sdl.surface, &splash_rect);
+#else
 				SDL_SetAlpha(splash_surf, SDL_SRCALPHA,255);
 				SDL_BlitSurface(splash_surf, NULL, sdl.surface, NULL);
+#endif
+#if SDL_VERSION_ATLEAST(2,0,0)
+				SDL_UpdateWindowSurface(sdl.window);
+#else
 				SDL_Flip(sdl.surface);
+#endif
 			} else if (ct>=max_splash_loop-splash_fade) {
 				if (use_fadeout) {
 					SDL_FillRect(sdl.surface, NULL, SDL_MapRGB(sdl.surface->format, 0, 0, 0));
+#if SDL_VERSION_ATLEAST(2,0,0)
+					SDL_SetSurfaceAlphaMod(splash_surf, (Bit8u)((max_splash_loop-1-ct)*255/(splash_fade-1)));
+					SDL_BlitScaled(splash_surf, NULL, sdl.surface, &splash_rect);
+#else
 					SDL_SetAlpha(splash_surf, SDL_SRCALPHA, (Bit8u)((max_splash_loop-1-ct)*255/(splash_fade-1)));
 					SDL_BlitSurface(splash_surf, NULL, sdl.surface, NULL);
+#endif
+#if SDL_VERSION_ATLEAST(2,0,0)
+					SDL_UpdateWindowSurface(sdl.window);
+#else
 					SDL_Flip(sdl.surface);
+#endif
 				}
+			} else { // Fix a possible glitch
+#if SDL_VERSION_ATLEAST(2,0,0)
+				SDL_UpdateWindowSurface(sdl.window);
+#else
+				SDL_Flip(sdl.surface);
+#endif
 			}
 
 		}
 
 		if (use_fadeout) {
 			SDL_FillRect(sdl.surface, NULL, SDL_MapRGB(sdl.surface->format, 0, 0, 0));
+#if SDL_VERSION_ATLEAST(2,0,0)
+			SDL_UpdateWindowSurface(sdl.window);
+#else
 			SDL_Flip(sdl.surface);
+#endif
 		}
 		SDL_FreeSurface(splash_surf);
 		delete [] tmpbufp;
@@ -1411,7 +2147,11 @@
 	MAPPER_AddHandler(&PauseDOSBox, MK_pause, MMOD2, "pause", "Pause");
 #endif
 	/* Get Keyboard state of numlock and capslock */
+#if SDL_VERSION_ATLEAST(2,0,0)
+	SDL_Keymod keystate = SDL_GetModState();
+#else
 	SDLMod keystate = SDL_GetModState();
+#endif
 	if(keystate&KMOD_NUM) startup_state_numlock = true;
 	if(keystate&KMOD_CAPS) startup_state_capslock = true;
 }
@@ -1425,6 +2165,83 @@
 	}
 }
 
+#if defined(__ANDROID__)
+/* The way mouse emulation is done here is based on the
+following (horizontal) partitioning of the touchscreen:
+
+/-----------------------------------------------------------------------\
+|    Left   | (H)Escape |   Motion  |  Motion   |   Middle  |   Right   |
+\-----------------------------------------------------------------------/
+
+Note that the simulated Escape key is the host one
+(not the emulator's), so it can be re-mapped.
+Furthermore, that should be considered a hack for now. */
+static void HandleTouchFinger(SDL_TouchFingerEvent * tfinger) {
+	void MAPPER_CheckEvent(SDL_Event * event);
+	switch (tfinger->type) {
+		case SDL_FINGERDOWN:
+			if (tfinger->x >= 0.83f) { // Right button
+				sdl.mouse.rightMouseFingerID = tfinger->fingerId;
+				if (!sdl.mouse.isRightMouseFingerUsed) {
+					Mouse_ButtonPressed(1);
+					sdl.mouse.isRightMouseFingerUsed = true;
+				}
+			} else if (tfinger->x >= 0.67f) { // Middle button
+				sdl.mouse.middleMouseFingerID = tfinger->fingerId;
+				if (!sdl.mouse.isMiddleMouseFingerUsed) {
+					Mouse_ButtonPressed(2);
+					sdl.mouse.isMiddleMouseFingerUsed = true;
+				}
+			} else if (tfinger->x >= 0.33f) { // Motion
+				sdl.mouse.mouseMotionFingerID = tfinger->fingerId;
+			} else if (tfinger->x >= 0.17f) { // (Host) Escape key
+				sdl.mouse.escKeyFingerID = tfinger->fingerId;
+				if (!sdl.mouse.isEscKeyFingerUsed) {
+					SDL_Event event;
+					event.type = SDL_KEYDOWN;
+					event.key.keysym.scancode = SDL_SCANCODE_ESCAPE;
+					MAPPER_CheckEvent(&event);
+					sdl.mouse.isEscKeyFingerUsed = true;
+				}
+			} else { // Left button
+				sdl.mouse.leftMouseFingerID = tfinger->fingerId;
+				if (!sdl.mouse.isLeftMouseFingerUsed) {
+					Mouse_ButtonPressed(0);
+					sdl.mouse.isLeftMouseFingerUsed = true;
+				}
+			}
+			break;
+		case SDL_FINGERUP:
+			if ((sdl.mouse.leftMouseFingerID == tfinger->fingerId) && sdl.mouse.isLeftMouseFingerUsed) {
+				Mouse_ButtonReleased(0);
+				sdl.mouse.isLeftMouseFingerUsed = false;
+			} else if ((sdl.mouse.rightMouseFingerID == tfinger->fingerId) && sdl.mouse.isRightMouseFingerUsed) {
+				Mouse_ButtonReleased(1);
+				sdl.mouse.isRightMouseFingerUsed = false;
+			} else if ((sdl.mouse.middleMouseFingerID == tfinger->fingerId) && sdl.mouse.isMiddleMouseFingerUsed) {
+				Mouse_ButtonReleased(2);
+				sdl.mouse.isMiddleMouseFingerUsed = false;
+			} else if ((sdl.mouse.escKeyFingerID == tfinger->fingerId) && sdl.mouse.isEscKeyFingerUsed) {
+				SDL_Event event;
+				event.type = SDL_KEYUP;
+				event.key.keysym.scancode = SDL_SCANCODE_ESCAPE;
+				MAPPER_CheckEvent(&event);
+				sdl.mouse.isEscKeyFingerUsed = false;
+			}
+			break;
+		case SDL_FINGERMOTION:
+			/* We basically IGNORE the absolute coordinates, since
+			we emulate relative mouse movement all the time.    */
+			if (sdl.mouse.mouseMotionFingerID == tfinger->fingerId) {
+				Mouse_CursorMoved((float)tfinger->dx*sdl.clip.w*sdl.mouse.sensitivity/100.0f,
+				                  (float)tfinger->dy*sdl.clip.h*sdl.mouse.sensitivity/100.0f,
+				                  0, 0, true);
+			}
+			break;
+	}
+}
+
+#else	// Not on Android
 static void HandleMouseMotion(SDL_MouseMotionEvent * motion) {
 	if (sdl.mouse.locked || !sdl.mouse.autoenable)
 		Mouse_CursorMoved((float)motion->xrel*sdl.mouse.sensitivity/100.0f,
@@ -1473,6 +2290,7 @@
 		break;
 	}
 }
+#endif	// End of touch/mouse differentiation
 
 void GFX_LosingFocus(void) {
 	sdl.laltstate=SDL_KEYUP;
@@ -1484,6 +2302,34 @@
 	return sdl.desktop.fullscreen;
 }
 
+#if SDL_VERSION_ATLEAST(2,0,0)
+void GFX_HandleVideoResize(int width, int height) {
+	/* Maybe a screen rotation has just occurred, so we simply resize.
+	There may be a different cause for a forced resized, though.    */
+	if (sdl.desktop.full.display_res && sdl.desktop.fullscreen) {
+		/* Note: We should not use GFX_ObtainDisplayDimensions
+		(SDL_GetDisplayBounds) on Android after a screen rotation:
+		The older values from application startup are returned. */
+		sdl.desktop.full.width = width;
+		sdl.desktop.full.height = height;
+	}
+	/* Even if the new window's dimensions are actually the desired ones
+	 * we may still need to re-obtain a new window surface or do
+	 * a different thing. So we basically call GFX_SetSize, but without
+	 * touching the window itself (or else we may end in an infinite loop).
+	 *
+	 * Furthermore, if the new dimensions are *not* the desired ones, we
+	 * don't fight it. Rather than attempting to resize it back, we simply
+	 * keep the window as-is and disable screen updates. This is done
+	 * in SDL_SetSDLWindowSurface by setting sdl.update_display_contents
+	 * to false.
+	 */
+	sdl.update_window = false;
+	GFX_ResetScreen();
+	sdl.update_window = true;
+}
+#endif
+
 void GFX_Events() {
 	SDL_Event event;
 #if defined (REDUCE_JOYSTICK_POLLING)
@@ -1497,6 +2343,98 @@
 #endif
 	while (SDL_PollEvent(&event)) {
 		switch (event.type) {
+#if SDL_VERSION_ATLEAST(2,0,0)
+		case SDL_WINDOWEVENT:
+			switch (event.window.event) {
+				case SDL_WINDOWEVENT_RESTORED:
+					/* We may need to re-create a texture
+					 * and more on Android. Another case:
+					 * Update surface while using X11.
+					 */
+					GFX_ResetScreen();
+					continue;
+				case SDL_WINDOWEVENT_RESIZED:
+					GFX_HandleVideoResize(event.window.data1, event.window.data2);
+					continue;
+				case SDL_WINDOWEVENT_EXPOSED:
+					if (sdl.draw.callback) sdl.draw.callback( GFX_CallBackRedraw );
+					continue;
+				case SDL_WINDOWEVENT_FOCUS_GAINED:
+					if (sdl.desktop.fullscreen && !sdl.mouse.locked)
+						GFX_CaptureMouse();
+					SetPriority(sdl.priority.focus);
+					CPU_Disable_SkipAutoAdjust();
+					break;
+				case SDL_WINDOWEVENT_FOCUS_LOST:
+					if (sdl.mouse.locked) {
+#ifdef WIN32
+						if (sdl.desktop.fullscreen) {
+							VGA_KillDrawing();
+							GFX_ForceFullscreenExit();
+						}
+#endif
+						GFX_CaptureMouse();
+					}
+					SetPriority(sdl.priority.nofocus);
+					GFX_LosingFocus();
+					CPU_Enable_SkipAutoAdjust();
+					break;
+				default: ;
+			}
+
+			/* Non-focus priority is set to pause; check to see if we've lost window or input focus
+			 * i.e. has the window been minimised or made inactive?
+			 */
+			if (sdl.priority.nofocus == PRIORITY_LEVEL_PAUSE) {
+				if ((event.window.event == SDL_WINDOWEVENT_FOCUS_LOST) || (event.window.event == SDL_WINDOWEVENT_MINIMIZED)) {
+					/* Window has lost focus, pause the emulator.
+					 * This is similar to what PauseDOSBox() does, but the exit criteria is different.
+					 * Instead of waiting for the user to hit Alt-Break, we wait for the window to
+					 * regain window or input focus.
+					 */
+					bool paused = true;
+					SDL_Event ev;
+
+					GFX_SetTitle(-1,-1,true);
+					KEYBOARD_ClrBuffer();
+//					SDL_Delay(500);
+//					while (SDL_PollEvent(&ev)) {
+						// flush event queue.
+//					}
+
+					while (paused) {
+						// WaitEvent waits for an event rather than polling, so CPU usage drops to zero
+						SDL_WaitEvent(&ev);
+
+						switch (ev.type) {
+						case SDL_QUIT: throw(0); break; // a bit redundant at linux at least as the active events gets before the quit event.
+						case SDL_WINDOWEVENT:     // wait until we get window focus back
+							if ((ev.window.event == SDL_WINDOWEVENT_FOCUS_LOST) || (ev.window.event == SDL_WINDOWEVENT_MINIMIZED) || (ev.window.event == SDL_WINDOWEVENT_FOCUS_GAINED) || (ev.window.event == SDL_WINDOWEVENT_RESTORED) || (ev.window.event == SDL_WINDOWEVENT_EXPOSED)) {
+								// We've got focus back, so unpause and break out of the loop
+								if ((ev.window.event == SDL_WINDOWEVENT_FOCUS_GAINED) || (ev.window.event == SDL_WINDOWEVENT_RESTORED) || (ev.window.event == SDL_WINDOWEVENT_EXPOSED)) {
+									paused = false;
+									GFX_SetTitle(-1,-1,false);
+								}
+
+								/* Now poke a "release ALT" command into the keyboard buffer
+								 * we have to do this, otherwise ALT will 'stick' and cause
+								 * problems with the app running in the DOSBox.
+								 */
+								KEYBOARD_AddKey(KBD_leftalt, false);
+								KEYBOARD_AddKey(KBD_rightalt, false);
+								if (ev.window.event == SDL_WINDOWEVENT_RESTORED) {
+									// We may need to re-create a texture and more
+									GFX_ResetScreen();
+								}
+							}
+							break;
+						}
+					}
+				}
+			}
+			break;
+#endif	// SDL_VERSION_ATLEAST(2,0,0)
+#if !SDL_VERSION_ATLEAST(2,0,0)
 		case SDL_ACTIVEEVENT:
 			if (event.active.state & SDL_APPINPUTFOCUS) {
 				if (event.active.gain) {
@@ -1567,6 +2505,14 @@
 				}
 			}
 			break;
+#endif	// !SDL_VERSION_ATLEAST(2,0,0)
+#if defined(__ANDROID__)
+		case SDL_FINGERDOWN:
+		case SDL_FINGERUP:
+		case SDL_FINGERMOTION:
+			HandleTouchFinger(&event.tfinger);
+			break;
+#else
 		case SDL_MOUSEMOTION:
 			HandleMouseMotion(&event.motion);
 			break;
@@ -1574,15 +2520,20 @@
 		case SDL_MOUSEBUTTONUP:
 			HandleMouseButton(&event.button);
 			break;
+#endif
+#if !SDL_VERSION_ATLEAST(2,0,0)
 		case SDL_VIDEORESIZE:
-//			HandleVideoResize(&event.resize);
+			//GFX_HandleVideoResize(event.resize.w, event.resize.h);
 			break;
+#endif
 		case SDL_QUIT:
 			throw(0);
 			break;
+#if !SDL_VERSION_ATLEAST(2,0,0)
 		case SDL_VIDEOEXPOSE:
 			if (sdl.draw.callback) sdl.draw.callback( GFX_CallBackRedraw );
 			break;
+#endif
 #ifdef WIN32
 		case SDL_KEYDOWN:
 		case SDL_KEYUP:
@@ -1635,7 +2586,11 @@
 	vsprintf(buf,format,msg);
         strcat(buf,"\n");
 	va_end(msg);
+#ifdef __ANDROID__
+	__android_log_print(ANDROID_LOG_DEBUG, "DOSBox", buf);
+#else
 	if(!no_stdout) printf("%s",buf); //Else buf is parsed again.
+#endif
 }
 
 
@@ -1647,13 +2602,17 @@
 	Prop_int* Pint;
 	Prop_multival* Pmulti;
 
+#ifndef __ANDROID__
 	Pbool = sdl_sec->Add_bool("fullscreen",Property::Changeable::Always,false);
 	Pbool->Set_help("Start dosbox directly in fullscreen. (Press ALT-Enter to go back)");
+#endif
      
-	Pbool = sdl_sec->Add_bool("fulldouble",Property::Changeable::Always,false);
-	Pbool->Set_help("Use double buffering in fullscreen. It can reduce screen flickering, but it can also result in a slow DOSBox.");
+	Pbool = sdl_sec->Add_bool("vsync",Property::Changeable::Always,false);
+	Pbool->Set_help("Sync to Vblank IF supported by the output device and renderer (if relevant).\n"
+	                "It can reduce screen flickering, but it can also result in a slow DOSBox.");
 
-	Pstring = sdl_sec->Add_string("fullresolution",Property::Changeable::Always,"original");
+#ifndef __ANDROID__
+	Pstring = sdl_sec->Add_string("fullresolution",Property::Changeable::Always,"0x0");
 	Pstring->Set_help("What resolution to use for fullscreen: original, desktop or a fixed size (e.g. 1024x768).\n"
 	                  "  Using your monitor's native resolution with aspect=true might give the best results.\n"
 			  "  If you end up with small window on a large screen, try an output different from surface.");
@@ -1661,20 +2620,50 @@
 	Pstring = sdl_sec->Add_string("windowresolution",Property::Changeable::Always,"original");
 	Pstring->Set_help("Scale the window to this size IF the output device supports hardware scaling.\n"
 	                  "  (output=surface does not!)");
+#endif
 
 	const char* outputs[] = {
-		"surface", "overlay",
-#if C_OPENGL
-		"opengl", "openglnb",
-#endif
+		"surface",
+#if SDL_VERSION_ATLEAST(2, 0, 0)
+		"texture",
+		"texturenb",
+#else	// !SDL_VERSION_ATLEAST(2, 0, 0)
+		"overlay",
 #if (HAVE_DDRAW_H) && defined(WIN32)
 		"ddraw",
 #endif
+#endif	// !SDL_VERSION_ATLEAST(2, 0, 0)
+#if C_OPENGL
+		"opengl", "openglnb",
+#endif
 		0 };
+#if SDL_VERSION_ATLEAST(2, 0, 0)
+	Pstring = sdl_sec->Add_string("output",Property::Changeable::Always,"texture");
+#else
 	Pstring = sdl_sec->Add_string("output",Property::Changeable::Always,"surface");
+#endif
 	Pstring->Set_help("What video system to use for output.");
 	Pstring->Set_values(outputs);
 
+#if SDL_VERSION_ATLEAST(2,0,0)
+	const char* renderers[] = {
+		"auto",
+#ifdef WIN32
+		"direct3d",
+#endif
+#ifdef __ANDROID__
+		"opengles2",
+		"opengles",
+#else	// On any platform other than Android
+		"opengl",
+#endif
+		"software",
+		0 };
+	Pstring = sdl_sec->Add_string("renderer",Property::Changeable::Always,"auto");
+	Pstring->Set_help("Choose a renderer driver if output=texture or output=texturenb. Use output=auto for an automatic choice.");
+	Pstring->Set_values(renderers);
+#endif	// SDL_VERSION_ATLEAST(2,0,0)
+
 	Pbool = sdl_sec->Add_bool("autolock",Property::Changeable::Always,true);
 	Pbool->Set_help("Mouse will automatically lock, if you click on the screen. (Press CTRL-F10 to unlock)");
 
@@ -1701,8 +2690,10 @@
 	Pstring = sdl_sec->Add_path("mapperfile",Property::Changeable::Always,MAPPERFILE);
 	Pstring->Set_help("File used to load/save the key/event mappings from. Resetmapper only works with the default value.");
 
+#if !SDL_VERSION_ATLEAST(2,0,0)
 	Pbool = sdl_sec->Add_bool("usescancodes",Property::Changeable::Always,true);
 	Pbool->Set_help("Avoid usage of symkeys, might not work on all operating systems.");
+#endif
 }
 
 static void show_warning(char const * const message) {
@@ -1714,8 +2705,15 @@
 #endif
 	printf("%s",message);
 	if(textonly) return;
+#if SDL_VERSION_ATLEAST(2, 0, 0)
+	if (!sdl.window)
+		if (!GFX_SetSDLSurfaceWindow(640,400)) return;
+	sdl.surface = SDL_GetWindowSurface(sdl.window);
+#else
 	if(!sdl.surface) sdl.surface = SDL_SetVideoMode_Wrap(640,400,0,0);
+#endif
 	if(!sdl.surface) return;
+
 #if SDL_BYTEORDER == SDL_BIG_ENDIAN
 	Bit32u rmask = 0xff000000;
 	Bit32u gmask = 0x00ff0000;
@@ -1743,7 +2741,11 @@
 	}
    
 	SDL_BlitSurface(splash_surf, NULL, sdl.surface, NULL);
+#if SDL_VERSION_ATLEAST(2, 0, 0)
+	SDL_UpdateWindowSurface(sdl.window);
+#else
 	SDL_Flip(sdl.surface);
+#endif
 	SDL_Delay(12000);
 }
    
@@ -1955,12 +2957,20 @@
 	 */
 	putenv(const_cast<char*>("SDL_DISABLE_LOCK_KEYS=1"));
 #endif
-	if ( SDL_Init( SDL_INIT_AUDIO|SDL_INIT_VIDEO|SDL_INIT_TIMER|SDL_INIT_CDROM
+	if ( SDL_Init( SDL_INIT_AUDIO|SDL_INIT_VIDEO|SDL_INIT_TIMER
+#if !SDL_VERSION_ATLEAST(2,0,0)
+		|SDL_INIT_CDROM
+#endif
 		|SDL_INIT_NOPARACHUTE
 		) < 0 ) E_Exit("Can't init SDL %s",SDL_GetError());
 	sdl.inited = true;
 
 #ifndef DISABLE_JOYSTICK
+#ifdef __ANDROID__
+	// Disable accelerometer-as-joystick emulation
+	// (available for backwards compatibility)
+	SDL_SetHint(SDL_HINT_ACCELEROMETER_AS_JOYSTICK, "0");
+#endif
 	//Initialise Joystick separately. This way we can warn when it fails instead
 	//of exiting the application
 	if( SDL_InitSubSystem(SDL_INIT_JOYSTICK) < 0 ) LOG_MSG("Failed to init joystick support");
@@ -1969,6 +2979,7 @@
 	sdl.laltstate = SDL_KEYUP;
 	sdl.raltstate = SDL_KEYUP;
 
+#if !SDL_VERSION_ATLEAST(2, 0, 0) // Not relevant for SDL 2.0 at the moment
 #if defined (WIN32)
 #if SDL_VERSION_ATLEAST(1, 2, 10)
 		sdl.using_windib=true;
@@ -1997,7 +3008,8 @@
 		if (SDL_VideoDriverName(sdl_drv_name,128)!=NULL) {
 			if (strcmp(sdl_drv_name,"windib")==0) LOG_MSG("SDL_Init: Starting up with SDL windib video driver.\n          Try to update your video card and directx drivers!");
 		}
-#endif
+#endif	// WIN32
+#endif	// !SDL_VERSION_ATLEAST(2, 0, 0)
 	sdl.num_joysticks=SDL_NumJoysticks();
 
 	/* Parse configuration files */
@@ -2108,10 +3120,17 @@
 	sticky_keys(true); //Might not be needed if the shutdown function switches to windowed mode, but it doesn't hurt
 #endif 
 	//Force visible mouse to end user. Somehow this sometimes doesn't happen
+#if SDL_VERSION_ATLEAST(2,0,0)
+	SDL_SetRelativeMouseMode(SDL_FALSE);
+#else
 	SDL_WM_GrabInput(SDL_GRAB_OFF);
+#endif
 	SDL_ShowCursor(SDL_ENABLE);
 
 	SDL_Quit();//Let's hope sdl will quit as well when it catches an exception
+#ifdef __ANDROID__
+	exit(0); // Actually quits application... and hopefully(?) removes static values
+#endif
 	return 0;
 }
 
Index: src/hardware/mixer.cpp
===================================================================
--- src/hardware/mixer.cpp	(revision 3869)
+++ src/hardware/mixer.cpp	(working copy)
@@ -412,6 +412,9 @@
 }
 
 static void SDLCALL MIXER_CallBack(void * userdata, Uint8 *stream, int len) {
+#if SDL_VERSION_ATLEAST(2,0,0)
+	memset(stream, 0, len);
+#endif
 	Bitu need=(Bitu)len/MIXER_SSIZE;
 	Bit16s * output=(Bit16s *)stream;
 	Bitu reduce;
Index: src/misc/cross.cpp
===================================================================
--- src/misc/cross.cpp	(revision 3869)
+++ src/misc/cross.cpp	(working copy)
@@ -30,6 +30,10 @@
 #include <shlobj.h>
 #endif
 
+#if defined(__ANDROID__)
+#include "SDL_system.h" // For SDL_AndroidGetExternalStoragePath
+#endif
+
 #if defined HAVE_SYS_TYPES_H && defined HAVE_PWD_H
 #include <sys/types.h>
 #include <pwd.h>
@@ -61,6 +65,10 @@
 #elif defined(MACOSX)
 	in = "~/Library/Preferences";
 	ResolveHomedir(in);
+#elif defined(__ANDROID__)
+	in = SDL_AndroidGetExternalStoragePath();
+	//Assume external storage (possibly internal) is available
+	ResolveHomedir(in);
 #else
 	in = "~/.dosbox";
 	ResolveHomedir(in);
@@ -88,6 +96,11 @@
 	in = "~/Library/Preferences/";
 	ResolveHomedir(in);
 	//Don't create it. Assume it exists
+#elif defined(__ANDROID__)
+	in = SDL_AndroidGetExternalStoragePath();
+	//Assume external storage (possibly internal) is available
+	ResolveHomedir(in);
+	mkdir(in.c_str(),0770);
 #else
 	in = "~/.dosbox";
 	ResolveHomedir(in);
