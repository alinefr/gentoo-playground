diff --git a/Source/WebCore/GNUmakefile.am b/Source/WebCore/GNUmakefile.am
index 3d94fe5..2c664a6 100644
--- a/Source/WebCore/GNUmakefile.am
+++ b/Source/WebCore/GNUmakefile.am
@@ -1,5 +1,13 @@
 include $(srcdir)/Source/WebCore/GNUmakefile.list.am
 
+#if TARGET_WAYLAND
+Source/WebCore/platform/gtk/WaylandWebkitGtk%:
+	$(AM_V_GEN)
+	$(AM_V_at)wayland-scanner server-header < $(WebCore)/platform/gtk/wl-wkgtk.xml > $(WebCore)/platform/gtk/WaylandWebkitGtkServerProtocol.h
+	$(AM_V_at)wayland-scanner client-header < $(WebCore)/platform/gtk/wl-wkgtk.xml > $(WebCore)/platform/gtk/WaylandWebkitGtkClientProtocol.h
+	$(AM_V_at)wayland-scanner code < $(WebCore)/platform/gtk/wl-wkgtk.xml > $(WebCore)/platform/gtk/WaylandWebkitGtkProtocol.c
+#endif
+
 WEBCORE_CSS_PROPERTY_NAMES := $(WebCore)/css/CSSPropertyNames.in
 WEBCORE_CSS_VALUE_KEYWORDS := $(WebCore)/css/CSSValueKeywords.in
 
diff --git a/Source/WebCore/GNUmakefile.list.am b/Source/WebCore/GNUmakefile.list.am
index 02db0dd..b897a95 100644
--- a/Source/WebCore/GNUmakefile.list.am
+++ b/Source/WebCore/GNUmakefile.list.am
@@ -6295,7 +6295,10 @@ platformgtk_sources += \
 	Source/WebCore/platform/gtk/WaylandDisplay.cpp \
 	Source/WebCore/platform/gtk/WaylandDisplay.h \
 	Source/WebCore/platform/gtk/WaylandSurface.cpp \
-	Source/WebCore/platform/gtk/WaylandSurface.h
+	Source/WebCore/platform/gtk/WaylandSurface.h \
+	Source/WebCore/platform/gtk/WaylandWebkitGtkServerProtocol.h \
+	Source/WebCore/platform/gtk/WaylandWebkitGtkClientProtocol.h \
+	Source/WebCore/platform/gtk/WaylandWebkitGtkProtocol.c
 endif # END USE_OPENGL
 if USE_EGL
 webcoregtk_sources += \
diff --git a/Source/WebCore/platform/gtk/WaylandCompositor.cpp b/Source/WebCore/platform/gtk/WaylandCompositor.cpp
index 3e8bf2f..6607568 100644
--- a/Source/WebCore/platform/gtk/WaylandCompositor.cpp
+++ b/Source/WebCore/platform/gtk/WaylandCompositor.cpp
@@ -31,6 +31,8 @@
 
 #include "WaylandDisplayEventSource.h"
 
+#include "WaylandWebkitGtkServerProtocol.h"
+
 #include <gdk/gdkwayland.h>
 
 namespace WebCore {
@@ -65,6 +67,67 @@ static const EGLenum gGLAPI = EGL_OPENGL_ES_API;
 static const EGLenum gGLAPI = EGL_OPENGL_API;
 #endif
 
+void WaylandCompositor::nestedBufferReferenceHandleDestroy(struct wl_listener* listener, void* data)
+{
+    struct NestedBufferReference* ref = 0;
+    ref = wl_container_of(listener, ref, destroyListener);
+    ref->buffer = 0;
+}
+
+void WaylandCompositor::nestedBufferReference(struct NestedBufferReference* ref, struct NestedBuffer* buffer)
+{
+    if (buffer == ref->buffer)
+        return;
+
+    if (ref->buffer) {
+        ref->buffer->busyCount--;
+        if (ref->buffer->busyCount == 0)
+            wl_resource_queue_event(ref->buffer->resource, WL_BUFFER_RELEASE);
+        wl_list_remove(&ref->destroyListener.link);
+    }
+
+    if (buffer) {
+        buffer->busyCount++;
+        wl_signal_add(&buffer->destroySignal, &ref->destroyListener);
+        ref->destroyListener.notify = nestedBufferReferenceHandleDestroy;
+    }
+
+    ref->buffer = buffer;
+}
+
+void WaylandCompositor::surfaceHandlePendingBufferDestroy(struct wl_listener* listener, void* data)
+{
+    struct NestedSurface* surface = 0;
+    surface = wl_container_of(listener, surface, bufferDestroyListener);
+    surface->buffer = 0;
+}
+
+void WaylandCompositor::nestedBufferDestroyHandler(struct wl_listener* listener, void* data)
+{
+    struct NestedBuffer* buffer = 0;
+    buffer = wl_container_of(listener, buffer, destroyListener);
+    wl_signal_emit(&buffer->destroySignal, buffer);
+    g_free(buffer);
+}
+
+struct NestedBuffer* WaylandCompositor::nestedBufferFromResource(struct wl_resource* resource)
+{
+    struct NestedBuffer* buffer;
+    struct wl_listener* listener;
+
+    listener = wl_resource_get_destroy_listener(resource, nestedBufferDestroyHandler);
+    if (listener)
+        return wl_container_of(listener, (struct NestedBuffer*)0, destroyListener);
+
+    buffer = g_new0(struct NestedBuffer, 1);
+    buffer->resource = resource;
+    wl_signal_init(&buffer->destroySignal);
+    buffer->destroyListener.notify = nestedBufferDestroyHandler;
+    wl_resource_add_destroy_listener(resource, &buffer->destroyListener);
+
+    return buffer;
+}
+
 bool WaylandCompositor::supportsRequiredExtensions(EGLDisplay eglDisplay)
 {
     // Make sure we have the required Wayland EGL extension
@@ -194,11 +257,12 @@ struct NestedDisplay* WaylandCompositor::createNestedDisplay()
 void WaylandCompositor::destroyNestedDisplay(struct NestedDisplay* display)
 {
     if (display->childDisplay) {
-        if (display->eventSource) {
+        if (display->eventSource)
             g_source_remove(g_source_get_id(display->eventSource));
-        }
         if (display->wlGlobal)
             wl_global_destroy(display->wlGlobal);
+        if (display->wkgtkGlobal)
+            wl_global_destroy(display->wkgtkGlobal);
         wl_display_destroy(display->childDisplay);
     }
     shutdownEGL(display);
@@ -219,12 +283,7 @@ void WaylandCompositor::surfaceDestroy(struct wl_client* client, struct wl_resou
 
 void WaylandCompositor::surfaceAttach(struct wl_client* client, struct wl_resource* resource, struct wl_resource* bufferResource, int32_t sx, int32_t sy)
 {
-    if (!bufferResource)
-        return;
-
     struct NestedSurface* surface = static_cast<struct NestedSurface*>(wl_resource_get_user_data(resource));
-    if (!surface)
-        return;
 
     EGLint format;
     WaylandCompositor* compositor = surface->compositor;
@@ -233,8 +292,17 @@ void WaylandCompositor::surfaceAttach(struct wl_client* client, struct wl_resour
     if (format != EGL_TEXTURE_RGB && format != EGL_TEXTURE_RGBA)
         return;
 
-    // We release buffer resources when processing pending frame callbacks (before the client can attach a new buffer)
-    surface->bufferResource = bufferResource;
+    // Remove references to any previous pending buffer for this surface
+    if (surface->buffer) {
+        surface->buffer = 0;
+        wl_list_remove(&surface->bufferDestroyListener.link);
+    }
+
+    // Make the new buffer the current pending buffer
+    if (bufferResource) {
+        surface->buffer = nestedBufferFromResource(bufferResource);
+        wl_signal_add(&surface->buffer->destroySignal, &surface->bufferDestroyListener);
+    }
 }
 
 void WaylandCompositor::surfaceDamage(struct wl_client* client, struct wl_resource* resource, int32_t x, int32_t y, int32_t w, int32_t h)
@@ -248,8 +316,6 @@ void WaylandCompositor::surfaceFrame(struct wl_client* client, struct wl_resourc
     if (!surface)
         return;
 
-    // Queue frame callback until we are done with the current frame and are ready to process the next one
-    // (see nextFrame)
     struct NestedFrameCallback* callback = g_new0(struct NestedFrameCallback, 1);
     callback->resource = wl_resource_create(client, &wl_callback_interface, 1, id);
     wl_resource_set_implementation(callback->resource, 0, callback, destroyNestedFrameCallback);
@@ -268,7 +334,7 @@ void WaylandCompositor::surfaceSetInputRegion(struct wl_client* client, struct w
 
 void WaylandCompositor::surfaceCommit(struct wl_client* client, struct wl_resource* resource)
 {
-    struct NestedSurface*surface = static_cast<struct NestedSurface*>(wl_resource_get_user_data(resource));
+    struct NestedSurface* surface = static_cast<struct NestedSurface*>(wl_resource_get_user_data(resource));
     if (!surface)
         return;
 
@@ -284,9 +350,12 @@ void WaylandCompositor::surfaceCommit(struct wl_client* client, struct wl_resour
         surface->cairoSurface = 0;
     }
 
+    // Make the pending buffer current 
+    nestedBufferReference(&surface->bufferRef, surface->buffer);
+
     // Create a new EGLImage from the last buffer attached to this surface
     EGLDisplay eglDisplay = compositor->m_display->eglDisplay;
-    surface->image = static_cast<EGLImageKHR*>(eglCreateImage(eglDisplay, EGL_NO_CONTEXT, EGL_WAYLAND_BUFFER_WL, surface->bufferResource, 0));
+    surface->image = static_cast<EGLImageKHR*>(eglCreateImage(eglDisplay, EGL_NO_CONTEXT, EGL_WAYLAND_BUFFER_WL, surface->buffer->resource, 0));
     if (surface->image == EGL_NO_IMAGE_KHR)
         return;
 
@@ -296,15 +365,30 @@ void WaylandCompositor::surfaceCommit(struct wl_client* client, struct wl_resour
 
     // Create a new cairo surface associated with the surface texture
     int width, height;
-    eglQueryBuffer(eglDisplay, surface->bufferResource, EGL_WIDTH, &width);
-    eglQueryBuffer(eglDisplay, surface->bufferResource, EGL_HEIGHT, &height);
+    eglQueryBuffer(eglDisplay, surface->buffer->resource, EGL_WIDTH, &width);
+    eglQueryBuffer(eglDisplay, surface->buffer->resource, EGL_HEIGHT, &height);
     cairo_device_t* device = compositor->m_display->eglDevice;
     surface->cairoSurface = cairo_gl_surface_create_for_texture(device, CAIRO_CONTENT_COLOR_ALPHA, surface->texture, width, height);
     cairo_surface_mark_dirty (surface->cairoSurface); // FIXME: Why do we need this?
 
+    // We are done with this buffer
+    if (surface->buffer) {
+        wl_list_remove(&surface->bufferDestroyListener.link);
+        surface->buffer = 0;
+    }
+
     // Redraw the widget backed by this surface
-    if (compositor->m_widget)
-        gtk_widget_queue_draw(compositor->m_widget);
+    if (surface->widget)
+        gtk_widget_queue_draw(surface->widget);
+
+    // Process frame callbacks for this surface so the client can render a new frame
+    struct NestedFrameCallback *nc, *next;
+    wl_list_for_each_safe(nc, next, &surface->frameCallbackList, link) {
+        wl_callback_send_done(nc->resource, 0);
+        wl_resource_destroy(nc->resource);
+    }
+    wl_list_init(&surface->frameCallbackList);
+    wl_display_flush_clients(surface->compositor->m_display->childDisplay);
 }
 
 void WaylandCompositor::surfaceSetBufferTransform(struct wl_client* client, struct wl_resource* resource, int32_t transform)
@@ -337,24 +421,21 @@ void WaylandCompositor::doDestroyNestedSurface(struct NestedSurface* surface)
         wl_resource_destroy(cb->resource);
     wl_list_init(&surface->frameCallbackList);
 
-    // Release last attached buffer
-    if (surface->bufferResource) {
-        // FIXME: queing a buffer release here can produce segfault in some scnearios,
-        // but are we not leaking the buffer otherwise? We might need some more
-        // elaborate mechanism to release the buffer (see nested example in weston)
-        // wl_resource_queue_event(surface->bufferResource, WL_BUFFER_RELEASE);
-        surface->bufferResource = 0;
-    }
-
     // Destroy EGLImage
     if (surface->image != EGL_NO_IMAGE_KHR) {
         eglDestroyImage(surface->compositor->m_display->eglDisplay, surface->image);
         surface->image = 0;
     }
 
+    // Release current buffer
+    nestedBufferReference(&surface->bufferRef, NULL);
+
     // Delete GL texture
     glDeleteTextures(1, &surface->texture);
 
+    // Unlink this source from the compositor's surface list
+    wl_list_remove(&surface->link);
+
     g_free(surface);
 }
 
@@ -369,14 +450,11 @@ void WaylandCompositor::createSurface(struct wl_client* client, struct wl_resour
 {
     WaylandCompositor* compositor = static_cast<WaylandCompositor*>(wl_resource_get_user_data(resource));
 
-    // FIXME: For now we only support one surface/widget
-    if (compositor->m_surface) {
-        g_warning("Nested Wayland compositor only supports one surface.");
-    }
-
     struct NestedSurface* surface = g_new0(struct NestedSurface, 1);
     surface->compositor = compositor;
+
     wl_list_init(&surface->frameCallbackList);
+    surface->bufferDestroyListener.notify = surfaceHandlePendingBufferDestroy;
 
     // Create a GL texture to back this surface
     glGenTextures (1, &surface->texture);
@@ -390,8 +468,7 @@ void WaylandCompositor::createSurface(struct wl_client* client, struct wl_resour
     struct wl_resource* surfaceResource = wl_resource_create(client, &wl_surface_interface, 1, id);
     wl_resource_set_implementation(surfaceResource, &surfaceInterface, surface, destroyNestedSurface);
 
-    // FIXME: For now we only support one surface/widget
-    compositor->m_surface = surface;
+    wl_list_insert(compositor->m_surfaces.prev, &surface->link);
 }
 
 void WaylandCompositor::createRegion(struct wl_client* client, struct wl_resource* resource, uint32_t id)
@@ -411,6 +488,28 @@ void WaylandCompositor::compositorBind(wl_client* client, void* data, uint32_t v
     wl_resource_set_implementation(resource, &compositorInterface, compositor, 0);
 }
 
+void WaylandCompositor::wkgtkSetSurfaceForWidget(struct wl_client* client, struct wl_resource* resource, struct wl_resource* surfaceResource, uint32_t id)
+{
+    WaylandCompositor* compositor = static_cast<WaylandCompositor*>(wl_resource_get_user_data(resource));
+    GtkWidget* widget = getWidgetById(compositor, id);
+    if (!widget)
+        return;
+    struct NestedSurface* surface = static_cast<struct NestedSurface*>(wl_resource_get_user_data(surfaceResource));
+    setSurfaceForWidget(compositor, widget, surface);
+}
+
+static const struct wl_wkgtk_interface wkgtkInterface = {
+    WaylandCompositor::wkgtkSetSurfaceForWidget,
+};
+
+
+void WaylandCompositor::wkgtkBind(struct wl_client* client, void* data, uint32_t version, uint32_t id)
+{
+    WaylandCompositor* compositor = static_cast<WaylandCompositor*>(data);;
+    struct wl_resource* resource = wl_resource_create(client, &wl_wkgtk_interface, 1, id);
+    wl_resource_set_implementation(resource, &wkgtkInterface, compositor, 0);
+}
+
 bool WaylandCompositor::initialize()
 {
     // Create the nested display
@@ -436,6 +535,13 @@ bool WaylandCompositor::initialize()
         return false;
     }
 
+    // Bind the webkitgtk protocol extension
+    m_display->wkgtkGlobal = wl_global_create(m_display->childDisplay, &wl_wkgtk_interface, 1, this, wkgtkBind);
+    if (!m_display->wkgtkGlobal) {
+        g_warning("Nested Wayland compositor could not register webkitgtk global");
+        return false;
+    }
+
     if (!eglBindDisplay(m_display->eglDisplay, m_display->childDisplay)) {
         g_warning("Nested Wayland compositor could not bind nested display");
         return false;
@@ -466,62 +572,74 @@ WaylandCompositor* WaylandCompositor::instance()
 
 WaylandCompositor::WaylandCompositor()
     : m_display(0)
-    , m_surface(0)
-    , m_widget(0)
 {
+    wl_list_init(&m_surfaces);
 }
 
 WaylandCompositor::~WaylandCompositor()
 {
-    if (m_surface)
-        doDestroyNestedSurface(m_surface);
+    struct NestedSurface *surface, *next;
+    wl_list_for_each_safe(surface, next, &m_surfaces, link)
+        doDestroyNestedSurface(surface);
+    wl_list_init(&m_surfaces);
 
     if (m_display)
         destroyNestedDisplay(m_display);
 }
 
-// FIXME: For now we only support one widget/surface, in the future
-// we should be able to map multiple widgets to multiple surfaces
 void WaylandCompositor::addWidget(GtkWidget* widget)
 {
-    if (m_widget)
-        g_warning("Nested Wayland compositor only supports one widget.");
-    m_widget = widget;
+    static int nextWidgetId = 0;
+    g_object_set_data(G_OBJECT(widget), "wayland-compositor-widget-id", GINT_TO_POINTER(++nextWidgetId));
+    setSurfaceForWidget(this, widget, 0);
 }
 
-// FIXME: For now we only support one widget/surface, in the future
-// we should be able to map multiple widgets to multiple surfaces
-cairo_surface_t* WaylandCompositor::cairoSurfaceForWidget(GtkWidget *widget)
+void WaylandCompositor::removeWidget(GtkWidget* widget)
 {
-    if (widget != m_widget || !m_surface)
-        return 0;
-    return m_surface->cairoSurface;
+    struct NestedSurface* surface = getSurfaceForWidget(this, widget);
+    if (surface)
+        surface->widget = 0;
+
+    int widgetId = getWidgetId(widget);
+    if (widgetId) {
+        m_widgetHashMap.remove(widget);
+        g_object_steal_data(G_OBJECT(widget), "wayland-compositor-widget-id");
+    }
 }
 
-void WaylandCompositor::nextFrame()
+int WaylandCompositor::getWidgetId(GtkWidget* widget)
 {
-    if (!m_surface)
-        return;
-
-    // FIXME: When we support multiple surfaces/widgets we probably want to request
-    // the next frame for a specific widget only so we can throttle frame callbacks
-    // for that surface alone
+    return GPOINTER_TO_INT(g_object_get_data(G_OBJECT(widget), "wayland-compositor-widget-id"));
+}
 
-    // Process frame callbacks for the surface
-    struct NestedFrameCallback *nc, *next;
-    wl_list_for_each_safe (nc, next, &m_surface->frameCallbackList, link) {
-        wl_callback_send_done (nc->resource, 0);
-        wl_resource_destroy (nc->resource);
-    }
+struct NestedSurface* WaylandCompositor::getSurfaceForWidget(WaylandCompositor* compositor, GtkWidget* widget)
+{
+    return compositor->m_widgetHashMap.get(widget);
+}
 
-    wl_list_init (&m_surface->frameCallbackList);
-    wl_display_flush_clients (m_display->childDisplay);
+void WaylandCompositor::setSurfaceForWidget(WaylandCompositor* compositor, GtkWidget* widget, struct NestedSurface* surface)
+{
+    // Associate the new surface with the widget, the client is responsible
+    // for destroying any previous surface created for this widget
+    compositor->m_widgetHashMap.set(widget, surface);
+    if (surface)
+        surface->widget = widget;
+}
 
-    // Release the last buffer attached for this surface
-    if (m_surface->bufferResource) {
-        wl_resource_queue_event (m_surface->bufferResource, WL_BUFFER_RELEASE);
-        m_surface->bufferResource = 0;
+GtkWidget* WaylandCompositor::getWidgetById(WaylandCompositor* compositor, int id)
+{
+    for (HashMap<GtkWidget*, struct NestedSurface*>::iterator it = compositor->m_widgetHashMap.begin(); it != compositor->m_widgetHashMap.end(); ++it) {
+        GtkWidget* widget = it->key;
+        if (id == GPOINTER_TO_INT(g_object_get_data(G_OBJECT(widget), "wayland-compositor-widget-id")))
+            return widget;
     }
+    return 0;
+}
+
+cairo_surface_t* WaylandCompositor::cairoSurfaceForWidget(GtkWidget* widget)
+{
+    struct NestedSurface* surface = getSurfaceForWidget(this, widget);
+    return surface ? surface->cairoSurface : 0;
 }
 
 } // namespace WebCore
diff --git a/Source/WebCore/platform/gtk/WaylandCompositor.h b/Source/WebCore/platform/gtk/WaylandCompositor.h
index a3583b2..9dde562 100644
--- a/Source/WebCore/platform/gtk/WaylandCompositor.h
+++ b/Source/WebCore/platform/gtk/WaylandCompositor.h
@@ -43,42 +43,60 @@
 #include <cairo.h>
 #include <cairo-gl.h>
 
+#include <wtf/HashMap.h>
+
 #include "GLContext.h"
 #include "IntSize.h"
 #include "RefPtrCairo.h"
 
 namespace WebCore {
 
-struct NestedSurface;
 class WaylandCompositor;
 
 // Nested compositor display
 struct NestedDisplay {
-  GdkDisplay* gdkDisplay;               // Gdk display
-  struct wl_display* wlDisplay;         // Main Wayland display
-  struct wl_display* childDisplay;      // Nested display
-  EGLDisplay eglDisplay;                // EGL display
-  EGLConfig eglConfig;                  // EGL configuration
-  EGLContext eglCtx;                    // EGL context
-  cairo_device_t* eglDevice;            // EGL cairo device
-  struct wl_global* wlGlobal;           // Wayland global
-  GSource* eventSource;                 // Display event source
+    GdkDisplay* gdkDisplay;               // Gdk display
+    struct wl_display* wlDisplay;         // Main Wayland display
+    struct wl_display* childDisplay;      // Nested display
+    EGLDisplay eglDisplay;                // EGL display
+    EGLConfig eglConfig;                  // EGL configuration
+    EGLContext eglCtx;                    // EGL context
+    cairo_device_t* eglDevice;            // EGL cairo device
+    struct wl_global* wlGlobal;           // Wayland display global
+    struct wl_global* wkgtkGlobal;        // Wayland webkitgtk interface global
+    GSource* eventSource;                 // Display event source
+};
+
+struct NestedBuffer {
+    struct wl_resource* resource;
+    struct wl_signal destroySignal;
+    struct wl_listener destroyListener;
+    uint32_t busyCount;
+};
+
+struct NestedBufferReference {
+    struct NestedBuffer* buffer;
+    struct wl_listener destroyListener;
 };
 
 // Nested Wayland compositor surface
 struct NestedSurface {
-  WaylandCompositor* compositor;        // Nested compositor instance
-  struct wl_resource* bufferResource;   // Last attached buffer
-  GLuint texture;                       // GL texture for the surface
-  EGLImageKHR* image;                   // EGL Image for texture
-  cairo_surface_t* cairoSurface;        // Cairo surface for GL texture
-  struct wl_list frameCallbackList;     // Pending frame callback list
+    WaylandCompositor* compositor;        // Nested compositor instance
+    struct NestedBuffer* buffer;          // Last attached buffer (pending buffer)
+    GLuint texture;                       // GL texture for the surface
+    EGLImageKHR* image;                   // EGL Image for texture
+    cairo_surface_t* cairoSurface;        // Cairo surface for GL texture
+    struct wl_list frameCallbackList;     // Pending frame callback list
+    GtkWidget* widget;                    // widget associated with this surface
+    struct wl_listener bufferDestroyListener; // Pending buffer destroy listener
+    struct NestedBufferReference bufferRef;   // Current buffer
+    struct wl_list link;
 };
 
 // List of pending frame callbacks on a nested surface
 struct NestedFrameCallback {
-  struct wl_resource* resource;
-  struct wl_list link;
+    struct wl_resource* resource;
+    struct wl_list link;
 };
 
 class WaylandCompositor {
@@ -88,9 +106,13 @@ public:
 
     // WebKit integration
     void addWidget(GtkWidget*);
-    void nextFrame();
+    void removeWidget(GtkWidget*);
+    int getWidgetId(GtkWidget*);
     cairo_surface_t* cairoSurfaceForWidget(GtkWidget*);
 
+    // Wayland Webkit extension interface
+    static void wkgtkSetSurfaceForWidget(struct wl_client*, struct wl_resource*, struct wl_resource*, uint32_t);
+
     // Wayland compositor interface
     static void createSurface(struct wl_client*, wl_resource*, uint32_t);
     static void createRegion(struct wl_client*, wl_resource*, uint32_t);
@@ -117,17 +139,33 @@ private:
     static void destroyNestedDisplay(struct NestedDisplay*);
     bool initialize();
 
-    // Wayland callbacks
+    // Global binding
+    static void wkgtkBind(struct wl_client*, void*, uint32_t, uint32_t);
     static void compositorBind(struct wl_client*, void*, uint32_t, uint32_t);
+
+    // Widget/Surface mapping
+    static struct NestedSurface* getSurfaceForWidget(WaylandCompositor*, GtkWidget*);
+    static void setSurfaceForWidget(WaylandCompositor*, GtkWidget*, struct NestedSurface*);
+    static GtkWidget* getWidgetById(WaylandCompositor*, int);
+
+    // Surface management
     static void doDestroyNestedSurface(struct NestedSurface*);
-    static void destroyNestedSurface (struct wl_resource*);
-    static void destroyNestedFrameCallback (struct wl_resource*);
+    static void destroyNestedSurface(struct wl_resource*);
+    static void destroyNestedFrameCallback(struct wl_resource*);
+
+    // Buffer management
+    static void nestedBufferDestroyHandler(struct wl_listener*, void*);
+    static struct NestedBuffer* nestedBufferFromResource(struct wl_resource*);
+    static void surfaceHandlePendingBufferDestroy(struct wl_listener*, void*);
+    static void nestedBufferReference(struct NestedBufferReference*, struct NestedBuffer*);
+    static void nestedBufferReferenceHandleDestroy(struct wl_listener*, void*);
 
+    // Global instance
     static WaylandCompositor* m_instance;
 
     struct NestedDisplay* m_display;
-    struct NestedSurface* m_surface;
-    GtkWidget* m_widget;
+    HashMap<GtkWidget*, struct NestedSurface*> m_widgetHashMap;
+    struct wl_list m_surfaces;
 };
 
 } // namespace WebCore
diff --git a/Source/WebCore/platform/gtk/WaylandDisplay.cpp b/Source/WebCore/platform/gtk/WaylandDisplay.cpp
index e5729c0..0a557ab 100644
--- a/Source/WebCore/platform/gtk/WaylandDisplay.cpp
+++ b/Source/WebCore/platform/gtk/WaylandDisplay.cpp
@@ -44,6 +44,9 @@ void WaylandDisplay::registryHandleGlobal(void *data, struct wl_registry *regist
     if (strcmp(interface, "wl_compositor") == 0)
         display->m_compositor =
             static_cast<struct wl_compositor*>(wl_registry_bind(registry, name, &wl_compositor_interface, 1));
+    else if (strcmp(interface, "wl_wkgtk") == 0)
+        display->m_wkgtk =
+            static_cast<struct wl_wkgtk*>(wl_registry_bind(registry, name, &wl_wkgtk_interface, 1));
 }
 
 void WaylandDisplay::registryHandleGlobalRemove(void *data, struct wl_registry *registry, uint32_t name)
@@ -82,11 +85,12 @@ WaylandDisplay::WaylandDisplay(struct wl_display* wlDisplay)
     wl_display_roundtrip(m_display);
 }
 
-PassOwnPtr<WaylandSurface> WaylandDisplay::createSurface(int width, int height)
+PassOwnPtr<WaylandSurface> WaylandDisplay::createSurface(int width, int height, int widgetId)
 {
-    struct wl_surface *surface = wl_compositor_create_surface(m_compositor);
+    struct wl_surface* surface = wl_compositor_create_surface(m_compositor);
     EGLNativeWindowType native = wl_egl_window_create(surface, width, height);
     OwnPtr<WaylandSurface> wlSurface = WaylandSurface::create(surface, native);
+    wl_wkgtk_set_surface_for_widget(m_wkgtk, surface, widgetId);
     return wlSurface.release();
 }
 
diff --git a/Source/WebCore/platform/gtk/WaylandDisplay.h b/Source/WebCore/platform/gtk/WaylandDisplay.h
index 0bdccce..20901e5 100644
--- a/Source/WebCore/platform/gtk/WaylandDisplay.h
+++ b/Source/WebCore/platform/gtk/WaylandDisplay.h
@@ -36,6 +36,7 @@
 #include <wayland-client.h>
 
 #include "WaylandSurface.h"
+#include "WaylandWebkitGtkClientProtocol.h"
 
 namespace WebCore {
 
@@ -49,7 +50,7 @@ public:
     static void registryHandleGlobalRemove(void*, struct wl_registry*, uint32_t);
 
     // Display interface
-    PassOwnPtr<WaylandSurface> createSurface(int, int);
+    PassOwnPtr<WaylandSurface> createSurface(int, int, int);
     void destroySurface(WaylandSurface*);
     struct wl_display* nativeDisplay() { return m_display; }
 
@@ -62,6 +63,7 @@ private:
     struct wl_display* m_display;
     struct wl_registry* m_registry;
     struct wl_compositor* m_compositor;
+    struct wl_wkgtk* m_wkgtk;
 };
 
 }
diff --git a/Source/WebCore/platform/gtk/WaylandSurface.cpp b/Source/WebCore/platform/gtk/WaylandSurface.cpp
index dc89f8b..0f83f3f 100644
--- a/Source/WebCore/platform/gtk/WaylandSurface.cpp
+++ b/Source/WebCore/platform/gtk/WaylandSurface.cpp
@@ -33,23 +33,6 @@
 
 namespace WebCore {
 
-void WaylandSurface::frameCallback(void* data, struct wl_callback* callback, uint32_t time)
-{
-    // FIXME: Looks like this is never called. Why?
-    if (callback)
-        wl_callback_destroy(callback);
-}
-
-static const struct wl_callback_listener frameListener = {
-    WaylandSurface::frameCallback
-};
-
-void WaylandSurface::requestFrame()
-{
-    struct wl_callback* wlCallback = wl_surface_frame(m_surface);
-    wl_callback_add_listener(wlCallback, &frameListener, this);
-}
-
 PassOwnPtr<WaylandSurface> WaylandSurface::create(struct wl_surface* surface, EGLNativeWindowType native)
 {
     return adoptPtr(new WaylandSurface(surface, native));
diff --git a/Source/WebCore/platform/gtk/WaylandSurface.h b/Source/WebCore/platform/gtk/WaylandSurface.h
index 653b21e..31e4df3 100644
--- a/Source/WebCore/platform/gtk/WaylandSurface.h
+++ b/Source/WebCore/platform/gtk/WaylandSurface.h
@@ -45,13 +45,9 @@ public:
     static PassOwnPtr<WaylandSurface> create(struct wl_surface*, EGLNativeWindowType);
     virtual ~WaylandSurface();
 
-    // Wayland surface interface callbacks
-    static void frameCallback(void*, struct wl_callback*, uint32_t);
-
     // Surface interface
     EGLNativeWindowType nativeWindowHandle() { return m_native; }
     struct wl_surface* surface() { return m_surface; }
-    void requestFrame();
 
 private:
     WaylandSurface(struct wl_surface*, EGLNativeWindowType);
diff --git a/Source/WebCore/platform/gtk/wl-wkgtk.xml b/Source/WebCore/platform/gtk/wl-wkgtk.xml
new file mode 100644
index 0000000..c264846
--- /dev/null
+++ b/Source/WebCore/platform/gtk/wl-wkgtk.xml
@@ -0,0 +1,37 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="wl_wkgtk">
+
+  <copyright>
+    Copyright © 2013 Igalia S.L.
+
+    Permission to use, copy, modify, distribute, and sell this
+    software and its documentation for any purpose is hereby granted
+    without fee, provided that the above copyright notice appear in
+    all copies and that both that copyright notice and this permission
+    notice appear in supporting documentation, and that the name of
+    the copyright holders not be used in advertising or publicity
+    pertaining to distribution of the software without specific,
+    written prior permission.  The copyright holders make no
+    representations about the suitability of this software for any
+    purpose.  It is provided "as is" without express or implied
+    warranty.
+
+    THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+    SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+    FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+    SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+    AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+    ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
+    THIS SOFTWARE.
+  </copyright>
+
+  <interface name="wl_wkgtk" version="1">
+    <request name="set_surface_for_widget">
+      <arg name="surface" type="object" interface="wl_surface"/>
+      <arg name="id" type="uint"/>
+    </request>
+
+  </interface>
+
+</protocol>
diff --git a/Source/WebKit2/UIProcess/API/gtk/WebKitWebViewBase.cpp b/Source/WebKit2/UIProcess/API/gtk/WebKitWebViewBase.cpp
index 9fe945b..945bace 100644
--- a/Source/WebKit2/UIProcess/API/gtk/WebKitWebViewBase.cpp
+++ b/Source/WebKit2/UIProcess/API/gtk/WebKitWebViewBase.cpp
@@ -478,12 +478,6 @@ static bool webkitWebViewRenderAcceleratedCompositingResults(WebKitWebViewBase*
         cairo_fill(cr);
     }
 
-#if USE(EGL) && PLATFORM(WAYLAND) && defined(GDK_WINDOWING_WAYLAND) && !defined(GTK_API_VERSION_2)
-    if (displayType == DISPLAY_TYPE_WAYLAND) {
-        priv->waylandCompositor->nextFrame();
-    }
-#endif
-
     return true;
 }
 #endif
@@ -915,7 +909,10 @@ static void webkitWebViewBaseDestroy(GtkWidget* widget)
     WebKitWebViewBasePrivate* priv = WEBKIT_WEB_VIEW_BASE(widget)->priv;
     if (priv->authenticationDialog)
         gtk_widget_destroy(priv->authenticationDialog);
-
+#if USE(TEXTURE_MAPPER_GL) && USE(EGL) && PLATFORM(WAYLAND) && defined(GDK_WINDOWING_WAYLAND) && !defined(GTK_API_VERSION_2)
+    if (priv->waylandCompositor)
+        priv->waylandCompositor->removeWidget(widget);
+#endif
     GTK_WIDGET_CLASS(webkit_web_view_base_parent_class)->destroy(widget);
 }
 
@@ -1001,9 +998,19 @@ void webkitWebViewBaseCreateWebPage(WebKitWebViewBase* webkitWebViewBase, WebCon
     priv->pageProxy = context->createWebPage(*priv->pageClient, pageGroup);
     priv->pageProxy->initializeWebPage();
 
-#if USE(TEXTURE_MAPPER_GL) && defined(GDK_WINDOWING_X11)
-    if (priv->redirectedWindow)
-        priv->pageProxy->setAcceleratedCompositingWindowId(priv->redirectedWindow->windowId());
+#if USE(TEXTURE_MAPPER_GL)
+    DisplayType displayType = getDisplayType();
+    if (displayType == DISPLAY_TYPE_WAYLAND) {
+#if USE(EGL) && PLATFORM(WAYLAND) && defined(GDK_WINDOWING_WAYLAND) && !defined(GTK_API_VERSION_2)
+        if (priv->waylandCompositor)
+            priv->pageProxy->setAcceleratedCompositingWindowId(priv->waylandCompositor->getWidgetId(GTK_WIDGET(webkitWebViewBase)));
+#endif
+    } else {
+#if defined(GDK_WINDOWING_X11)
+        if (priv->redirectedWindow)
+            priv->pageProxy->setAcceleratedCompositingWindowId(priv->redirectedWindow->windowId());
+#endif
+    }
 #endif
 
     webkitWebViewBaseUpdatePreferences(webkitWebViewBase);
diff --git a/Source/WebKit2/WebProcess/WebPage/gtk/LayerTreeHostGtk.cpp b/Source/WebKit2/WebProcess/WebPage/gtk/LayerTreeHostGtk.cpp
index 56a1864..f4fb7f1 100644
--- a/Source/WebKit2/WebProcess/WebPage/gtk/LayerTreeHostGtk.cpp
+++ b/Source/WebKit2/WebProcess/WebPage/gtk/LayerTreeHostGtk.cpp
@@ -163,21 +163,19 @@ void LayerTreeHostGtk::initialize()
     if (m_displayType == DISPLAY_TYPE_WAYLAND) {
 #if USE(EGL) && PLATFORM(WAYLAND) && defined(GDK_WINDOWING_WAYLAND)
         // Request a wayland surface from the nested wayland compositor
+        IntSize webPageSize = m_webPage->size();
         WaylandDisplay* display = WaylandDisplay::instance();
-        m_wlSurface = display->createSurface(1, 1);
+        m_wlSurface = display->createSurface(webPageSize.width(), webPageSize.height(), m_webPage->nativeWindowHandle());
         if (!m_wlSurface)
             return;
-
-        // Resize the surface to match the size of the web page
-        IntSize webPageSize = m_webPage->size();
-        wl_egl_window_resize(m_wlSurface->nativeWindowHandle(), webPageSize.width(), webPageSize.height(), 0, 0);
-
-        // FIXME: We need a non-zero window handle so that webkit realizes we are good to go for AC.
-        // We can probably find a more elegant way to do this for Wayland
-        m_layerTreeContext.windowHandle = m_wlSurface->nativeWindowHandle() ? 1 : 0;
 #endif
-    } else
-        m_layerTreeContext.windowHandle = m_webPage->nativeWindowHandle();
+    }
+
+    // In the case of Wayland this is not really a native window handle
+    // but an internal ID generated by the nested compositor for the widget
+    // backed by this surface. We only need it to tell WebKit that we are
+    // good to go for AC here
+    m_layerTreeContext.windowHandle = m_webPage->nativeWindowHandle();
 
     GLContext* context = glContext();
     if (!context)
@@ -365,12 +363,6 @@ gboolean LayerTreeHostGtk::layerFlushTimerFiredCallback(LayerTreeHostGtk* layerT
 
 void LayerTreeHostGtk::queueLayerFlush(unsigned interval)
 {
-    if (m_displayType == DISPLAY_TYPE_WAYLAND) {
-#if USE(EGL) && PLATFORM(WAYLAND) && defined(GDK_WINDOWING_WAYLAND)
-        // Let the compositor know that we want to render a new frame
-        m_wlSurface->requestFrame();
-#endif
-    }
     m_layerFlushTimerCallbackId = g_timeout_add_full(GDK_PRIORITY_EVENTS, interval, reinterpret_cast<GSourceFunc>(layerFlushTimerFiredCallback), this, 0);
     g_source_set_name_by_id(m_layerFlushTimerCallbackId, "[WebKit] layerFlushTimerFiredCallback");
 }
